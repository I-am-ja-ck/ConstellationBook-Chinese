canister 、 存储 、 合约、Motoko 例子

https://stackoverflow.blog/2020/08/24/motoko-the-language-that-turns-the-web-into-a-computer/

https://icpleague.com/thread/3

https://icpleague.com/thread/287

https://medium.com/dfinity/software-canisters-an-evolution-of-smart-contracts-internet-computer-f1f92f1bfffb

https://fxa77-fiaaa-aaaae-aaana-cai.raw.ic0.app/

https://mp.weixin.qq.com/s/X6EWRXgey8uFooIfBEGzQg

https://mp.weixin.qq.com/s/uzo-FhD6W0wupxAXydQsmg

https://wiki.internetcomputer.org/wiki/Canister_smart_contract

https://wiki.internetcomputer.org/wiki/HTTPS_outcalls

https://forum.dfinity.org/t/inter-canister-query-calls-community-consideration/6754

https://forum.dfinity.org/t/custom-domains-for-ic0-app-community-consideration/6162

https://forum.dfinity.org/t/how-does-the-storage-mechanism-in-dfinity-works/2733

https://wiki.internetcomputer.org/wiki/IC_Smart_Contract_Memory

https://wiki.internetcomputer.org/wiki/HTTPS_outcalls

https://www.cnblogs.com/helios-fz/p/15905424.html

https://wiki.internetcomputer.org/wiki/Motoko_(programming_language)

https://mirror.xyz/0xFd007bb46C47D8600C139E34Df9DfceC86F0B319/iSQR3xzfXxOYERG5b2pUUiQvsgirEwBuEOJ649hvdio

https://www.bilibili.com/video/BV14Z4y1m7VB/?vd_source=db5bf130bc81934e0880088323df6748

https://wiki.internetcomputer.org/wiki/Canister_smart_contract#From_smart_contracts_to_canisters

https://wiki.internetcomputer.org/wiki/WebAssembly

https://wiki.internetcomputer.org/wiki/Exchange_rate_canister





Canister 里有一个叫做 Web Assembly（Wasm）字节码的东西，它代表了智能合约的程序；还有一组内存页面，它们代表了合约的状态。

你可以把内存页面就像是合约的笔记本。通过安装或更新计算机，我们可以修改 Wasm 字节码。当我们在合约上执行消息时，合约的状态就会发生变化，就好像是在合约记事本上做出了修改。





<img src="assets/1.canister/image-20230626184532186.png" style="zoom:50%;" />



每个 Canister 都运行在一个与其他 Canister 和系统其余部分隔离的沙盒环境中，确保数据的隐私和完整性。Canister 通过 WebAssembly（Wasm）运行时执行，它提供了内存安全和类型安全保证。Wasm 还限制了 Canister 可以访问的系统调用，防止恶意 Canister 执行有害操作。



翻译：容器

Internet Computer 上的智能合约以容器（canisters）的形式存在：它们是将代码和状态捆绑在一起的计算单元。每个容器都定义了可以被其他容器以及 IC 之外的各方（如浏览器或移动应用）调用的函数。容器通过异步消息相互通信，但每个此类消息的执行都是完全隔离的，允许大规模的并发执行。容器由控制器管理。容器的控制结构可以是集中式的（例如，当控制器包含一些集中式实体时）、去中心化的（当控制器是一个 DAO 时）甚至不存在，此时容器是一个不可变的智能合约。控制器是唯一可以将容器部署到 Internet Computer、启动/停止它们的执行并更新代码的实体。控制器还需要确保容器持有足够的循环。这些是在 IC 上用于获取容器执行资源（内存、网络带宽和计算能力）的单位。为此，IC 监控容器的资源使用情况，并从每个容器本地维护的循环余额中扣除费用。

深入了解



Motoko

Motoko 是一种新的智能合约编程语言。它旨在无缝支持 Internet Computer 的编程模型，并使其更容易利用区块链的独特功能。Motoko 是强类型的、基于 actor 的，并具有正交持久性和异步消息传递的内置支持。生产力和安全功能包括自动内存管理、泛型、类型推断、模式匹配以及任意精度和固定精度算术。消息传递透明地使用 Internet Computer 的 Candid 接口定义语言和有线格式进行类型化、高级和跨语言互操作性。

深入了解



认证变量

容器智能合约可以将变量声明为认证的。每当设置这些变量时，它们都会自动获得由 Internet Computer 区块链签名的 Merkle 树证书。这使得任何人都可以使用 Internet Computer 的公钥验证此类数据的真实性。





查询与更新调用（也就是消息）的主要区别在于，查询不能改变子网的复制状态，而更新调用可以。

**查询与更新调用的执行**：与更新调用类似，查询在一个节点上由多个线程同时执行。然而，子网中的所有节点可以同时执行不同的查询，因为查询不是以复制方式执行的。因此，子网的查询吞吐量随着子网中节点数量的增加而线性增加，而更新调用性能随着节点数量的增加而降低。

**查询与以太坊的类比**：查询类似于在以太坊区块链上的本地或云节点上进行的读取操作。去中心化应用（dApp）应仅将查询用于非关键操作。当需要读取关键信息（例如，用于决策的财务数据）时，应使用更新调用获取此类信息，因为更新调用的响应经过子网的BLS阈值签名认证，并可使用子网的公钥进行验证。

**内存处理**：执行层的关键职责之一是管理 Canister 字节码和状态（统称为内存）。一个子网所能容纳的复制状态不受节点机器可用 RAM 的限制，而是受可用 SSD 存储的限制。然而，可用 RAM 会影响子网的性能，尤其是内存页面的访问延迟。这很大程度上取决于工作负载的访问模式，就像在传统计算机系统中一样。

IC 的节点机器配备有数十 TB 的高端 SSD 存储，以及半 TB 以上的 RAM ，可以容纳大量的复制 Canister 状态和 Wasm 代码，并在访问内存时实现良好性能。执行 Canister 时获得的状态由消息路由的状态管理组件进行认证（即数字签名）。每轮都会认证部分状态，包括入口历史记录和发送到其他子网络的消息。整个子网络的状态（包括该子网络托管的所有 Canister 的状态）在每个（较长的）检查点间隔内认证一次。





让 GPT 解读一下：

#### Single canister message execution 

For security and reliability, each canister is executed within a sandboxed environment that isolates it from other canisters and the rest of the system. For executing each individual message, the scheduler brings up the sandbox process hosting the canister and executes the canister on the provided message. If the sandbox does not yet exist, it compiles the canister, creates the sandbox which contains a Wasm runtime and loads the canister compiled code. The message is then executed by invoking the runtime.  Each message execution can lead to new messages to other canisters, memory pages of the canister's state being modified, and/or a response to be generated. If the response corresponds to an ingress message then the response is written to the ingress history from where it can be read by the sender of the ingress message. This information, together with the number of instructions consumed are returned to the execution environment for bookkeeping purposes.

Bookkeeping associated with requests is maintained in a call context associated with that request. This is a data structure which keeps track of information related to the call, among other things, where it originates, whether the call has been answered, etc. Calls to other canisters are recorded in the call context and placed in the output queues of the canister. If a response is generated this is placed in the ingress history if it is a response to an ingress message; the call context records that the call had been answered and the response is stored in the ingress history for some fixed amount of time.

Executing a response is similar to executing a request: the difference is that the response is executed within the call context of the request that triggered it. The other steps are as above.



### 心跳和定时器

 Canister 具有通过设置心跳或定时方法来定期安排任务的能力。在内部，这是通过将消息放入 Canister 特定的任务队列来实现的。当一个 Canister 被安排执行时，调度器以轮询方式选择执行任务还是消息。

### 管理单元消息

IC 上的几种操作被发送到所谓的管理单元并由其执行。这不是一个 Canister 本身：发送给管理 Canister 的消息被引导到相关子网络（见下面的一些示例），并由执行环境拦截并触发它们的执行。

从技术上讲，这是通过两个特定于子网络的队列实现的，一个用于输入消息，另一个用于输出消息。在每轮开始时，这些队列中的消息被优先执行。

### 管理单元

对于其中一些消息，执行完全局限于执行环境。这是管理 Canister 的消息（用于创建、更新设置、启动、停止单元的消息）的情况。发出这些消息时，它们被路由到托管相应 Canister 的子网络（对于单元创建，正确的子网络是在带外决定的），并包含在子网络队列中。在每轮开始时，调度器依次选择并调用执行环境以执行其中的若干消息。执行结果要么是全局复制状态更改（即创建新 Canister 时），要么是某个 Canister 的本地更改（即安装代码或更新 Canister 设置）。生成一个响应，例如，表示执行结果的状态，并将其路由回发出 Canister 管理消息的发件人。

### ECDSA消息

其他管理 Canister 消息，如用于 ECDSA 操作的消息，通过涉及互联网计算机软件堆栈的其他组件来执行。这样的消息被路由到一个特殊的子网络（以阈值方式持有 ECDSA 主密钥的子网络），并排队到该子网络的队列。当调度执行时，它们被执行环境捕获，然后涉及共识层，然后引导子网络中的副本生成签名份额，收集份额并构建相关签名，然后将其返回到子网络的输出队列。

### 比特币消息

这些消息被发送到比特币 Canister ；它们被重新路由到托管比特币 Canister 的子网络，并排队到该 Canister 的输入队列。提供的响应直接路由到发出请求的 Canister 。

### 随机数生成

 Canister 可以向管理请求发送请求，从 IC 获取随机位。为了回答这些请求，执行环境使用 IC 每轮通过数字签名方案生成的随机位。具体来说，每轮 IC 上的每个子网络都会产生一个 BLS 签名。尽管是确定性生成的，但在产生签名之前，签名的位是不可预测的。从该签名中提取熵，并将其用作伪随机生成器的种子，以生成前一轮中由 Canister 发出的随机请求所需的伪随机位。



许多应用程序都受益于或需要一个安全的随机数生成器。然而，以简单的方式作为执行过程的一部分生成随机数会轻易破坏确定性，因为每个副本都会计算不同的随机性。IC 通过让执行层访问一个称为随机带的去中心化伪随机数生成器来解决这个问题。随机带是用链密钥加密技术构建的。每一轮，子网络都会生成一个新的阈值 BLS 签名，这种签名本质上是不可预测和均匀分布的。然后，这个签名可以作为加密伪随机生成器的种子。这为 Canister 提供了一个高效且安全的随机数来源，这也是互联网计算机的另一个独特功能。



每个子网都拥有**分布式伪随机生成器（以下简称PRG）**的访问权限。伪随机位可以从一个由 (f+1)/n 的 BLS 阈值签名衍生而来，被称为**随机磁带**。共识协议的每一轮都有一个不同的随机磁带。虽然此 BLS 签名与共识中使用的随机信标的签名相似，其机制却略有不同。

在共识协议中，一旦块高 h 的区块被最终确认，每个诚实节点将释放其在 h+1 块高下随机磁带中的片段。此处隐藏两点含义：

1. 在块高 h 的区块被任何诚实副本最终确认前，块高 h+1 的随机磁带是被确保为不可预测的。
2. 在块高 h+1 的区块被任何诚实副本确认时，该节点副本一般将拥有所有所需的片段以构建块高 h+1 的随机磁带。

例如在轮次 h 时，子网为获得二进制伪随机数，需要从执行层发起 “ 系统调用 ” 。当块高 h+1 的随机磁带可用时，系统随后就会响应该请求。根据上述的特性（1），我们可以确保在请求发起时，被请求的二进制伪随机数是不可预测的。基于上述的特性（2），一般在下个区块被最终确认时，被请求的二进制伪随机数即可获取。事实上，在当前的实现中，在块高 h 的区块被最终确认时，共识层将会同时递交块高 h 的区块（其荷载）以及 h+1 的随机磁带来给消息路由层处理。



每个子网都可以访问**分布式伪随机生成器(PRG)**。二进制伪随机数的种子是被称为随机磁带(Random Tape)的阈值签名。共识协议的每一轮都会有一个不同的随机磁带。

随机磁带的基本特性有

1. 在块高ℎ的区块被任意诚实节点副本确认之前，块高ℎ+1的随机磁带是不可预测的。
2. 在块高ℎ+1的区块被任意诚实节点副本确认的时间点前，节点副本已经有构建块高ℎ+1的随机磁带的所有片段

例如在轮次ℎ时，子网为获得二进制伪随机数，需要从执行层发起“系统调用”。系统随后将响应块高ℎ+1的随机磁带。根据上述的特性（1），协议保证在子网发送请求时，请求的二进制伪随机数不可预测。事实上，共识层会将随机磁带和荷载都传递给消息路由层；根据上述的特性（2），一般不会引起任何额外的延迟。





查询调用和更新调用

针对那些处理时不会变更状态的入口消息，可以进行一项重要的优化。他们被称为**查询调用**—而相对的其他入口消息，被称为**更新调用**。

查询调用被允许进行只读或是可能改变容器状态的计算，但是任何对副本状态的更新都不会被提交给复制状态。正因如此，查询调用可以被单个副本直接处理而不需要经过共识，这极大的降低了从查询调用获得响应的延迟。



查询调用的响应不记录在入口历史中（入口历史只记录更新调用的响应），所以也不能用每轮认证状态验证。但 IC 提供了另一种验证机制，就是**认证变量**（certied variables）。

如果查询调用的内容是认证变量，那么查询调用就是安全的、可验证的。因为 Canister 的认证变量是被哈希之后也记录在每轮认证状态里了。而每轮认证状态是经过共识的。



---



但是，我们提供了一种单独的用于验证该类响应的机制：**认证变量**（certied variables）。作为每轮认证状态中的一部分，每个子网下的容器都被分配了一小段字节，这便是该容器的认证变量，其值可通过更新调用进行更新，也可被每轮认证状态机制来进行验证。另外，容器也可使用其认证变量来存储默克尔树的的根节点。通过这种方式，只要查询调用的响应是该容器中以认证变量为根的默克尔树的叶节点，即可被验证。





### 查询调用(query calls)和更新调用(update calls)

正如我们之前所述，所有的入口消息必须经过共识，才能被子网的所有节点副本按相同的顺序进行处理。但是，针对那些处理时不会变更状态的入口消息，可以进行一项重要的优化。他们被称为**查询调用**—而相对的其他入口消息，被称为**更新调用**。查询调用被允许进行只读或是可能改变容器状态的计算，但是任何对节点副本状态的更新都不会被提交给复制状态。正因如此，查询调用可以被单个节点副本直接处理而不需要经过共识，这极大的降低了从查询调用获得响应的延迟。

一般而言，对查询调用的响应不会记录在*入口历史*的数据结构中，因此也不可以用之前的每轮认证状态进行验证。然而，IC使容器可以存储数据（在处理更新调用时）在特殊的认证变量中(certified variables)，可以利用这一机制验证数据的有效性；这样的话，查询调用可以返回值并存储在经认证变量中，仍然可以被验证。



### 外部用户验证(External user authentication)

入口消息和跨子网消息的一个主要区别在于用于验证消息的机制。链钥密码学用于验证跨子网消息，另一个不同的机制用于来自外部用户的入口消息。

IC中没有外部用户的中央注册表。相反，外部用户通过一串公钥哈希作为**用户标识**（又称*principal*）来向容器来标识自己。用户自己持有对应的签名密钥，用来签署入口消息。签名和公钥会随着入口消息一起发送。IC将自动验证签名并传递用户标识给到对应的容器。随后该容器根据用户标识和入口消息中指定操作的其他参数，批准请求的操作。

新用户在首次与IC交互时会生成一对密钥对并从公钥中衍生出他们的用户标识。老用户根据存储在用户代理中的私钥完成验证。用户还可以用签名委托的方式，将多个密钥对关联到一个用户身份上。该特性非常有用，因为它允许了一个用户在多个设备上通过相同的用户身份证明来访问IC。











### 关于容器数据扩容

DFINITY 的优势在于大规模高性能的去中心化数据库存取，DFINITY 的程序以容器为单位运行，容器中会存储业务相关的数据库，且容器之间不会共享状态数据。而目前 DFINITY 容器存储上限是 64G ，如果一个业务容器的 64G 存满之后，容器就需要面临扩容的问题，该如何解决？

目前 DFINITY 能允许容器在存储与带宽等资源即将耗尽时，自动 Fork 出一个新容器进行扩容。新的容器中只保存了最近的状态数据，会丢弃历史。两个容器间依然通过异步调用来实现交互。

同时，在设计容器时，需要把各种级别的数据分开存放。举个例子，如果直接在 DFINITY 上建立一个钱包容器，交易记录的数据量会比用户地址的数据大很多。如果这时候把这两类数据放入一个容器，就会影响后续的扩容能力。

因此我们需要把对最终一致性要求相同的数据放在一起。比如在将钱包的余额与地址放在一起，而交易记录就可以通过分片存放在不同的容器中。从而实现系统的自动弹性扩容。



### 探索新的编程范式

显然想要在 DFINITY 保证安全性地实现复杂应用，我们需要探索新的范式。

最终一致性与确定性在传统互联网的分布式架构下有一些解决方案，这是值得我们借鉴的。DFINITY 上的智能合约需要关注的是数据的最终一致性，从写入和读取入手。

首先当我们需要很强安全性保证时，可能把整个所有的逻辑放在一个容器里面。主要在一个容器中，所有的交易都是原子性的，这里确保了事务与数据两个层面的一致性。但这种方式面临着扩容的噩梦，显然是偷懒的做法。

传统互联网其实关注的是数据库中数据的一致性，而在 DFINITY 中其实分为两个部分：一个是业务层面的，这部分是可以通过更新合约变化的，我们其实不太需要保证这里的原子性；而还有一部分是数据层面的，也就是进入正交持久性的数据，落盘的数据，这才是我们需要保证一致性与原子性的地方。

在 DFINITY 中有使用了名为 stable 的变量类型来定义落盘的数据，这其实类似于传统的数据库，目前也有多个团队在做 DFINITY 的数据库引擎，有了这个底层落盘数据的一致性与原子性，上层的业务的安全性就依靠数据来保证一致性。

如果是借鉴原来分布式事务的概念，我们有四种方式实现这个能力：

* tcc 两端事务提交，这是目前银行转账使用的机制，在交易发生时我们先直接更新数据库的 stable 的最终一致数据，等大家都确认清楚后，再去提交。
* saga 的事务处理机制，首先建立一个事务协调程序，当某个容器需要发起一次跨合约的调用时可以向事务协调程序申请一个 ID，并通过这个 ID 向事务的终结程序汇报，最后大家都提交成功后，再进行整体的提交。
* 使用事务观察者模式，对 stable 的状态进行包装，每当发生状态的更新操作时，观察者都去记录更新前后的两个值，如果发现某一个事务失败，观察者会就使用之前的值回滚操作。



### 原子性问题

一切即 actor ，DFINITY 使用的编程模型与传统区块链有一定差异，反而与传统互联网的 akka 类似。

DFINITY 中的智能合约（即容器）之间的交互也与以太坊不同，DFINITY 的智能合约内部是向存在一个唯一线程，但是容器之间的交互是通过发送异步消息进行，因此容器间可以进行异步操作。如果一个容器向另一个容器发送请求后，需要等待另一个容器的处理结果，才能进行下一步操作。

DFINITY 中存在很多个对等的子网，智能合约会随机的部署上子网。对于部署合约的开发者与使用合约的用户来说，他们并不知道这个合约运行在哪一个子网中，因为片间通讯是无感的。在同一个子网的两个容器的交互，与在不同子网上两个容器的交互，在延迟、安全性、复杂度上都没有差别，因此无法感知到子网之间的差别。这也是异步消息系统的好处。

这样 DFINITY 获得了近乎无限的扩容能力，大大提升了通用计算能力。但这也导致了合约间的交互失去了原子性，而在以太坊上利用原子性特点实现了很多独特的服务，比如 DeFi 的闪电贷清算机制。

在失去了原子性后，开发者面临着新的挑战，特别是在实现 DeFi 应用上，如果依然按照过去以太坊上的编程范式，这导致交易失败后状态无法恢复的问题。

比如，如果在 DFINITY 上实现了设计多个容器交互的复杂应用，比如一个借贷应用，需要与稳定币、借出代币、流动性凭证三个合约交互，三个合约都成功调用才能完成借贷。但如果强行在 DFINITY 实现以太坊范式的调用，如果其中两个合约成功，而最后一个调用没有响应，那么借贷交易会失败，并且前两个合约的状态却已经完成，就会卡住，而不会退回去。表现在用户这边，就是钱已经质押上去，代币已经扣走，却没法完成借贷，也没有收到退款。





## Wallet

Wallet 是允许存储和管理 cycles 的专用 canister 。Wallet 要归属于某个身份。



## Principal

Principal 本质是一种标识符，可以用于标识身份和 Canister（未来可能还有其他）。

比如可以使用 Principal ID 标识一个身份，当你第一次使用 Dfinity Canister SDK 时，dfx 命令行工具会为你创建 default 开发者身份（和一对公钥私钥），default 这个开发者身份就是由 Principal ID 标识。

注意，开发者身份还可用于派生 Account ID（类似于以太坊地址），以代表「身份」将 ICP 代币保存在 Ledger Canister 中。

同样，Canister ID 也是一种 Principal。

所以当说起 Principal 时，它可能会同时代表某个身份或者某个 Canister，比如 Wallet Canister。



## Controller

Controller 是具有安装、升级、删除 Canister 权限的 Principal。

一般情况下，一个 Canister 的 Controller 可以指定为某个身份、或者某个身份对应的 Wallet Canister。

在 dfx 0.9 之后，默认「身份」是 Canister 的 Controller 了，Wallet Canister 不再是默认 Controller（相当于 dfx 指定了 --no-wallet）。

