canister 、 存储 、 合约、Motoko 例子

https://stackoverflow.blog/2020/08/24/motoko-the-language-that-turns-the-web-into-a-computer/

https://icpleague.com/thread/3

https://icpleague.com/thread/287

https://medium.com/dfinity/software-canisters-an-evolution-of-smart-contracts-internet-computer-f1f92f1bfffb

https://fxa77-fiaaa-aaaae-aaana-cai.raw.ic0.app/

https://mp.weixin.qq.com/s/X6EWRXgey8uFooIfBEGzQg

https://mp.weixin.qq.com/s/uzo-FhD6W0wupxAXydQsmg

https://wiki.internetcomputer.org/wiki/Canister_smart_contract

https://wiki.internetcomputer.org/wiki/HTTPS_outcalls

https://forum.dfinity.org/t/inter-canister-query-calls-community-consideration/6754

https://forum.dfinity.org/t/custom-domains-for-ic0-app-community-consideration/6162

https://forum.dfinity.org/t/how-does-the-storage-mechanism-in-dfinity-works/2733

https://wiki.internetcomputer.org/wiki/IC_Smart_Contract_Memory

https://wiki.internetcomputer.org/wiki/HTTPS_outcalls

https://www.cnblogs.com/helios-fz/p/15905424.html

https://wiki.internetcomputer.org/wiki/Motoko_(programming_language)

https://mirror.xyz/0xFd007bb46C47D8600C139E34Df9DfceC86F0B319/iSQR3xzfXxOYERG5b2pUUiQvsgirEwBuEOJ649hvdio

https://www.bilibili.com/video/BV14Z4y1m7VB/?vd_source=db5bf130bc81934e0880088323df6748

https://wiki.internetcomputer.org/wiki/Canister_smart_contract#From_smart_contracts_to_canisters

https://wiki.internetcomputer.org/wiki/WebAssembly

https://wiki.internetcomputer.org/wiki/Exchange_rate_canister





Canister 里有一个叫做 Web Assembly（Wasm）字节码的东西，它代表了智能合约的程序；还有一组内存页面，它们代表了合约的状态。

你可以把内存页面就像是合约的笔记本。通过安装或更新计算机，我们可以修改 Wasm 字节码。当我们在合约上执行消息时，合约的状态就会发生变化，就好像是在合约记事本上做出了修改。





<img src="assets/1.canister/image-20230626184532186.png" style="zoom:50%;" />



每个 Canister 都运行在一个与其他 Canister 和系统其余部分隔离的沙盒环境中，确保数据的隐私和完整性。Canister 通过 WebAssembly（Wasm）运行时执行，它提供了内存安全和类型安全保证。Wasm 还限制了 Canister 可以访问的系统调用，防止恶意 Canister 执行有害操作。



翻译：容器

Internet Computer 上的智能合约以容器（canisters）的形式存在：它们是将代码和状态捆绑在一起的计算单元。每个容器都定义了可以被其他容器以及 IC 之外的各方（如浏览器或移动应用）调用的函数。容器通过异步消息相互通信，但每个此类消息的执行都是完全隔离的，允许大规模的并发执行。容器由控制器管理。容器的控制结构可以是集中式的（例如，当控制器包含一些集中式实体时）、去中心化的（当控制器是一个 DAO 时）甚至不存在，此时容器是一个不可变的智能合约。控制器是唯一可以将容器部署到 Internet Computer、启动/停止它们的执行并更新代码的实体。控制器还需要确保容器持有足够的循环。这些是在 IC 上用于获取容器执行资源（内存、网络带宽和计算能力）的单位。为此，IC 监控容器的资源使用情况，并从每个容器本地维护的循环余额中扣除费用。

深入了解



Motoko

Motoko 是一种新的智能合约编程语言。它旨在无缝支持 Internet Computer 的编程模型，并使其更容易利用区块链的独特功能。Motoko 是强类型的、基于 actor 的，并具有正交持久性和异步消息传递的内置支持。生产力和安全功能包括自动内存管理、泛型、类型推断、模式匹配以及任意精度和固定精度算术。消息传递透明地使用 Internet Computer 的 Candid 接口定义语言和有线格式进行类型化、高级和跨语言互操作性。

深入了解



认证变量

容器智能合约可以将变量声明为认证的。每当设置这些变量时，它们都会自动获得由 Internet Computer 区块链签名的 Merkle 树证书。这使得任何人都可以使用 Internet Computer 的公钥验证此类数据的真实性。





查询与更新调用（也就是消息）的主要区别在于，查询不能改变子网的复制状态，而更新调用可以。

**查询与更新调用的执行**：与更新调用类似，查询在一个节点上由多个线程同时执行。然而，子网中的所有节点可以同时执行不同的查询，因为查询不是以复制方式执行的。因此，子网的查询吞吐量随着子网中节点数量的增加而线性增加，而更新调用性能随着节点数量的增加而降低。

**查询与以太坊的类比**：查询类似于在以太坊区块链上的本地或云节点上进行的读取操作。去中心化应用（dApp）应仅将查询用于非关键操作。当需要读取关键信息（例如，用于决策的财务数据）时，应使用更新调用获取此类信息，因为更新调用的响应经过子网的BLS阈值签名认证，并可使用子网的公钥进行验证。

**内存处理**：执行层的关键职责之一是管理 Canister 字节码和状态（统称为内存）。一个子网所能容纳的复制状态不受节点机器可用 RAM 的限制，而是受可用 SSD 存储的限制。然而，可用 RAM 会影响子网的性能，尤其是内存页面的访问延迟。这很大程度上取决于工作负载的访问模式，就像在传统计算机系统中一样。

IC 的节点机器配备有数十 TB 的高端 SSD 存储，以及半 TB 以上的 RAM ，可以容纳大量的复制 Canister 状态和 Wasm 代码，并在访问内存时实现良好性能。执行 Canister 时获得的状态由消息路由的状态管理组件进行认证（即数字签名）。每轮都会认证部分状态，包括入口历史记录和发送到其他子网络的消息。整个子网络的状态（包括该子网络托管的所有 Canister 的状态）在每个（较长的）检查点间隔内认证一次。





让 GPT 解读一下：

#### Single canister message execution 

For security and reliability, each canister is executed within a sandboxed environment that isolates it from other canisters and the rest of the system. For executing each individual message, the scheduler brings up the sandbox process hosting the canister and executes the canister on the provided message. If the sandbox does not yet exist, it compiles the canister, creates the sandbox which contains a Wasm runtime and loads the canister compiled code. The message is then executed by invoking the runtime.  Each message execution can lead to new messages to other canisters, memory pages of the canister's state being modified, and/or a response to be generated. If the response corresponds to an ingress message then the response is written to the ingress history from where it can be read by the sender of the ingress message. This information, together with the number of instructions consumed are returned to the execution environment for bookkeeping purposes.

Bookkeeping associated with requests is maintained in a call context associated with that request. This is a data structure which keeps track of information related to the call, among other things, where it originates, whether the call has been answered, etc. Calls to other canisters are recorded in the call context and placed in the output queues of the canister. If a response is generated this is placed in the ingress history if it is a response to an ingress message; the call context records that the call had been answered and the response is stored in the ingress history for some fixed amount of time.

Executing a response is similar to executing a request: the difference is that the response is executed within the call context of the request that triggered it. The other steps are as above.



### 心跳和定时器

 Canister 具有通过设置心跳或定时方法来定期安排任务的能力。在内部，这是通过将消息放入 Canister 特定的任务队列来实现的。当一个 Canister 被安排执行时，调度器以轮询方式选择执行任务还是消息。

### 管理单元消息

IC 上的几种操作被发送到所谓的管理单元并由其执行。这不是一个 Canister 本身：发送给管理 Canister 的消息被引导到相关子网络（见下面的一些示例），并由执行环境拦截并触发它们的执行。

从技术上讲，这是通过两个特定于子网络的队列实现的，一个用于输入消息，另一个用于输出消息。在每轮开始时，这些队列中的消息被优先执行。

### 管理单元

对于其中一些消息，执行完全局限于执行环境。这是管理 Canister 的消息（用于创建、更新设置、启动、停止单元的消息）的情况。发出这些消息时，它们被路由到托管相应 Canister 的子网络（对于单元创建，正确的子网络是在带外决定的），并包含在子网络队列中。在每轮开始时，调度器依次选择并调用执行环境以执行其中的若干消息。执行结果要么是全局复制状态更改（即创建新 Canister 时），要么是某个 Canister 的本地更改（即安装代码或更新 Canister 设置）。生成一个响应，例如，表示执行结果的状态，并将其路由回发出 Canister 管理消息的发件人。

### ECDSA消息

其他管理 Canister 消息，如用于 ECDSA 操作的消息，通过涉及互联网计算机软件堆栈的其他组件来执行。这样的消息被路由到一个特殊的子网络（以阈值方式持有 ECDSA 主密钥的子网络），并排队到该子网络的队列。当调度执行时，它们被执行环境捕获，然后涉及共识层，然后引导子网络中的副本生成签名份额，收集份额并构建相关签名，然后将其返回到子网络的输出队列。

### 比特币消息

这些消息被发送到比特币 Canister ；它们被重新路由到托管比特币 Canister 的子网络，并排队到该 Canister 的输入队列。提供的响应直接路由到发出请求的 Canister 。

### 随机数生成

 Canister 可以向管理请求发送请求，从 IC 获取随机位。为了回答这些请求，执行环境使用 IC 每轮通过数字签名方案生成的随机位。具体来说，每轮 IC 上的每个子网络都会产生一个 BLS 签名。尽管是确定性生成的，但在产生签名之前，签名的位是不可预测的。从该签名中提取熵，并将其用作伪随机生成器的种子，以生成前一轮中由 Canister 发出的随机请求所需的伪随机位。



许多应用程序都受益于或需要一个安全的随机数生成器。然而，以简单的方式作为执行过程的一部分生成随机数会轻易破坏确定性，因为每个副本都会计算不同的随机性。IC 通过让执行层访问一个称为随机带的去中心化伪随机数生成器来解决这个问题。随机带是用链密钥加密技术构建的。每一轮，子网络都会生成一个新的阈值 BLS 签名，这种签名本质上是不可预测和均匀分布的。然后，这个签名可以作为加密伪随机生成器的种子。这为 Canister 提供了一个高效且安全的随机数来源，这也是互联网计算机的另一个独特功能。



每个子网都拥有**分布式伪随机生成器（以下简称PRG）**的访问权限。伪随机位可以从一个由 (f+1)/n 的 BLS 阈值签名衍生而来，被称为**随机磁带**。共识协议的每一轮都有一个不同的随机磁带。虽然此 BLS 签名与共识中使用的随机信标的签名相似，其机制却略有不同。

在共识协议中，一旦块高 h 的区块被最终确认，每个诚实节点将释放其在 h+1 块高下随机磁带中的片段。此处隐藏两点含义：

1. 在块高 h 的区块被任何诚实副本最终确认前，块高 h+1 的随机磁带是被确保为不可预测的。
2. 在块高 h+1 的区块被任何诚实副本确认时，该节点副本一般将拥有所有所需的片段以构建块高 h+1 的随机磁带。

例如在轮次 h 时，子网为获得二进制伪随机数，需要从执行层发起 “ 系统调用 ” 。当块高 h+1 的随机磁带可用时，系统随后就会响应该请求。根据上述的特性（1），我们可以确保在请求发起时，被请求的二进制伪随机数是不可预测的。基于上述的特性（2），一般在下个区块被最终确认时，被请求的二进制伪随机数即可获取。事实上，在当前的实现中，在块高 h 的区块被最终确认时，共识层将会同时递交块高 h 的区块（其荷载）以及 h+1 的随机磁带来给消息路由层处理。
