https://www.reddit.com/r/dfinity/comments/o4zdy6/we_are_david_johan_nicolas_and_ryan_ask_us

---

https://medium.com/dfinity/understanding-the-internet-computers-network-nervous-system-neurons-and-icp-utility-tokens-730dab65cae8

https://medium.com/dfinity/getting-started-on-the-internet-computers-network-nervous-system-app-wallet-61ecf111ea11

https://allthingsinternetcomputer.substack.com/p/how-you-can-earn-icp-through-the

https://icpleague.com/thread/517

https://internetcomputer.org/how-it-works/network-nervous-system-nns/

https://medium.com/dfinity/the-dfinity-blockchain-nervous-system-a5dd1783288e

https://medium.com/dfinity/future-governance-integrating-traditional-ai-technology-into-the-blockchain-nervous-system-825ababf9d9

https://dominic-w.medium.com/part-i-of-daos-new-horizons-and-challenges-in-depth-653c79c5ef5

https://wiki.internetcomputer.org/wiki/Limitless_Scaling

https://wiki.internetcomputer.org/wiki/New_Subnet_Creation

https://tingfei.space/posts/nns_summary/

https://www.cnblogs.com/helios-fz/p/15547991.html

https://wiki.internetcomputer.org/wiki/Network_Nervous_System

https://zhuanlan.zhihu.com/p/404721913

https://zhuanlan.zhihu.com/p/378362565

---

https://dashboard.internetcomputer.org/sns

https://dashboard.internetcomputer.org/neurons

sns1：https://sqbzf-5aaaa-aaaam-aavya-cai.ic0.app

https://internetcomputer.org/docs/current/developer-docs/integrations/sns

https://internetcomputer.org/sns

https://medium.com/dfinity/how-the-service-nervous-system-sns-will-bring-tokenized-governance-to-on-chain-dapps-b74fb8364a5c

https://www.youtube.com/watch?v=nZBWx6y070Y

https://wiki.internetcomputer.org/wiki/Service_Nervous_System_(SNS)

https://internetcomputer.org/sns/faq

https://wiki.internetcomputer.org/wiki/Proof_of_Personhood#Personhood_Score

https://wiki.internetcomputer.org/wiki/New_Subnet_Creation



## NNS是干嘛的

正如在前面总结链钥密码学时所说：

***IC 最伟大的创新在于：通过一系列复杂的密码学技术，实现了子网内部自己达成共识，可以理解为一种分片技术。有了链钥密码学技术，子网之间可以进行安全的跨子网通信。因为不需要整个网络的全局共识，IC 可以通过添加更多子网来实现横向扩展。***



从技术架构上来讲，IC 可以无限扩容。只要需要，就可以不断添加新子网进来。但是对于单个子网来说，在子网内部进行共识的时候，成员是固定的，因为 BLS 阈值签名的私钥片段已经提前分发给共识委员会的成员了。就算有新副本要加入子网也得先 “ 待命 ” ，等下个时期开始时再分享私钥片段。所以对于单个子网来说，成员需要保持相对稳定，不能像比特币那样能随时随地加入挖矿。

另外，IC 能不断创造子网（分片），这就需要一个地方统计这些子网，不然坏人也组建一个子网冒充 IC 的子网就不好了。如果可以随意创建子网，那么子网之间沟通和信任的成本就会大幅增加，每个跨子网信息都需要经过层层验证，成本忒太高了。＞︿＜

但是 IC 又必须是去中心化的，必须开放、包容。



**所以 IC 为了能承载大规模计算任务和超低成本的跨子网通信，选择了一种兼顾性能与去中心化的折中方式 —— DAO 。**



经过深思熟虑，Dfinity 团队选择再 IC 里创建一个 “ 超级子网 ” ，叫做系统子网。这个子网拥有 IC 的最高权限，相当于 IC 的超级管理员：创建子网、删除子网、给子网添加新节点、拆分子网、升级子网的协议、升级副本软件版本、调整 Cycles 汇率、全局唯一的 Canister id 、用户的 principal id 、每个子网的子网公钥等等，关系到整个 IC 区块链系统的关键参数都由这个超级管理员设定或者内部投票决定。

这种在区块链系统底层嵌入 DAO 的混合模型叫 DAO 控制网络（DAO - controlled network）。



管理着整个 IC 系统的 DAO 有个炫酷的名字：网络神经系统（Network Nervous System ，NNS）。IC 上的关键参数都由一个 DAO ，即整个 IC 社区决定。社区可以在系统需要扩容时做出决定增加子网！😎



不过有一点得注意一下，DAO 不是一天建成的。DAO 没法在短时间内直接变成去中心化的形态。它需要一个缓慢的过程，慢慢儿的去中心化，潜移默化、润物细无声。像比特币最初也是渺小脆弱、不堪一击的，挺过几次危机、经历了硬分叉之后才形成今天的局面的。

> 比特币有好几次面临溢出、提取别人比特币 bug 等等 bug 

NNS 是 IC 的超级管理员。这个 DAO 最大的投票权落入坏人之手，整个 IC 系统就完了，DAO 是集成在区块链系统底层的。NNS 是 IC 最需要安全的子网，所以 NNS 子网的[节点数量也非常多](https://dashboard.internetcomputer.org/subnet/tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe)，让黑客难以控制数量足够的节点，最大程度确保 NNS 子网底层的安全。

<img src="assets/1.NNS/image-20230921102952706.png" style="zoom:67%;" />

目前有 40 个节点机器，有一个坏了，问题不大：

<img src="assets/1.NNS/image-20230921103600826.png" style="zoom:63%;" />



在 NNS 子网内部，部署着精密的引擎： DAO 的智能合约。

> 对了，在 IC 上，智能合约就是一个叫 Canister 的虚拟容器。它和 Docker 或者 Kubernetes 类似，Canister 是一个 Wasm 容器。在[这里](../4.容器(Canister)/1.Canister.md)可以了解 Canister 的更多内容，如果你还没有了解过的话。



## 深入NNS内部

NNS 子网现在总共有 11 个 Canister ，在 [Dashboard](https://dashboard.internetcomputer.org/canisters?s=25&subnet=tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe) 可以看到。

|        名字        |         Canister id         |            控制者 Controller            |          功能          |
| :----------------: | :-------------------------: | :-------------------------------------: | :--------------------: |
|    NNS Registry    | rwlgt-iiaaa-aaaaa-aaaaa-cai |   r7inp-6aaaa-aaaaa-aaabq-cai（Root）   |         注册表         |
|   NNS ICP Ledger   | ryjl3-tyaaa-aaaaa-aaaba-cai |   r7inp-6aaaa-aaaaa-aaabq-cai（Root）   |      ICP 代币功能      |
|  NNS ICP Archive   | qjdve-lqaaa-aaaaa-aaaeq-cai |   r7inp-6aaaa-aaaaa-aaabq-cai（Root）   | 存储 Ledger 的历史记录 |
|   NNS Governance   | rrkah-fqaaa-aaaaa-aaaaq-cai |   r7inp-6aaaa-aaaaa-aaabq-cai（Root）   |    投票，神经元提案    |
|    NNS Lifeline    | rno2w-sqaaa-aaaaa-aaacq-cai |   r7inp-6aaaa-aaaaa-aaabq-cai（Root）   |   控制 Root Canister   |
| NNS Cycles Minting | rkp4c-7iaaa-aaaaa-aaaca-cai |   r7inp-6aaaa-aaaaa-aaabq-cai（Root）   |  将 ICP 兑换为 Cycles  |
| NNS Genesis Token  | renrk-eyaaa-aaaaa-aaada-cai |   r7inp-6aaaa-aaaaa-aaabq-cai（Root）   |      创世纪神经元      |
|      NNS Root      | r7inp-6aaaa-aaaaa-aaabq-cai | rno2w-sqaaa-aaaaa-aaacq-cai（Lifeline） | 控制其他 NNS Canister  |
| NNS Front-End Dapp | qoctq-giaaa-aaaaa-aaaea-cai |   r7inp-6aaaa-aaaaa-aaabq-cai（Root）   |  存储 NNS 的前端代码   |
|    NNS SNS-WASM    | qaa6y-5yaaa-aaaaa-aaafa-cai |   r7inp-6aaaa-aaaaa-aaabq-cai（Root）   |     记录 SNS 信息      |
|  （NNS Identity）  | qhbym-qaaaa-aaaaa-aaafq-cai |   r7inp-6aaaa-aaaaa-aaabq-cai（Root）   |      用户身份 ii       |

### NNS上的Canister

它们的作用都和系统运行息息相关：

1. Registry Canister ：注册表 Canister 。整个 IC 的系统配置都存在这个 Camister 里，比如哪些节点属于某个子网以及每个节点应运行的软件版本。
2. Ledger Canister ：ICP 账本 Canister 。它存储着各个 principal id 的 ICP 余额以及 ICP 交易历史记录。
3. Archive Canisters ：一旦交易数量太多而无法保存在单个 Canister 中时，交易历史就存储在这里。
4. Governance Canister ：治理 Canister 。接收和存储提案，这些提案都是和治理 IC 网络有关的。治理 Canister 还跟踪神经元，确定谁可以参与投票治理。
5. Cycles Minting Canister ：负责燃烧 ICP 铸造 Cycles 。IC 上的 Cycles 都由这个 Canister 铸造。
6. Root Canister ：它是所有其他 NNS Canister 的控制者，负责升级它们。Canister 的控制者有权限删除 Canister 、升级更新代码、停止 Canister 。但 Root Canister 不能随意升级 Canister ，必须要 Governance Canister 投票通过升级某个 Canister 的提案后，才会调用 Root Canister ，由 Root Canister 负责执行升级。
7. Lifeline Canister ：它是 Root Canister 的控制者，负责升级它。NNS 里唯一一个使用 Motoko 语言写的 Canister ，当 Rust 底层库出现非常严重的 Bug 时，就可以用这个 Motoko Canister 来升级 Root Canister ，再用 Root Canister 升级其他 NNS Canister 来恢复 IC 系统。
8. Front-End Dapp ：NNS 前端 Canister 。
9. Genesis Token Canister ：用于初始化创世之前就已存在的神经元的 Canister 。治理记录了一些投资人、基金会、早期贡献者的神经元。
10. SNS-WASM Canister ：管理 SNS Canister 相关的内容。创建、更新、删除 SNS Canister 都是它负责的。投票通过后由它把 Wasm 模块安装到 SNS 子网的 Canister 里。
11. 用户身份抽象 Canister ：记录用户身份。

### Registry Canister

其中最重要的 Canister 就是 Registry Canister 了。

这里记录着 IC 上的所有子网、以及子网的公钥、对子网公钥的 BLS 阈值签名、节点的各种信息，还有 Cycles 的价格、防火墙配置等等。

新节点首先必须把自己的身份提交给 NNS ，然后投票通过后才能加入子网。所有副本都会监控 Registry Canister ，获取最新的配置。每个负责打包出块的副本也得把最新的配置放进区块。

### Ledger Canister和ICP代币

ICP 代币由 Ledger Canister 管理，它存储两种东西：账户和交易。账户记录跟踪某个 principal （在 IC 上的认证身份）拥有的代币数量。代币随后可以从一个账户发送到另一个账户，这被记录在 Ledger Canister 的交易中。

在 NNS 里，ICP 有三种用途：

1. 任何人可以购买 ICP ，质押到 NNS 并参与 IC 网络治理，质押和投票会得到 ICP 奖励。
2. 参与治理和提供计算能力的节点机都会得到 ICP 奖励。
3. ICP 可转换为 Cycles ，这是 Canister 进行计算、通信和存储的燃料。

所以你看，ICP 不是直接集成在系统底层的功能性代币，ICP 是部署在 NNS 子网的智能合约，Cycles 才是系统的功能性代币。但不管怎么说，NNS 上的智能合约是整个区块链系统最重要的一部分，也相当于支持 IC 运行的底层组件了（只是从架构上看部署在应用层）。

> 更深层次的问题：如果某个 DAO 遭到黑客攻击，大量 ICP 被黑客控制，是否可以通过 NNS 投票来更改 ICP 交易记录，强行返还被盗的 ICP ？

### Governance Canister

Governance Canister 负责持有神经元，确定谁可以参与治理。另外，它还存储提案，以及与提案相关的信息，比如赞成票由多少、反对票有多少等等。如果一个提案被采纳，Governance Canister 就会自动执行决定，没人能阻拦。最后，Governance Canister 会将奖励分发给参与投票、为决策做出贡献的神经元。



### 定义NNS上的Canister id

顺便提一嘴，NNS 子网里的 Canister 应该是第一个部署在 IC 上的 Canister 。NNS 里这些 Canister 的 Canister id 是直接在[代码](https://github.com/dfinity/ic/blob/master/rs/nns/constants/src/lib.rs)里定义好的。Canister id 的是由 u64 类型的索引转换出来的，也可以把 Canister 转换回 u64 。

这段代码定义了 NNS 子网各 Canister 的基础信息，是初始化 NNS 子网的重要组成部分。

```rust
// 定义NNS子网内各个Canister的索引
pub const REGISTRY_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 0;
pub const GOVERNANCE_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 1;
pub const LEDGER_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 2;
pub const ROOT_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 3;
pub const CYCLES_MINTING_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 4;
pub const LIFELINE_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 5;
pub const GENESIS_TOKEN_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 6;
pub const IDENTITY_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 7;
pub const NNS_UI_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 8;
pub const SNS_WASM_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 10;

pub const NUM_NNS_CANISTERS: usize = ALL_NNS_CANISTER_IDS.len();
// 根据索引,定义各个Canister的ID
pub const REGISTRY_CANISTER_ID: CanisterId =
    CanisterId::from_u64(REGISTRY_CANISTER_INDEX_IN_NNS_SUBNET);
pub const GOVERNANCE_CANISTER_ID: CanisterId =
    CanisterId::from_u64(GOVERNANCE_CANISTER_INDEX_IN_NNS_SUBNET);
pub const LEDGER_CANISTER_ID: CanisterId =
    CanisterId::from_u64(LEDGER_CANISTER_INDEX_IN_NNS_SUBNET);
pub const ROOT_CANISTER_ID: CanisterId = CanisterId::from_u64(ROOT_CANISTER_INDEX_IN_NNS_SUBNET);
pub const CYCLES_MINTING_CANISTER_ID: CanisterId =
    CanisterId::from_u64(CYCLES_MINTING_CANISTER_INDEX_IN_NNS_SUBNET);
pub const LIFELINE_CANISTER_ID: CanisterId =
    CanisterId::from_u64(LIFELINE_CANISTER_INDEX_IN_NNS_SUBNET);
pub const GENESIS_TOKEN_CANISTER_ID: CanisterId =
    CanisterId::from_u64(GENESIS_TOKEN_CANISTER_INDEX_IN_NNS_SUBNET);
pub const IDENTITY_CANISTER_ID: CanisterId =
    CanisterId::from_u64(IDENTITY_CANISTER_INDEX_IN_NNS_SUBNET);
pub const NNS_UI_CANISTER_ID: CanisterId =
    CanisterId::from_u64(NNS_UI_CANISTER_INDEX_IN_NNS_SUBNET);
pub const SNS_WASM_CANISTER_ID: CanisterId =
    CanisterId::from_u64(SNS_WASM_CANISTER_INDEX_IN_NNS_SUBNET);
```

### NNS无Gas

NNS 是系统子网，里面部署的 Canister 都是和 DAO 、系统运行相关的，开发者不能在 NNS 部署 Canister 。所以 NNS 也没有 Gas 费，不消耗 Cycles 。



## NNS 治理



你可以通过在神经元中质押 ICP 代币，参与到 NNS 的治理中来，参与治理会有 ICP 代币奖励。作为神经元持有者，你可以提出关于 IC 的提案，让大家投票，比如子网的拓扑结构或协议的改变。质押更多 ICP 的神经元投票权更大。除了代币数量，投票权还受神经元其他特征影响，比如愿意质押更长时间的神经元持有人会有更大的投票权。



每个提案都有确定的投票期限。在投票期结束时，如果简单多数赞成该提案，且赞成票数超过了总投票权的 3% ，这个提案就会被采纳。当然，如果绝对多数（超过总投票一半）赞成或反对某个提案，提案将立即被通过或否决。

提案一旦通过，治理 Canister 会自动执行决策。比如，提案提议改变网络拓扑结构并获得通过，治理容器就会用新配置更新注册表容器。



IC 的一个骄傲之处就是能实现低成本的无缝扩展。它可以自动产生新子网来应对网络负载，而且扩容过程中不需要停止服务。在 Dfinity 上，子网的增加与合并是按需进行的。参与 NNS 的神经元可以根据网络负载情况发起扩容提案，以平衡整个网络。



这种强大的扩容能力让超大型区块链应用成为可能。开发者可以用智能合约构建如 token 化的社交媒体等应用，将社交媒体与传统的智能合约应用（如 DeFi）整合在一起，大大拓宽了业务的想象力。

参与治理的用户可以通过抵押 ICP 代币成为神经元，发起提案并参与投票。你可以直接投票，也可以跟随你信任的节点的票。注意，这里是“跟随”而不是“代理”。被跟随的节点不会得到你的代币，也不会因为你的关注获得更多 ICP 奖励。这种方式有助于形成一个分散的知识网络，有助于做出明智的决策。

值得一提的是，NNS 的治理神经元还支持 AI 和脚本。这些机器人更擅长参数的微调，比如获取交易所 ICP 的价格来调节 Gas 的价格。这将极大提升治理效率，帮助网络实现自我进化。







## NNS 钱包













**首先，更高层次的真相……**

我们应该强调[NNS 治理系统](https://medium.com/dfinity/getting-started-on-the-internet-computers-network-nervous-system-app-wallet-61ecf111ea11)（所以[每个人](https://medium.com/dfinity/understanding-the-internet-computers-network-nervous-system-neurons-and-icp-utility-tokens-730dab65cae8)）决定[我们创建的子网的大小](https://medium.com/dfinity/a-technical-overview-of-the-internet-computer-f57c62abc20f)。所以如果人们想要它，他们可以创造它。我们不能创建更大的子网并没有真正的技术原因。只是出于实用性考虑，我们现在选择不这样做（例如，我们测试时表面积较小，随着更多节点提供商上线而最大化子网等）。因此，这意味着如果我们需要添加更多，我们就会这样做。如果子网中的节点数量成为生态系统和金融世界的障碍，那么我们（社区）可以提出建议。因此，风险在于社区同意，而不是任何加密或技术。

在许多方面，NNS 是说“我们信任社区。我们知道事情必须改变。”虽然我们帮助启动它，但很明显，我们永远不能考虑所有事情，重要的是 IC 比我们更好（而且我们的时间资源）。

**现在是细微差别，所以我们可以一起看看乐高积木：**

1. 似乎有一个假设，即 IC 需要 7 个副本，因为这就是它们目前在主网上的情况。我们的目的是在网络上工作时对此进行很大的改变。例如，NNS 子网被认为足够重要，可以拥有更多子网。我们已经测试了很多很多。
2. 协议试图最大化所有权的独立性，这与其他区块链不同，在其他区块链中，例如验证器都在 AWS 或巨型矿池中运行。如果某些金融应用程序空间还不关心这一点，那是完全正确的，但作为痴迷于安全的人，我们关心任何弱点或篡改的可能性。
3. 我们的目的是最大化节点所有权的独立性以及地理差异。我们不希望所有节点（或大多数）都在某个地区、国家等。
4. 除非原作者公开 API，否则第三方开发人员无法检查容器的状态。
5. 是的，目前节点操作员理论上可以检查罐的状态（困难但很有可能）。我们已经公开谈论过我们打算在节点上进行加密计算（SGX 样式），但这还没有实现（请参阅[此线程中](https://www.reddit.com/r/dfinity/comments/nerppg/ama_we_are_manu_paul_and_diego_we_have_worked/gykc779?utm_source=share&utm_medium=web2x&context=3)关于可信执行环境的评论。

希望这有助于用一些急需的细微差别来着色，我们可以一起看一下这些片段。有人说“*你忘了带 1* ”或“*这可能现在可以，但 IC 需要在 3 个月内更换。* ”这完全有效。这就是 IC 有 NNS 的原因。



我们可以容忍 3f+1 大小的子网中的 f 个恶意副本，因此对于 7 个节点的子网，2 个恶意副本可以，但 3 个则不行。





---



协议升级

Internet Computer 区块链由网络神经系统（NNS）进行治理，这是其算法治理系统。NNS 的许多职责之一是在社区采纳升级提案时，协调将 Internet Computer 升级到新协议版本。对任何区块链进行升级都需要解决去中心化系统特性所带来的一系列挑战性问题，包括如何允许对协议进行任意更改，保留所有容器智能合约的状态，最大限度地减少停机时间，并自主推出升级。



在任何大型分布式系统中，由于硬件故障、网络连接问题或所有者决定将副本从网络中移除，单个副本的故障是不可避免的。在这种情况下，IC 的网络神经系统选择一个备用副本来替换其子网中的故障副本。新副本随后加入子网，并与现有副本进行状态同步，开始为子网区块链的共识协议做出贡献。



**低成本的无缝扩展**

互联网计算机可以实现无缝丝滑地扩展，不仅能根据网络负载情况自动的产生新子网，在扩容过程中也不需要停止你的服务。对用户与开发者来说，扩容的过程是毫无感觉的。

过去我们的思维常常被限定在固定数量的链上，从而钉死了整个网络的 TPS，而实际上 TPS 应该是按需扩展的。在 DFINITY 上子网的增加与合并是按需进行的，参与 NNS 的神经元可以根据当前的网络负载情况发起扩容提案，来平衡整个网络的负载。

这种近乎无限地扩容能力，也让区块链的超大型应用成为可能。开发者可以使用智能合约来构建token 化的社交媒体，将社交媒体与传统的智能合约应用（如DeFi）融合在一起，这将带来无限的业务想象力。



注意，这里是“跟随”而不是“代理”。被跟随的节点不会得到你的代币，也不会因为你的关注获得更多的 ICP 奖励。被“跟随”的节点还能再去“跟随”别人，这最终形成一个分散的知识网络，帮助做出足够明智的决策。

NNS 的治理神经元能支持 AI 与脚本，这些机器人更擅长参数的微调，比如获取交易所 ICP 的价格，来调节 Gas 的价格。这将大大提升治理效率，并能帮助网络实现自我进化。





















## Proposals

### Format

Each proposal submitted to the NNS has the following fields:

* **Summary:** Text providing a short description of the proposal, composed using a maximum of 280 bytes.
* **URL:** The web address of additional content required to evaluate the proposal, specified using HTTPS. For example, the address might describe content supporting the assignment of a DCID (data center id) to a new data center.
* **Proposer:** The ID of the neuron that submitted the proposal. When a proposal is submitted, a “charge” is placed on its balance in case it is rejected. So the balance needs to be big enough to pay the charge on (all) rejection(s). A neuron is required to have a dissolve delay ≥ 6 months to vote, and this applies to submitting proposals too.
* **Proposal Type:** The type of the proposal. This infers what topic it belongs to (e.g., #NodeAdmin), the system function that will process the proposal if it is adopted, and the type and structure of the parameters that will be passed to that function.
* **Parameters:** The parameters that will be passed to the system function that will be invoked if the proposal is adopted, as determined by its type. When a proposal is submitted, the NNS checks the parameters.

The NNS assigns a unique identity to each proposal that it receives.

The NNS assigns a unique identity to each proposal that it receives.

### Topics

The topic of a proposal, which is inferred from its type, determines how it will be processed. For example, the NNS may require voters to have a greater degree of agreement, or to try to process proposals faster, for some topics. Also, neurons follow other neurons on a per-topic basis. Initial topics include:

* **#NeuronManagement:** A special topic by means of which a neuron can be managed by the followees for this topic (in this case, there is no fallback to default). Votes on this topic are not included in the voting history of the neuron. For proposals on this topic, only the neuron’s followees on the topic that the proposals pertain to are allowed to vote. Because the set of eligible voters of proposals on this topic is restricted, proposals on this topic have a shorter than normal voting period.
* **ExchangeRate:** All proposals provide information in “real time” about the market value of ICP, as measured by an International Monetary Fund (IMF) Special Drawing Right (SDR) , which allows the NNS to convert ICP to cycles (which power computation) at a rate that keeps their real-world cost constant. Because proposals on this topic are very frequent, they have a shorter voting period, and votes on this topic are not included in the voting history of the neuron.
* **#NetworkEconomics:** Proposals that administer network economics — for example, determining what rewards should be paid to node operators.
* **#Governance:** All proposals that administer governance — for example, motions and the configuration of certain parameters.
* **#NodeAdmin:** All proposals that administer node machines somehow, including but not limited to upgrading or configuring the OS, upgrading or configuring the virtual machine framework, and upgrading or configuring the node replica software.
* **#ParticipantManagement:** All proposals that administer network participants — for example, granting and revoking DCIDs (data center identities) or NPIDs (node provider identities).
* **#SubnetManagement:** All proposals that administer network subnets — for example, creating new subnets, adding and removing subnet nodes, and splitting subnets.
* **#NetworkCanisterManagement:** Installing and upgrading “system” [canisters](https://wiki.internetcomputer.org/wiki/NNS_Canisters) that belong to the network — for example, upgrading the NNS.
* **#KYC:** Proposals that update KYC information for regulatory purposes — for example, during the initial Genesis distribution of ICP in the form of neurons.
* **#NodeProviderRewards:** Topic for proposals to reward node providers.

### Types

Initial proposal types include:

* **ManageNeuron (#NeuronManagement, Restricted Voting)** This type of proposal calls a major function on a specified target neuron. Only the followees of the target neuron may vote on these proposals, which effectively provides the followees with control over the target neuron. This can provide a convenient and highly secure means for a team of individuals to manage an important neuron. For example, a neuron might hold a large balance, or belong to an organization of high repute, and be publicized so that many other neurons can follow its vote. In both cases, managing the private key of the principal securely could be problematic. (Either a single copy is held, which is very insecure and provides for a single party to take control, or a group of individuals must divide responsibility — for example, using threshold cryptography, which is complex and time consuming). To address this using this proposal type, the important neuron can be configured to follow the neurons controlled by individual members of a team. Now they can submit proposals to make the important neuron perform actions, which are adopted if and only if a majority of them vote to adopt. (Submitting such a proposal costs a small fee, to prevent denial-of-service attacks.) Nearly any command on the target neuron can be executed, including commands that change the follow rules, allowing the set of team members to be dynamic. Only the final step of dissolving the neuron once its dissolve delay reaches zero cannot be performed using this type of proposal, since this would allow control/“ownership” over the locked balances to be transferred. (The only exception to this rule applies to not-for-profit organizations, which may be allowed to dissolve their neurons without using the initial private key.) To prevent a neuron falling under the malign control of the principal’s private key by accident, the private key can be destroyed so that the neuron can only be controlled by its followees, although this makes it impossible to subsequently unlock the balance.

* ManageNetworkEconomics (#NetworkEconomics)

     

    This is a single proposal type which can update one or several economic parameters:

    * Reject cost: The amount of ICP the proposer of a rejected proposal will be charged — to prevent the spamming of frivolous proposals.
    * Minimum Neuron Stake: Set the minimum number of ICP required for creation of a neuron. The same limit must also be respected when increasing dissolve delay or changing the neuron state from dissolving to aging.
    * Neuron Management fee: The cost in ICP per neuron management proposal. Here the NNS is doing work on behalf of a specific neuron, and a small fee will be applied to prevent overuse of this feature (i.e., spam).
    * Minimum ICP/SDR rate: To prevent mistakes, there is a lower bound for the ICP/SDR rate, managed by network economic proposals.
    * Dissolve delay of spawned neurons: The dissolve delay of a neuron spawned from the maturity of an existing neuron.
    * Maximum node provider rewards: The maximum rewards to be distributed to node providers in a single distribution event (proposal).
    * Transaction fee: The transaction fee that must be paid for each ledger transaction.
    * Maximum number of proposals to keep per topic: The maximum number of proposals to keep, per topic. When the total number of proposals for a given topic is greater than this number, the oldest proposals that have reached a “final” state may be deleted to save space.

* **Motion (#Governance)** A motion is a text that can be adopted or rejected. No code is executed when a motion is adopted. An adopted motion should guide the future strategy of the Internet Computer ecosystem.

* **ApproveGenesisKYC (#KYC)** When new neurons are created at Genesis, they have GenesisKYC=false. This restricts what actions they can perform. Specifically, they cannot spawn new neurons, and once their dissolve delays are zero, they cannot be disbursed and their balances unlocked to new accounts. This proposal sets GenesisKYC=true for batches of principals.

(Special note: The Genesis event disburses all ICP in the form of neurons, whose principals must be KYCed. Consequently, all neurons created after Genesis have GenesisKYC=true set automatically since they must have been derived from balances that have already been KYCed.)

* **AddOrRemoveNodeProvider (#Participant Management)** Assign (or revoke) an identity to a node provider, associating key information regarding the legal person associated that should provide a way to uniquely identify it.

* **RewardNodeProvider (#NodeProviderRewards)** Propose to reward a Gen-1 node provider an amount of ICP as compensation for providing Gen-1 nodes to the IC.

* **SetDefaultFollowees (#Governance)** Specify the list of followees that a freshly created neuron should have.

The following is a list of proposal types that call other NNS canisters:

* **CreateSubnet (#SubnetManagement)** Combine a specified set of nodes, typically drawn from data centers and operators in such a way as to guarantee their independence, into a new decentralized subnet. The execution of this external update first initiates a new instance of the distributed key generation protocol. The transcript of that protocol is written to a new subnet record in the registry, together with initial configuration information for the subnet, from where the nodes comprising the subnet pick it up.

* **AddNodeToSubnet (#SubnetManagement)** Add a new node to a subnet. The node cannot be currently assigned to a subnet. The execution of this proposal changes an existing subnet record to add a node. From the perspective of the NNS, this update is a simple update of the subnet record in the registry.

* **InstallNetworkCanister (#NetworkCanisterManagement)** A proposal to add a new canister to be installed and executed in the NNS subnetwork. The root canister, which controls all canisters on the NNS except for itself, handles this proposal type. The call also expects the Wasm module that shall be installed.

* **UpgradeNetworkCanister (#NetworkCanisterManagement)** A proposal to upgrade an existing canister in the NNS subnetwork. This proposal type is executed by the root canister. Beyond upgrading the Wasm module of the target canister, the proposal can also set the authorization information and the allocations.

* **BlessReplicaVersion (#NodeAdmin)** A proposal to bless a new version to which the replicas can be upgraded. The proposal registers a replica version (identified by the hash of the installation image) in the registry. Besides creating a record for that version, the proposal also appends that version to the list of “blessed versions” that can be installed on a subnet. By itself, this proposal does not effect any upgrade. (In the future, there will only be one blessed version of the replica software at any given time.)

* **RecoverSubnet (#SubnetManagement)** Update a subnet’s recovery CUP (used to recover subnets that have stalled). Nodes that find a recovery CUP for their subnet will load that CUP from the registry and restart the replica from that CUP.

* **UpdateSubnetConfig (#SubnetManagement)** Update a subnet’s configuration. This proposal updates the subnet record in the registry, with the changes being picked up by the nodes on the subnet when they reference the respective registry version. Subnet configuration comprises protocol parameters that must be consistent across the subnet (e.g., message sizes).

* **AssignNPID (#ParticipantManagement)** Assign an identity to a node operator associating key information regarding its ownership, the jurisdiction in which it is located, and other information. The node operator is stored as a record in the registry. It contains the remaining node allowance for that node operator, that is the number of nodes the node operator can still add to the IC. When an additional node is added by the node operator, the remaining allowance is decreased.

* **RootUpgrade (#NetworkCanisterManagement)** A proposal to upgrade the root canister in the NNS subnetwork. The proposal is processed by the Lifeline canister, which controls the root canister. The proposal updates the Wasm module as well as the authorization settings.

* **SetICPSDR (#ExchangeRate)** Instruct the NNS about the market value of 1 ICP as measured by an IMF SDR. This setting affects cycles pricing (as the value of cycles shall be constant with respect to IMF SDRs).

* **UpgradeSubnetToReplicaVersion (#SubnetManagement)** Update the replica version running on a given subnet. The proposal changes the replica version that is used on the specified subnet. The version must be contained in the list of blessed replica versions. The upgrade is performed when the subnet creates the next regular CUP.

* **ClearProvisionalWhitelist (#NetworkEconomics)** Clears the provisional whitelist, which allows the listed principals to create canisters with cycles. The mechanism is only needed for bootstrap and testing and must be deactivated afterward.

* **RemoveNodeFromSubnet (#SubnetManagement)** Remove a node from a subnet. It then becomes available for reassignment. The execution of this proposal changes an existing subnet record to remove a node. From the perspective of the NNS, this update is a simple update of the subnet record in the registry.

* **SetAuthorizedSubnetworks (#Governance)** Informs the cycles minting canister that a certain principal is authorized to use certain subnetworks (from a list). Can also be used to set the “default” list of subnetworks that principals without special authorization are allowed to use.

* **SetFirewallConfig (#SubnetManagement)** Change the Firewall configuration in the registry (configures which boundary nodes subnet blockchain replicas will communicate with).

* **UpdateNodeOperatorConfig (#NodeAdmin)** Change a node operator’s allowance in the registry.

* **StopOrStartNNSCanister (#NetworkCanisterManagement)** Stop or start an NNS canister.

## ICP tokens

ICP are native utility tokens that play three key roles in the network:

1. **Facilitating Network Governance** ICP tokens can be locked to create neurons that participate in network governance by voting, through which they can earn economic rewards.

1. **Production of Cycles for Compute** ICP provides a source store of value that can be converted into “cycles,” which power computation in the role of fuel that is burned when it is used. The NNS converts ICP to cycles at a variable rate, so chosen to ensure users of the network can always create new cycles at approximately constant cost in real terms, such that the cost of acquiring fuel is predictable.

1. **Rewarding Participants** The network mints new ICP to reward and incentivize those playing important roles that enable the network to function, including: a) the provision of “voting rewards” to those participating in governance, and b) the provision of “node provider rewards” to those operating the node machines that are hosting the network.

## Ledger

The ICP ledger is hosted within the NNS, and records all balances of ICP in the manner of a spreadsheet. Each row is called an “account,” which has two fields (i.e., there are two “columns”):

1. **Account identifier (bytes)** A unique value that is derived from the identity of the “principal” that “controls” the account. Currently, the principal must either be: (i) the owner of a public key pair, or (ii) a canister smart contract that is part of the NNS. Account identifiers are derived by hashing the concatenation of a domain separator, the principal ID, and the subaccount (or zeros if no subaccount is given).

1. **Balance** (positive integer, representing one hundredth of a millionth of an ICP) The quantity of ICP assigned to the principal of the account.

When the principal is a public key or Canister, they can apply the following operation to an account:

1. **Send** Send a portion of the ICP balance to another account. If all the ICP is sent to another account, then the sending account ceases to exist (i.e., is deleted from the ledger).
2. **Notify** When the destination of the funds sent is the account of an NNS canister (e.g., an account of the governance canister), the sender can ask the ledger to notify the recipient canister of the incoming transfer. The recipient canister can then act on this notification. Two examples where this ability is used are creating a neuron and refreshing the stake of a neuron. These are detailed below.

Operations that require interaction between the ledger and the governance system (Neurons):

1. **Create neuron** When the principal is a public key holder, they may lock a portion of their balance inside a new neuron. Technically, creating the neuron is done in two stages. First transfer the ICP to be staked to an account of the governance canister (which corresponds to a new neuron — the details of the association are omitted here). Then notify the governance canister of the incoming transfer which updates its internal neuron bookkeeping. If the entire balance is locked inside a new neuron, the account ceases to exist (i.e., is deleted from the ledger). To move these ICP to a different account, such as back to the original account, where they can once again be controlled like a normal balance, the associated neuron must be fully dissolved and disbursed (destroyed). The new neuron that has been created is controlled by the private key of the principal that created it.
2. **Refresh stake** The stake of a neuron may be increased by transferring to its address/account in the ledger and notifying the governance canister of the incoming transfer. Refreshing the stake will change the maturity and age of the neuron prorated. For example, if the stake is doubled, the maturity and age will be halved, so spawning will yield the same amount and the age bonus will be the same as before (in absolute terms).

## Neurons

A neuron locks a balance of ICP and enables its owner to participate in network governance, through which they can earn rewards.

### Attributes

Neurons have the following attributes:

* **Identity (uint64)** The general identity of the neuron object. When a neuron is configured to follow another neuron, this is the value that is used. This is a random 64-bit value selected at neuron creation.

* **Account (bytes, private)** The ledger account where the locked ICP balance resides.

* **Controller (principal ID, private)** The principal that actually controls the neuron. The principal must identify a public key pair, which acts as a “master key,” such that the corresponding secret key should be kept very secure. The principal might control many neurons.

* **Hot Keys (list of principal ID, private)** Keys that can be used to perform actions with limited privileges, such as voting, without exposing the secret key corresponding to the principal (e.g., could be a WebAuthn key).

* **CreatedAt (timestamp)** When the Neuron was created.

* **AgingSince (timestamp)** The timestamp corresponding to the time this neuron has started aging. This is either the creation time or the last time at which the neuron has stopped dissolving. This value is meaningless when the neuron is dissolving, since a dissolving neuron always has an age of zero.

* DissolveState

     

    At any time, at most one of WhenDissolved and DissolveDelay are specified.

    * WhenDissolved (timestamp)

When the dissolve timer is running, this stores the timestamp in seconds from the Unix epoch, at which point the neuron becomes dissolved. At any time while the neuron is dissolving, the neuron owner may pause dissolving, in which case DissolveDelay will get assigned to: WhenDissolved minus the timestamp when the action is taken.

* * DissolveDelay (duration)

When the dissolve timer is stopped, this stores how much time the dissolve timer will be started with. It can be eight years at most. At any time while in this state, the neuron owner may (re)start dissolving, in which case WhenDissolved will get assigned to the timestamp when the action is taken plus DissolveDelay.

* **Maturity (positive number )** The maturity of a neuron which reflects the amount of voting rewards allocated to a neuron. When new neurons are created, their maturity is zero. When neurons vote, over time the NNS increases their maturity to reward them.

* **Follow Relationships (mapping from topic to list of followees, private)** A neuron can be configured to vote automatically by following other neurons on a topic-by-topic basis. For any valid topic, a list of followees can be specified, and the neuron will follow the vote of a majority of the followees on a proposal with a type belonging to that topic. If a null topic is specified, this acts as a catch-all that enables the neuron to follow the vote of followees where a rule has not been specified.

* **Recent Votes (public)** A record of recent votes is maintained. This can provide a guide for those wishing to evaluate whether to follow a neuron, or how their followees are voting.

* **NotForProfit (boolean)** Whether this neuron is “not for profit,” making it dissolvable by voting.

The following attributes can be computed:

* **Age (seconds)** (computed from AgingSince and current time) The period of time that has elapsed since the neuron was created or last stopped dissolving. Conceptually, whenever a neuron starts dissolving, then its age is reset to zero and remains zero while it is dissolving. If a dissolving neuron has dissolving turned off, the current time becomes the effective neuron creation date for the purposes of calculating the age.

* State (LOCKED or DISSOLVING or DISSOLVED)

     

    (computed from DissolveState and the current time)

    * LOCKED: In this state, the neuron is locked with a specific DissolveDelay. It accrues age by the passage of time and it can vote if DissolveDelay is at least six months. The method start_dissolving can be called to transfer the neuron to the DISSOLVING state. The method increase_dissolve_delay can be used to increase the dissolve delay without affecting the state or the age of the neuron.
    * DISSOLVING: In this state, the neuron’s effective dissolve delay decreases with the passage of time. While dissolving, the neuron’s age is considered zero. Eventually it will reach the DISSOLVED state. The method stop_dissolving can be called to transfer the neuron to the LOCKED state, and the neuron will start aging again. The method increase_dissolve_delay can be used to increase the dissolve delay, but this will not stop the timer or affect the age of the neuron.
    * DISSOLVED: In the dissolved state, the neuron’s stake can be disbursed using the disburse method. It cannot vote as its dissolve delay is considered to be zero. If the method increase_dissolve_delay is called in this state, the neuron will become locked with the specified dissolve delay and start aging again. Neuron holders have an incentive not to keep neurons in the dissolved state for a long time: if the holders want to make their tokens liquid, they disburse the neuron’s stake, and if they want to earn voting rewards, they increase the dissolve delay. If these incentives turn out to be insufficient, the NNS may decide to impose further restrictions on dissolved neurons.

* **ControlByProposals (boolean)** (true if the neuron has a non-empty list of followees on the #NeuronManagement topic) If a neuron specifies followees on the ManageNeuron topic, it can be managed by proposals of type ManageNeuron (#NeuronManagement), which may only be voted upon by the neuron’s own followees. This provides a foundation for the management of highly security sensitive neurons, since it allows them to be maintained without hot keys or the secret key of the principal, which can be kept in cold storage or even destroyed (so long as the associated balance of ICP need never be unlocked). For example, the DFINITY Foundation or the Internet Computer Association might publicize the address of special neurons that will be made to vote according to their wishes, so that others can configure their neurons to follow them and leverage their expertise and efforts in governance. One problem with such practices is that they introduce the risk that secret keys used in the management of the publicized neurons might be compromised, allowing hackers to take control and “trick” large numbers of following neurons into voting according to their wishes. If the publicized neurons have admin proposals enabled, however, then they can be administered by the neurons they follow (their followees), which are typically controlled by a large number of team members who cannot be simultaneously extorted, without any need for the usage of secret keys whatsoever.

### Commands

The principal that controls a neuron may instruct it to perform the following actions:

* **Start Dissolving** The dissolve delay is like a kitchen timer that can only be turned in one direction. It can be arbitrarily increased, but only reduced by turning on dissolve mode and counting down. The neuron can be instructed to start “dissolving.” When the neuron is dissolving, its dissolve delay falls over the passage of time until either it is stopped or it reaches zero. A neuron cannot vote (or earn rewards for voting) when its dissolve delay falls below six months. Once the dissolve delay reaches zero, it stops falling and the controlling principal can instruct the neuron to disburse.

* **Stop Dissolving** A neuron that is dissolving can be instructed to stop, whereupon its dissolve delay stops falling with time.

* **Disburse** When the dissolve delay of the neuron is 0, its controlling principal can instruct it to disburse the neuron’s stake. Its locked ICP balance is transferred to a specified new ledger account, and the neuron and its own ledger account disappear.

* **Increase Dissolve Delay** The dissolve delay of a neuron can be increased up to a maximum of eight years.

* **Spawn** When the maturity of a neuron has risen above a threshold, it can be instructed to spawn a new neuron. This creates a new neuron that locks a new balance of ICP on the ledger. The new neuron can remain controlled by the same principal as its parent, or be assigned to a new principal. When a neuron spawns a new neuron, its maturity falls to zero.

* **Add Hot Key** Add a new hot key that can be used to manage the neuron. This provides an alternative to using the principal’s cold key to manage the neuron, which might be onerous and difficult to keep secure, especially if it is used regularly. A hot key might be a WebAuthn key that is maintained inside a user device, such as a smartphone.

* **Remove Hot Key** Remove a hot key that has been previously assigned to the neuron.

The following actions can be initiated using the principal or a hot key that has been configured:

* **Vote** Have the neuron vote to either adopt or reject a proposal with a specified ID.
* **Follow** Add a rule that enables the neuron to vote automatically on proposals that belong to a specific topic, by specifying a group of followee neurons whose majority vote is followed. The configuration of such follow rules can be used to: a) distribute control over voting power amongst multiple entities, b) have a neuron vote automatically when its owner lacks time to evaluate newly submitted proposals, c) have a neuron vote automatically when its own lacks the expertise to evaluate newly submitted proposals, and d) for other purposes. A follow rule specifies a set of followees. Once a majority of the followees votes to adopt or reject a proposal belonging to the specified topic, the neuron votes the same way. If it becomes impossible for a majority of the followees to adopt (for example, because they are split 50–50 between adopt and reject), then the neuron votes to reject. If a rule is specified where the proposal topic is null, then it becomes a catch-all follow rule, which will be used to vote automatically on proposals belonging to topics for which no specific rule has been specified. If the list of followees is empty, this effectively removes a follow rule.



# Governance of the Internet Computer

The Internet Computer blockchain is governed by the [Network Nervous System](https://wiki.internetcomputer.org/wiki/Network_Nervous_System) (NNS) [[1\]](https://wiki.internetcomputer.org/wiki/Governance_of_the_Internet_Computer#cite_note-1). The NNS is an algorithmic governance system that oversees the network and the token economics that make it possible to build DeFi dapps, open internet services and enterprise systems.

Holders of the Internet Computer’s [ICP utility tokens](https://wiki.internetcomputer.org/wiki/ICP_Tokenomics) can lock their tokens in [neurons](https://wiki.internetcomputer.org/wiki/Neurons_101) to participate in governance and contribute to decision-making, such as voting to determine whether or not a new collection of nodes (also called a subnet) should be added to the network.

### Why the Internet Computer needs a Network Nervous System[[2\]](https://wiki.internetcomputer.org/wiki/Governance_of_the_Internet_Computer#cite_note-2)

The Internet Computer is a distributed protocol run by a [network of node machines](https://wiki.internetcomputer.org/wiki/Sovereign_Network), which are hosted in different data centers. The nodes communicate with one another over the internet to achieve a [consensus](https://wiki.internetcomputer.org/wiki/Proof_of_Useful_Work) on what the Internet Computer’s state should be. A collection of nodes engaging in consensus is called a subnet. On top of this underlying communication and consensus protocol, the Internet Computer hosts [Canister Smart Contracts](https://wiki.internetcomputer.org/w/index.php?title=Canister_Smart_Contracts&action=edit&redlink=1) called *canisters*, which are stateful programs that can also communicate with each other. The state of all of the canisters has to be replicated across all of the nodes. Therefore, to allow the Internet Computer to scale indefinitely, the network is made up of not just one subnet, but multiple subnets.

Different [subnets](https://wiki.internetcomputer.org/wiki/Subnet_blockchain) can communicate with one another, enabling [Canister Smart Contracts](https://wiki.internetcomputer.org/w/index.php?title=Canister_Smart_Contracts&action=edit&redlink=1) that are hosted on different subnets to also communicate with each other. For the Internet Computer to scale on-demand, the network must be able to add new subnets over time to increase compute capacity. Moreover, the robustness of the subnets can be improved by adding new nodes to them over time. Eventually, the Internet Computer will run millions of nodes at scale. This means that there needs to be a mechanism by which the nodes and subnets are organized, tracked, and managed. For example, decisions must be made about when subnets and nodes should be added or removed. In addition, the Internet Computer was launched with an initial feature set, which evolves over time. Therefore, the Internet Computer needs to be able to make decisions on how to evolve the protocol in a distributed manner.



# NNS Canisters

The Network Nervous System of the Internet Computer is realized by a set of *[canisters](https://wiki.internetcomputer.org/wiki/Glossary#canister)*. NNS canisters include:

1. **Ledger canister:** The ledger canister stores the ICP utility *token balance* of each principal and the history of ICP *transactions*.
2. **Governance canister:** The governance canister receives and stores *Proposals*, which are suggestions for how the Internet Computer should be changed. These proposals can then be voted on. The governance canister also tracks *Neurons*, which determine who is allowed to participate in governance.
3. **Registry canister:** The registry canister stores the configuration of the whole Internet Computer, e.g., which nodes belong to a certain subnet and the software each node should run.
4. **Cycles minting canister**: This canister is responsible for minting *cycles*, the fuel for canisters for computation, communication and storage. New cycles can be minted when a new canister is newly created or when an existing canister is topped up with additional cycles.
5. **Root canister**: The root canister is the controller of all other NNS canisters and responsible for upgrading them.
6. **Lifeline canister**: The lifeline canister is the controller of the root canister and responsible for upgrading it.
7. **Archive canisters**: The canisters that store the history of the ledger transactions once there are too many transactions to keep in a single canister.
8. **Genesis token canister:** This is the canister that was used to initialize the neurons that already existed during genesis.

The canisters that users of the Internet Computer are interacting with the most are the first two: the ledger canister for making transactions, and the governance canister for staking tokens and submitting and voting on proposals.

## Ledger canister & ICP utility tokens in the NNS

[ICP utility tokens](https://wiki.internetcomputer.org/wiki/ICP_token) are managed by the ledger canister, which stores two things: accounts and transactions. An account record keeps track of how many tokens are in the possession of a given [principal](https://wiki.internetcomputer.org/wiki/Principal) (i.e., an identity by which a user is authenticated on the Internet Computer). Tokens can then be sent from one account to another, and this is recorded in the transactions of the ledger canister.

In the NNS, ICP utility tokens are used for three different things:

1. ICP tokens facilitate **participation in governance** (more below on how the neurons are connected with the tokens).
2. Those who participate in governance and those who provide compute capacity by operating note machines are **rewarded** in ICP tokens.
3. ICP tokens are used for **conversion into cycles**, which are fuel for canisters for computation, communication and storage.

## Governance Canister

The governance canister is responsible for holding *neurons*, determining who is allowed to participate in governance. Moreover, it stores proposals, which are suggestions for changes to the Internet Computer, and the information associated with proposals that decides if these suggestions should be implemented. If a proposal is adopted, the governance canister automatically executes the decision. Finally, the governance canister distributes rewards to those neurons who participated in voting and contributed to the decision making.

## Neurons

Neurons contain *locked* ICP utility tokens. These staked tokens are not liquid and cannot be transferred freely to others.

### Neuron Attributes

Each neuron stores a number of neuron attributes. Some of the most important ones are the following:

* How many ICP tokens are *locked* in the neuron. This information is accessible both by a neuron referencing an account on the ledger canister that stores the neuron's balance and by a cached stake on the governance canister.
* A *controller* principal, which identifies who manages the neuron's actions.
* A unique *neuron ID*
* The neuron's *dissolve delay.* Intuitively, the dissolve delay defines the earliest time when the locked ICP tokens can be unlocked. This time can be increased to up to 8 years but it can only be decreased by waiting for time to pass. A neuron can either be *non-dissolving*, *dissolving*, or *dissolved.* If a neuron is non-dissolving, its set dissolve delay is kept stable and the timer is not running down. The neuron can then be set to dissolving, which means that the dissolve delay is decreasing with the time. Finally, if a the dissolve delay reaches 0, the neuron is dissolved and the locked tokens can be transferred out of the neuron.
* The *age*, which is between 0 and 4 years. A neuron's age determines the time since when then neuron has last entered the non-dissolving state.

A neuron's dissolve delay determines a neuron's *eligibility* to participate in voting. Namely, only those neurons with tokens locked for at least six months are eligible to participate in governance. This incentivizes neuron holders to vote such that the value of their tokens is maximized for a future date. Assuming the value of the tokens is a rough proxy for the network’s success, this incentivizes neuron holders to vote in the long-term interest of the Internet Computer.

A neuron's *voting power* depends on how many tokens a neuron has locked, as well as the neuron's dissolve delay and age. Intuitively, those who are more committed to the Internet Computer, as they have locked their tokens for longer or have already staked them for a long time, have more voting power. The voting power increases with the dissolve delay and the age.

Finally, the number of rewards that each neuron receives depends on the number of votes that the neuron participated in as well as the neuron's voting power.

### How to lock tokens in a neuron[[1\]](https://wiki.internetcomputer.org/wiki/NNS_Canisters#cite_note-1)

As a user, there are different [ICP staking options](https://wiki.internetcomputer.org/wiki/ICP_staking_options) to stake ICP utility tokens in a neuron. The effect of such an operation is that these ICP tokens are transferred to a ledger account that is associated with a newly created neuron. The tokens are thus locked and cannot be used freely by the neuron holder.

**Example.** *Let’s assume that User B, who has an account (A1) on the ledger canister, would like to lock a hundred tokens in a neuron. To do so, User B sends a command to the NNS specifying the number of tokens and User B’s corresponding principal ID.*

*A transaction is then recorded on the ledger, which specifies that some tokens are sent from the original account (A1) of the user to a new account (A2), which also creates the new account (A2) that holds the locked tokens. A new neuron is created in the governance canister that specifies that User B is the one controlling this neuron and that specifies that the amount of locked tokens is defined by the new ledger account A2.*

*Externally, it’s not visible that the new account (A2) holds locked tokens or is in any way related to the original account (A1). Nevertheless, this account is in fact controlled by the neuron, which means that the tokens are not liquid and that User B cannot transfer the tokens or convert the tokens into cycles.*

The main reason for a user to lock tokens in a neuron is to be able to participate in voting and get voting rewards. Both are described in more detail below.

## Proposals

A proposal is a suggestion for a change to the Internet Computer. More technically, a proposal describes a *method* in a canister that is called if the proposal is accepted. Moreover, it describes the *parameters* with which the method will be called.

The Internet Computer supports a variety of different proposal *topics*. Here are some examples of topics that are supported in the NNS governance canister:

* \#SubnetManagement Proposals: This considers topology changes. The example proposal above about whether a node should be added to a subnet falls into this category.
* \#NodeAdmin Proposals: This concerns the administration of node machines. An example of a proposal could specify that all of the nodes in a subnet should be updated.
* \#NetworkEconomics Proposals: This concerns the administration of network economics. For example: what rewards should be paid to the node machine providers?
    1. Motion Proposals: These proposals do not have a direct execution of a method as a consequence but are merely there to record the opinion of the community on a specified matter.

## Voting and proposal lifecycle

### Submitting a proposal

Any eligible neuron can make and [submit a proposal](https://wiki.internetcomputer.org/index.php?title=Neuron_Attributes_and_Commands#Make_Proposal). To avoid being inundated by useless proposals, a user submitting a proposal has to pay a fee of 1 ICP when submitting a proposal, that they will receive back if the proposal is adopted (but that they will not receive back if the proposal is rejected).

**Example.** *Let’s consider a User C who would like to suggest that a new subnet is created that initially consists of two nodes: Node 1 and Node 2. Once User C controls a neuron, they can submit a proposal by specifying their neuron ID, the type of proposal that they would like to submit, and the proposal’s parameters. In our example, the proposal specifies that a new subnet should be created and the proposal's parameters consist of the initial nodes Node 1 and Node 2. Upon the receipt of this proposal, the governance canister first checks that this user is indeed the one controlling the neuron with the given ID and that this neuron is eligible to vote. If the requirements are met, the proposal is added to the governance canister.*

After a proposal is submitted by an eligible neuron, the proposal is created and stored in the governance canister. Moreover, the governance canister computes and stores additional information with each proposal. First, the [voting power](https://wiki.internetcomputer.org/w/index.php?title=Voting_power&action=edit&redlink=1) of each neuron is computed and stored together with the proposal. The sum of all of these voting powers also determines the *total voting power* associated with a given proposal.

When a new proposal is created, the number of “yes” votes associated with the proposal is already increased by the proposer’s voting power. This reflects that the proposal already has the support of the user submitting it.

Moreover, each proposal has an associated *voting period,* which determines the period of time over which votes for this proposal are accepted.

### Viewing NNS Proposals

You can see all the NNS proposals on the Internet Computer dashboard: https://dashboard.internetcomputer.org/governance

### Discussing NNS Proposals

Voters can freely discuss proposal anywhere they like. A lot of NNS proposals are discussed on the developer forum: https://forum.dfinity.org/c/roadmap/29.

### Voting on a proposal

After a proposal is submitted and added to the governance canister, other users who control neurons can [vote on the proposal](https://wiki.internetcomputer.org/wiki/ICP_voting_options). Currently, the most user-friendly way to vote on NNS proposals is via the NNS Frontend dapp: https://nns.ic0.app/. For voting, users would first learn which are the open proposals on the governance canister that they can actually vote on. This information is available, for example on Internet Computer dashboard: https://dashboard.internetcomputer.org/governance or in the [NNS frontend dapp](https://wiki.internetcomputer.org/w/index.php?title=NNS_frontend_dapp&action=edit&redlink=1).

If a neuron votes in favor of a proposal, the governance canister adds this neuron’s voting power, as stored with the proposal, to the “Yes”-votes associated with the proposal. Likewise, if a neuron votes against a proposal, the governance canister adds the neuron’s voting power to the “No”-votes of the proposal.

**Example.** *Assume that a given User D would like to reject the proposal that was just added by User C. To do so, User D would send their neuron ID and a “no” vote to the governance canister. The governance canister would check that the vote is coming from the correct user who controls the neuron and confirm that the neuron is eligible to vote. If the conditions are met, the governance canister would then add the voting power of User D to the “no” votes.*

#### Neuron following and liquid democracy

Users may not have the time or knowledge to participate in all voting decisions. Therefore, instead of directly voting on proposals, neuron holders may choose to delegate their vote to other neurons that they trust with certain decisions. This concept of delegating the right to vote to other voters who then effectively vote with more voting power is called *liquid democracy.*

Concretely, for each proposal topic a neuron can [specify a set of other neurons that it would like to *follow*](https://wiki.internetcomputer.org/w/index.php?title=How_to_follow_neurons&action=edit&redlink=1) *(so-called followees)*. In addition, a neuron can specify a set of followees for "all other topics" that are not covered by specific rules. The governance canister keeps track of this relation of follower and followee neurons. It then automatically casts a vote for a follower neuron based on the decision of the followees. In particular, if more than 50% of the followees vote "yes", then a "yes" vote is cast for the follower and if at least 50% of the followees vote "no", then a "no" vote is cast for the follower.

**Example**. *Consider neuron N1 that follows the set of neurons {N2, N3, N4, N5} on all proposal topics. Consider now that a proposal is submitted by another neuron N6. Assume in a first scenario that first N2 votes "No" and then N3 votes "No" on the proposal. In that case, the governance canister will also send a "No" vote for N1 two out of four followees voted "No" (which also means that it is not possible anymore to get more than 50% "Yes" votes). Assume a second scenario where N2 votes "Yes" and then N3 votes "Yes" on the proposal. In that case, no vote is sent yet for N1. However, if either N4 and N5 also send a "Yes" vote, a "Yes" vote is also cast for N1.*

This liquid democracy has great advantages. First, it allows even neurons that do not have enough knowledge of a certain topic to nevertheless participate in governance by choosing the neurons that they trust with certain decisions and by delegating their vote to them. In particular, a neuron can choose a different set of followees for different topics. Moreover, this mechanism allows neuron holders to get voting rewards from voting participation even if they do not have time to actively participate in all voting decision.

### Proposal decision and wait-for-quiet

A proposal can be *decided* in two ways:

1. **Absolute Majority before the voting period ends**: At any point, even before the voting period ends, if an absolute majority (more than half of the total voting power stored in the proposal) has voted Yes, then the proposal is adopted and if an absolute majority has voted No, then the proposal is rejected.
2. **Simple Majority at the voting period’s end**: When the voting period ends, if a simple majority (more than half of the cast votes) has voted Yes and the number of these Yes-votes constitute at least 3% of the total voting power, then the proposal is adopted. Otherwise, the proposal is rejected.

What also plays into this is the fact that the governance voting algorithm also applies *wait-for-quiet*. The idea of wait-for-quiet is to decide proposals quickly when all voters agree, but increase the time that neurons can vote for proposals that are controversial. That means that the voting period can be dynamically increased, depending on the neurons’ votes. In particular, each time a proposal’s outcome is turned (either a Yes-majority is turned to a No-majority or vice versa), the proposal’s deadline is increased. Currently, a proposal's initial voting period is 4 days and can be increased by at most another 4 days. That is, the voting period that is taken into account for the above rules can be between 4 and 8 days, depending on the voting activity.

### Proposal execution

Recall that a proposal defines a method, a canister, and some parameters. As soon as a proposal is adopted, the defined method on the specified canister is called with the given parameters. This is done fully automatically by the governance canister.

## Voting Rewards

Contributing to decision-making is one incentive for voters to lock their neurons, but they are also *rewarded* for participating in network governance.

Specifically, each day the governance canister considers which proposal can be settled. It is then considered for each neuron in how many proposals they participated and with which voting power. Depending on this, the neurons get rewarded. Concretely, rewards are added to the neuron's attribute that is called *maturity.*

A neuron holder can then profit from the maturity in two ways:

1. **Spawn maturity:** A neuron holder can choose to [spawn a new neuron](https://wiki.internetcomputer.org/w/index.php?title=How_to_spawn_a_neuron&action=edit&redlink=1) to get liquid ICP utility tokens worth the voting rewards. Spawning a new neuron has the effect that a new neuron with a new associated account on the ledger will be created, which contains the amount of staked ICP utility token equivalent to the maturity of the original neuron. In fact, the new tokens are minted and transferred to the new account, which is also recorded in the ledger canister. The new neuron has a small dissolve delay of 7 days. This means that users only need to wait a short amount of time to be able to unlock the tokens and use them freely, no matter what dissolve delay the original neuron has.
2. **Stake maturity**: A user can stake maturity which locks the maturity until the neuron is dissolved. Once a neuron is dissolved, staked maturity is unlocked and becomes normal maturity. Staked maturity contributes to the voting power of the neuron as determined by Voting Power = (ICP staked + maturity staked) x Dissolve Delay Bonus x Age Bonus. No ICP is (or can be) produced from staked maturity until the neuron is dissolved and the maturity is spawned (as described in the section above), at which point it is subject to maturity modulation.

## Cycles Minting Canister and Cycles[[2\]](https://wiki.internetcomputer.org/wiki/NNS_Canisters#cite_note-2)

Besides governance participation and voting rewards, tokens can also be converted into cycles, which fuel computation and storage on the Internet Computer. Each canister on the Internet Computer, except for those on the NNS, uses cycles for computations and has some cycles stored within it. While the token price may vary over time, the goal of the cycles is to keep the price of computation roughly consistent over time.

The canister responsible for converting ICP utility tokens into cycles is the *Cycles Minting Canister.* To convert cycles for creating or topping-up a canister, a user needs to send ICP utility tokens to the Cycles Minting Canister. This canister then burns the tokens and mints the cycles.

The Cycles Minting Canister only facilitates the conversion of ICP utility tokens to cycles but not the other way around. Cycles are burned in canisters when they use computation and storage over time.

**Example.** *Consider User E who runs a canister on the Internet Computer and would like to top up the cycles of this canister so that it can perform even more computations. Also assume that this canister currently has 700 trillion cycles and User E would like to increase this number by 200 trillion. To do so, the user would send a command to the NNS that specifies the action of topping up their canister. Upon receiving this command, a transaction is made from the user’s account to the Cycles Minting Canister. As a result of this transaction, the Cycles Minting Canister would burn the tokens, mint new cycles, and send these freshly minted cycles to the user’s canister, meaning the canister balance is now 900 trillion cycles.*



ICP Tokenomics
(Redirected from ICP token)
Introduction
ICP tokenomics encompasses aspects such as ICP token supply, distribution, use cases, and mechanisms to maintain stability of the ICP network and drive DAO participation.

By establishing a well-designed token economy, ICP project aim to create sustainable ecosystems that encourage participation, growth, and reliability for ICP smart contracts, developers, DAO participants, node providers, and dapp users.

Design Intent
The design intent of the tokenomics of the IC is to create a self-sustaining ecosystem that can balance the following goals and constraints:

Developers pay very low & stable storage and compute costs.
Node provider rewards are high enough to incentivize node providers to be part of the network.
Voting rewards are balanced to encourage staking and governance participation while also limiting inflation
Since this is a dynamic system, it is up to the community to keep an eye on the system and adjust its levers accordingly, evolving and optimizing the IC's tokenomics via NNS proposals.

Uses of ICP token
It is important to understand a bit about the Tokenomics of ICP. ICP is the utility token of ICP blockchain. The following are the core use cases that outline how the ICP token helps in the functioning of the Internet Computer blockchain.

1. Node Provider Rewards
The node providers that offer compute/storage infrastructure to the Internet Computer blockchain receive ICP rewards. Each node receives a flat monthly reward calculated in fiat and paid in the form of ICP tokens. This model ensures that the cost that the network bears for running a node is always constant in fiat terms. The reward varies slightly based on the geographical location of the node to ensure the IC is able to achieve a wider geographical distribution of nodes. Each node provider continues to receive rewards as long as they guarantee the right quality of service. The rewards are paid by minting new ICP tokens, causing inflation.

See also:

Node Provider Remuneration
2. Governance:
ICP token holder can stake (lock) their tokens to create Neurons. Holding neurons enables them to secure voting rights via the IC’s on-chain open governance system, the Network Nervous System (NNS). The NNS enables the neuron holders (people staking ICP) to vote on proposals related to aspects like upgrading the IC protocol and software running on node machines, onboarding new node providers, adding node machines into the blockchain network, and creating new subnet blockchains to increase capacity. The NNS implements liquid democracy: neurons can follow other neurons a delegate voting power. The neuron holders receive rewards from the IC protocol for participating in the voting process and helping with the governance. Rewards are distributed in the form of maturity which is an attribute of a neuron. Neurons holders can convert maturity to ICP at a later stage. This process is subject to maturity modulation.

See also:

Governance of the Internet Computer
Staking, voting and rewards
Tutorials for acquiring, managing, and staking ICP
3. Fuel for Computation/Storage
Canister smart contract computations running on the Internet Computer blockchain are fueled by “cycles”. These cycles are derived by burning ICP tokens. The cycles play a similar role to “gas” on Ethereum. There are several major differences, however. One of the most fundamental differences is that Ethereum leverages “user pays” while the Internet Computer has “smart contract pays” model (sometimes called “reverse gas”) model. Whereas the Ethereum blockchain requires end-users to send payments for the gas that smart contracts consume with every transaction, on the Internet Computer, Canister smart contracts are pre-charged with cycles, such that contracts effectively pay for their own computation - freeing users from the responsibility. Cycles are generated by burning ICP utility tokens, causing deflation.

4. Transaction/Proposal Fees
When any ICP holder transfers their ICP from one wallet to another they incur a small transaction fee paid in ICP. Additionally, ICP holders pay a small fee while submitting new proposals to the NNS.

Token Supply
The total supply of ICP is variable, with both minting (inflationary) and burning (deflationary) mechanisms. See: Total supply, circulating supply, and staked ICP.

To summarize, ICP inflation happens for rewarding node providers and governance participants while deflation happens when ICP is burnt for computation or for transaction/proposal submission fees.

How to get ICP tokens
There are different ways you can acquire ICP tokens:

Purchase ICP tokens directly through an exchange that lists ICP tokens available for trade. Coinmarketcap maintains a reasonably complete list of exchanges that trade ICP tokens
Receive tokens as voting rewards for participating in the governance of the Internet Computer
Receive ICP tokens from somebody who sends them to an account you created
Receive a developer grant of tokens through the Internet Computer Association (ICA) or the DFINITY Foundation
Receive tokens as remuneration for providing computing capacity as a node provider
Key tokenomics concepts
Maturity
neurons
Tokenomics series
The Tokenomics Series are a series of articles by the DFINITY Foundation presenting an ICP tokenomics framework that enables the community to analyze the relationship between various factors influencing the supply and demand of ICP. This framework will offer a quantitative basis for assessing the state of ICP tokenomics over time and evaluating potential changes.

May 11, 2023 - Projection of cycle demand and required network capacity of the IC
May 24, 2023 - Projecting total supply of ICP



# Total supply, circulating supply, and staked ICP

For a crypto community to understand the [governance](https://wiki.internetcomputer.org/wiki/Governance_of_the_Internet_Computer) and [tokenomics](https://wiki.internetcomputer.org/wiki/ICP_Tokenomics) of ICP, understanding the supply of ICP is important.

## Definitions

### Total supply

Total supply is the sum of all tokens currently in the system (whether they are locked/staked or not).

The total supply changes over time due to inflation and deflation. Its current value can be seen on the [IC Circulation page](https://dashboard.internetcomputer.org/circulation) of the IC dashboard.

### Circulating supply

The circulating supply is all tokens except liquid (non-staked) tokens owned by the DFINITY Foundation. The circulating supply definition was updated to its current definition on 18APR23 through an approved vote by the NNS on [proposal 117360.](https://dashboard.internetcomputer.org/proposal/117360)

The current circulating supply can be seen on the [IC Circulation page](https://dashboard.internetcomputer.org/circulation) of the IC dashboard.

### Staked ICP

Staked ICP supply is the sum of all the tokens that are locked or dissolving in neurons at any given time that are earning rewards. At this time, there is a minimum lockup period of 6 months to accrue voting rewards.

The total amount of staked ICP changes over time. Its current value can be seen on the [Neurons page](https://dashboard.internetcomputer.org/neurons) of the IC dashboard.

## Numbers

### At network Genesis

May 10, 2021:

* Total supply: 469 million
* Circulating supply: 123 million

### Current status

As of September 14th, 2023:

* Total supply: 505.8 million ICP
* Circulating supply: 444.6 million (87.5% of total supply)
* Staked ICP: 251.8 million (49.8% of total supply).
    * 81.8% of ICP staked is staked with more than a 1-year dissolve delay
    * 52.8% of ICP staked is staked for an 8-year dissolve
    * One can see the breakdown of staked ICP by dissolve delays in [IC neuron dashboard](https://dashboard.internetcomputer.org/neurons).

* As outlined in the section above Circulating supply represents ICP that was ever liquid. A subset of the circulating supply is locked in neurons as staked ICP.

## Inflationary mechanisms

The NNS mints ICP tokens for two reasons:

* For voting rewards (Governance).
* For node provider rewards.

The amount of ICP minted since Genesis can be seen in the ["Total Rewards" chart](https://dashboard.internetcomputer.org/circulation) on the IC dashboard.

### Paying staking rewards

Voting rewards are generated by minting ICP, although this minting only happens at the moment rewards are spawned, maturity is merged, or the neuron is disbursed.

The voting rewards rate schedule is designed with the goal that 90% of the token supply is staked in neurons. With this goal in mind, in the first year, the NNS allocates 10% of the total supply to generate voting rewards. Note the term "allocates" rather than "mints", because rewards are not minted (increasing the total supply) until they are spawned, merged, or the neuron is disbursed.

As the network becomes more stable over time, this allocation rate drops quadratically until it reaches 5% by year 8. See chart below from the [IC Circulation page](https://dashboard.internetcomputer.org/circulation) on the IC dashboard.:

[![NNS minting % by year.png](https://mywikis-wiki-media.s3.us-central-1.wasabisys.com/internetcomputer/thumb/NNS_minting_%25_by_year.png/800px-NNS_minting_%25_by_year.png)](https://wiki.internetcomputer.org/wiki/File:NNS_minting_%_by_year.png)

**Like all parameters in the NNS, this rate schedule can be changed via NNS proposals.**

See more in [Staking, voting and rewards](https://wiki.internetcomputer.org/wiki/Staking,_voting_and_rewards).

### Node provider rewards

Node providers are rewarded for running the node machines that power the Internet Computer.

## Deflationary mechanisms

The NNS burns ICP tokens for three reasons:

* To mint cycles, used to pay for compute and storage.
* For transaction fees.
* For failed NNS proposal fees.

The amount of ICP burned since Genesis can be seen in the ["Total ICP Burned" chart](https://dashboard.internetcomputer.org/circulation) on the IC dashboard.

### Paying for compute and storage

Dapp and smart contract developers pay computation and storage costs with cycles. Cycles are acquired from the NNS by converting ICP to cycles, which burns the converted ICP.

The cycles costs for IC computation and storage can be seen at [Computation and Storage Costs](https://smartcontracts.org/docs/developers-guide/computation-and-storage-costs.html).

### Transaction fees

Transferring ICP across accounts incurs a transaction fee of 0.0001 ICP, which is burned.

### Failed NNS proposals

It costs 10 ICP to submit a proposal. If the proposal passes, the 10 ICP is returned to the proposer. If the proposal is rejected, the 10 ICP is burned. Note that this only happens at disbursement or merging of neurons, so accumulated failed proposal fees can persist for a while before finally contributing to deflation.

## Historical factors affecting circulating supply

The Internet Computer blockchain is a result of several years of unyielding R&D. By Genesis, the DFINITY foundation, a major contributor to the Internet Computer was over 200 full-time members. Over the past several years the foundation raised financing in three main rounds and also allocated ICP tokens to the community in the form of an airdrop event.

For a breakdown of the different rounds and vesting schedules, see Messari's report ["Introduction to ICP"](https://messari.io/article/an-introduction-to-dfinity-and-the-internet-computer?referrer=asset:internet-computer). The unlocking of neurons has been the **largest contributing factor** to circulating supply since Genesis, so it's important to understand the context.

1. **Seed Round, Feb-2017:** This round was advertised by a tweet and open to the public by downloading a web extension. DFINITY raised CHF3.9 million (US$3.9 million) from 370 participants, at a valuation of $16 million, or a price of $0.03 per token. It held a portion of these funds in ETH and BTC during the 2017 crypto bull run. Seed round participants received all of their tokens at genesis but are staked inside 49 neurons. Each neuron has a different dissolve delay counting from 0 to 49 months. So this is practically equivalent to a 49-month "vesting schedule" see [How to Access ‘Seed’ and ‘Airdrop’ ICP Tokens and Participate in the Internet Computer Network](https://medium.com/dfinity/how-to-access-seed-and-airdrop-icp-tokens-and-participate-in-the-internet-computer-network-e6cd663a0c3c).
2. **Strategic Round, Jan-2018:** DFINITY raised $20.54 million for 7.00% of the initial supply (the number has been revised from the previously cited 6.84%). This allocation will vest monthly over three years starting from mainnet launch (May 2021). Participants include Polychain Capital, Andreessen Horowitz, CoinFund, Multicoin Capital, and Greycroft Partners. This round marks the first token a16z invested in. Polychain and DFINITY later collaborated to create the "DFINITY Ecosystem Venture Fund" (later renamed ["Beacon Fund"](https://dfinity.org/ecosystem/fund/)) of an undisclosed size. The goal is to fund new projects that would grow the IC's application ecosystem. The media reported that DFINITY raised a much larger amount of $61 million.
3. **Private Sale, Aug-2018:** 110 participants contributed $97 million for 4.96% of the initial supply, sold at 4 CHF (around $4 at the time) per ICP token. This number has been revised from 4.75% previously reported. This allocation came with a monthly vesting schedule of one year from mainnet launch. Vesting began one month after the initial token distribution event on May 10, 2021. Participants in this round include Andreessen Horowitz, Polychain Capital, SV Angel, Aspect Ventures, Electric Capital, ZeroEx, Scalar Capital, and Multicoin Capital.
4. **Airdrop, May-2018:** $35 million worth of ICP tokens (formerly DFN), or 0.80% of the initial supply, was airdropped to early supporters by being part of their mailing list, forums, and community. At this time, valuations reached $1.89 billion. Airdrop participants received the IOU version of their ICP tokens in September 2020. This allocation came with a monthly distribution schedule of one year from mainnet launch, which began on May 10, 2021.

## Conclusion

**Ultimately, the NNS is controlled by the community so it can vote to change any of the parameters. The parameters and mechanisms described are the current ones.**

The ICP token has a Total Supply of 505.8MM, Circulating Supply of 444.6MM as of August, 2023. 251.8MM ICP (49.8% of total supply) is staked by token holders in the form of neurons with over 81.8% locked for over 1 year.

The number of tokens is constantly changing. The rewards paid out to the node providers and governance participants contribute to the inflation in token supply while factors like compute/storage fees and transaction fees cause deflation in the total supply.