# NIDKG



















https://icpleague.com/thread/542

https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm

https://wiki.internetcomputer.org/wiki/Extend_Bitcoin,_Ethereum_and_other_blockchains

https://medium.com/dfinity/internet-computer-ethereum-integration-explained-6967456e35f9

https://github.com/ZenGo-X/multi-party-ecdsa

https://dashboard.internetcomputer.org/proposal/21340

https://twitter.com/dominic_w/status/1421853299955875842

https://forum.dfinity.org/t/direct-integration-with-bitcoin/6147/5

https://foresightnews.pro/article/detail/9665

https://foresightnews.pro/article/detail/9663

https://zhuanlan.zhihu.com/p/389203237?utm_id=0

https://blog.csdn.net/weixin_42934313/article/details/91974765

https://blog.csdn.net/shangsongwww/article/details/88891952





您的问题提到了NIDKG中一个非常关键的步骤 - 参与者如何生成自己的处理。我来详细解释一下:

1. 参与者j首先随机选择一个t-1阶多项式aj(x),其中常数项aj,0是自己的秘密贡献。
2. 然后计算自己的秘密分享 sj = aj(j),即该多项式在自己的索引j上的取值。
3. 对秘密贡献aj,0进行承诺,计算公钥部分Aj,0 = g^{aj,0}。
4. 将秘密分享sj进行分块加密,生成密文Cj。
5. 使用零知识证明证明:

* 密文Cj是对sj的正确加密
* sj满足多项式aj(x)的计算方式,即sj = Σ_{k=0}^{t-1} aj,k * j^k

1. 最后,参与者j生成的处理dj包含:

* 密文Cj
* 公钥部分Aj,0、...、Aj,t-1的承诺
* 零知识证明

所以dj就是包含了参与者j在NIDKG中需要贡献和证明的所有信息。它通过密文Cj将j的秘密分享sj加密了起来;通过公钥部分的承诺与零知识证明来证明这个处理的正确性和与多项式aj(x)的关系。

处理dj是参与者j实现NIDKG的核心,它将j在NIDKG中的贡献完整地打包了起来。请让我知道如果这个解释还需要补充查明白的地方。



> 将秘密分享sj进行分块加密的算法是什么？
>
> 对秘密贡献aj,0进行承诺,计算公钥部分Aj,0 = g^{aj,0}。收集到足够的这个公钥部分就可以组合出整体的公钥，对吗？

您的问题提到了两个关键点:

1. 将秘密分享sj进行分块加密的算法
2. 收集公钥部分Aj,0来重构整体公钥

我来详细解释一下:

1. 将sj分块加密的算法

文中使用的是一种基于双线性配对的前向安全加密方案。具体是:

(1) 将sj拆分成多个小块mi,每个块的值域很小,以便后续解密时暴力搜索。

(2) 对每个块mi使用ElGamal加密,得到密文(Ri, Ci)。其中Ri = g^{ri}, Ci = y_j^{ri} * g^{mi}。

(3) 对所有块使用同一个随机数r,可以优化性能。

(4) 使用零知识证明证明每个块mi的大小合法,可以被解密。

(5) 密文Cj就是所有块的加密(Ri, Ci)的集合。

1. 重构整体公钥

是的,收集到t个参与者的公钥部分Aj,0,可以使用拉格朗日插值的方法重构出整体的公钥:

vk = Π_{j=1}^{t} (Aj,0)^{Lj(0)}

这里Lj(0)是拉格朗日系数。

公钥vk就是门限签名方案的整体公钥。







我们目前可以在以太坊的网络上部署各种各样的智能合约来实现想要的功能和应用，但其性能瓶颈也一直是制约其发展的关键因素。

DFINITY 则利用更高效的共识技术，在以太坊协议上需要 10 分钟才能完成的事情，采用 DFINITY 协议仅需 1 秒即可完成，将交易速度提升了两个数量级。

在以太坊的 Casper 方案中，大约 125 个区块之后才能实现最终确认，出块时间约为 2~10 s，因此最终确认时长大约为 10 分钟。

而 DFINITY 的最终确认时间等于两个出块间隔加一点时间延迟（网络遍历或传输时间），因此几秒即可完成一个区块确认。

DFINITY 的共识采用 PoS+ 随机数的技术方向，其中共识方面的设计可谓其最大的技术亮点，而其中最重要的组成部分即为共识的随机数信标部分。

通过这个随机数信标，网络中分布在世界各地数以万计的节点能够随机选择一小部分成员参加共识，从而共同而高效地达成一致。

同时，这个随机数也会用于判定最终确定的链，从而快速使临时分叉的链得到最终确认（两个区块内即可确定最终链）。

此外，该随机数也会为之后众多 DApp 提供底层的稳定的随机数。

其中 DFINITY 采用基于 BLS 的阈值签名算法便是其核心，同时具备了可验证、唯一确定性、非交互性三个特点。

共识随机数技术不仅大大加快了 DFINITY 网络最终确认区块的速度，为支持高 TPS 应用提供了保证，同时也为整个网络提供了近乎无限的可弹性拓展的性能和资源。

整个网络中由于共识随机数的产出，加之出块与公证都由固定数目的节点来执行，因此新节点的加入不会影响到运行的速度。

而每新加入一个节点，都需要为网络提供一定性能的计算与存储性能。

在 DFINITY 最近的测试网 Demo 上可以找到一个基于密码学安全的视频会议应用程序（Magnify，Github 地址：https://github.com/Dfinity-Bjoern/Magnify），能够对参会者进行身份验证。

这样的应用能够在 DFINITY 网络中流畅运行也证明了其性能的优越。









首先来看背景，有一种叫门限签名的技术，它可以让多个人一起参与签名。比如一个公司的董事会，决定发布重要声明需要多数董事同意。为了做到这一点，每个董事持有一个秘密的“签名密钥”。要签发声明，需要收集多数董事使用自己的签名密钥生成的“签名片段”，把这些片段合并在一起就得到了整个声明的数字签名。这样可以防止少数恶意董事伪造签名。

但是问题是，这些签名密钥应该如何生成并分给每个董事呢？一个简单的方法是指定一个“发放者”，他生成签名公钥和匹配的签名私钥，然后把私钥分割成n份“秘密份额”，发给n个董事。但这需要发放者和每个董事都互相交互。

本论文提出一种“非交互式”的方法。非交互式意味着所有参与者(发放者和接收者)都可以独立生成信息，不需要交互。

作者使用了几种加密技术的组合:

1. Shamir秘密共享:可以把一个数字秘密分割成多份,达到一定数目的份额才能重构原始数字。

2. 公钥加密:用接收者的公钥加密每个秘密份额。

3. 零知识证明:证明加密的份额是正确的。

4. 前向安全:公钥是固定的,私钥会随时间改变,可以防止解密旧信息。

通过这些技术,作者构建了一个允许多个发放者生成门限签名公私钥并可靠分发给接收者的非交互式方案。

举个简单的例子,假设有5个董事,发放者先生成一个公钥,然后把对应的私钥分割成5份秘密份额。发放者使用Shamir秘密共享生成5个互不相关的份额,然后用每个董事的公钥加密各自的那一份。同时,发放者使用零知识证明来证明每个加密的份额都是正确的。每个董事收到含有自己那份加密秘密份额的信息后,可以验证零知识证明是否正确,如果正确,就可以用自己的私钥解密出自己的秘密份额。最后,达到门限数目的秘密份额可以重构出签名私钥。

这样就达到了非交互式地生成门限签名公私钥并分发秘密份额的目的。

为了应对私钥被破解的风险,文中使用了前向安全技术。公钥是固定的,但私钥会随时间分“时段”而改变。只有在同一时段,旧的私钥才能解密对应时段的信息。所以破解了过去时段的私钥也无法解密未来的信息。

作者使用了一些特殊的加密方式,可以让多个接收者共用随机数,这样可以大大提高效率。另外也设计了一个简单的证明方法,来证明秘密份额中的信息是可解密的,虽然这个证明系统不够完美,但可以通过一定方法使错误可忽略不计。

总之,作者组合了多种加密原语,设计出一个非交互式的方案,可以让多个发放者生成门限签名所需的公私钥,并可靠地分发秘密私钥份额给接收者。同时也考虑到了前向安全性和效率。



这个问题涉及到了一些密码学的高级概念，我会尽力将它们用尽可能易懂的方式解释，让你能够理解这段文字的核心内容。

首先，我们要讨论的是非交互式分布式密钥生成和密钥重分配协议，它们支持Shamir秘密分享的秘密密钥。你可以把Shamir秘密分享看作是一种神奇的魔术，魔术师Shamir可以把一个秘密（比如一个重要的数字或信息）分解成多份，然后分发给一群人。只有当一定数量的人（称为阈值）将他们的份额放在一起时，这个秘密才能被重新组合。如果人数不够，秘密就无法解开。这就好像是一个需要多把钥匙才能打开的大箱子。

接下来，"公共验证密钥" 和 "BLS签名方案"。公共验证密钥就像是一个公开的信号塔，任何人都可以用它来验证一份信息是否真实。而BLS签名方案就像是一种特殊的密码锁，它让我们能够确定一个消息是不是真的来自声称的发送者。

现在，让我们来谈谈这个过程的非交互性。在这里，非交互性意味着每个参与者都可以在不需要与其他人交谈的情况下完成他们的任务。这就像是一个自助餐厅：每个人都可以按照自己的节奏和口味去拿菜，而不需要等待服务员来点餐。

下一个概念是"非交互零知识证明"。这个词可能看起来有点复杂，但其实它的意思就是一种可以让人证明自己知道某个秘密，而又不用透露任何关于这个秘密的信息的方法。它就像是一个神奇的透明盒子：你可以看到盒子里面有东西，但你却看不到这个东西是什么。

然后我们要讨论的是"前向保密性"。这个概念就像是一次性密码，你用过一次之后就不能再用了。在这个协议中，时间被分为很多个"时代"，每个时代都有自己的密钥。这意味着如果你的密钥在某个时刻被盗了，盗贼只能解开那个时刻之后的信息，而不能解开之前的信息。

最后，这段文字讨论了如何通过将明文划分为小块来优化加密过程，这个过程就像是将一篇长文章切成一段一段的，然后每一段都进行独立的翻译，最后再把这些段落放在一起。这样做的好处是可以使加密过程更有效率，同时还可以减少解密过程中的错误。

总的来说，这段文字讲述了一个复杂的密码学过程，这个过程旨在创建一个公共的、安全的、可验证的密钥系统，其中涉及到的技术和策略都是为了确保信息的安全和准确。





在密码学中，交互性是指一种需要两个或更多的参与者进行来回通信以完成某种任务的特性。例如，Alice和Bob需要通过几轮的消息交换来达成共识或完成某种计算。这种场景中，Alice需要等待Bob的响应才能继续她的任务，反之亦然。

非交互性则是相对的概念，它指的是可以完成任务的方式，不需要在参与者之间进行回应或等待。比如，Alice可以在Bob不在线的情况下，完成自己的任务部分，然后将结果公开。Bob在他上线的时候，就可以拿到Alice的结果，并用它进行接下来的工作。在这种情况下，Alice和Bob就像是在各自的时间线上工作，他们并不需要在同一时间在线，或等待对方的响应。这样的过程可以大大提高效率。

在你引述的这段文字中，非交互性主要表现在两个方面：
1. 每个参与者（这里的“dealer”）都可以独立地创建他们的部分（这里的“dealing”），并公开它。他们并不需要等待其他参与者的反馈或验证。
2. 同样地，每个接收者（这里的“receiver”）都可以独立地验证一个dealing是否正确。他们也不需要与其他人交互，或等待他们的反馈。

这种非交互性可以使得整个系统的运行更加高效，因为每个参与者都可以在他们自己的节奏和时间线上工作，而不需要与其他人协调。这在处理大规模的网络交互时特别有用，因为在这种环境下，协调所有参与者的行动可能非常困难和耗时。







第一部分：导言

这个部分先介绍了论文要解决的问题。

我们可以想象，假设一个公司需要用密码技术来确保只有多数董事会成员同意，才能发布某些重要声明。为了做到这一点，可以使用 “ 多重签名 ” 技术，让每个董事会成员持有一个秘密的 “ 签名密钥 ” 。要签署声明，需要收集多数董事会成员使用各自的签名密钥生成的“签名片段”，然后把这些签名片段合并就可以产生整个声明的数字签名。

这样可以保证恶意的少数人无法在没有多数人同意的情况下，伪造整个董事会的签名。这种技术称为 “ 门限签名 ” 。

但是，这里还存在一个问题，那就是如何最开始生成这些签名密钥并分发给董事会成员呢?

一个简单的方法是选一个人作为 “ 交易方 ” ，让他生成签名公钥和匹配的签名私钥，然后把私钥切分成 n 份 “ 秘密份额 ” ，分别发送给n个董事会成员。但是这样需要很多交互，交易方要单独跟每个成员交互。

本论文提出一种 “ 非交互式 ” 的方法来生成和分发门限签名所需的公私钥。“ 非交互式 ” 意味着所有参与方(交易方和接收方)都可以独立生成各自的信息，不需要进行交互通信。

作者使用了一些加密技术原语的组合来实现这一目的：

1. Shamir 秘密共享：可以将一个秘密切分成多个 “ 秘密份额 ” ，达到一定门限的份额可以合并重构原始秘密。

2. 公钥加密：使用接收方的公钥加密每个秘密份额。

3. 零知识证明：证明加密的份额是正确的。

4. 前向安全：公钥是静态的，但私钥会随时间进化，可以防止解密旧的加密信息。

通过这些技术的组合，本文构建了一个非交互式的方案，允许多个交易方生成门限签名所需的公私钥，并可靠地分发给接收方，而无需交易方之间的交互。

这个问题在比特币中也存在，比特币网络由运行比特币软件的节点组成。为了保证安全，一些操作需要多重签名，所以也需要非交互式地生成和分发门限签名密钥。

总之，本文解决的问题就是，如何让多个节点非交互地生成门限签名公私钥，并正确分发私钥，这在许多密码应用中都是很有用的技术。



第二部分：预备知识

这个部分介绍了论文需要用到的一些基础知识。

1. 整数模运算

我们可以用100表示时间，比如9点就是9，10点就是10。但是如果用24小时制，10点就是22，这叫模24运算，即把一个大数模除以24的余数作为时间。

计算机也经常用这种技术，对一个大数模某个数字求余数。本文中会对大整数模一个质数p求余数。

2. 群

群是一系列数字，它们可以进行特定的运算，比如加法或者乘法，运算的结果还在这个群中。

本文中会提到循环群，比如1，2，3，...，p-1这些整数模p的余数组成的一个乘法群。群可以用于许多密码技术中。

3. 配对 

配对可以将两个不同的群G1和G2中的元素映射到一个新的群GT中。本文中使用的就是这种特殊的配对，称为配对密码。

4. 哈希函数

哈希函数可以将任意长度的数据映射成固定长度的哈希值。本文中会用到将数据映射成特定群中的元素的哈希函数。

5. Shamir秘密共享 

Shamir秘密共享可以将一个数字秘密分割成多份，达到一定数量的份额才能重构原始数字。本文中会用它来分割密钥。

6. 拉格朗日插值

拉格朗日插值是从一些点可以重构一个多项式的方法。配合Shamir秘密共享，可以从多个秘密份额重构原始秘密。

7. 非交互式零知识证明

零知识证明可以证明某个陈述是正确的，但不泄露陈述所基于的秘密信息。非交互式零知识证明不需要交互，可以单方面生成。

以上概括了本文需要的一些数学和密码学基础知识，这些知识对于读懂论文的技术内容非常重要。我尽量用简单的语言和类比来解释这些概念，以方便理解。请让我知道如果有哪些部分需要进一步详细解释。









第一部分：导言

该论文提出了一个非交互式的公开可验证的秘密分享方案，交易方可以在其中构造Shamir秘密分享的字段元素，并保密地向多个接受方分发份额。作者们还开发了一个非交互式的公开可验证的重新分享方案，其中现有的Shamir秘密分享的持有者可以创建同样秘密的新的Shamir秘密分享，并以保密的方式分发给一组接受方。

与秘密相关的公钥可以以被分享的秘密字段元素为指数的群元素的形式给出。作者使用他们的可验证秘密分享方案来构建一个非交互式的分布式密钥生成协议，该协议为BLS签名方案创建这种公钥，以及离散对数的秘密分享。他们还构建了一个非交互式的分布式重新分享协议，它保留公钥但为秘密密钥创建一个新的秘密分享，并将其交给一个可以与原始股东集合重叠或不重叠的一组接受方。

作者的协议基于一个新的基于配对的CCA安全公钥加密方案，该方案具有前向安全性。作为结果，他们的协议可以使用参与方的静态公钥，但仍可提供危害保护。该方案使用分块加密，这需要付出代价，但该代价被他们的密文仅由源群元素而不是目标群元素组成所带来的节省所抵消。进一步的效率节省是通过将单接收方加密方案扩展到多接收方加密方案来获得的，其中密文比只具有单接收方密文的情况小5倍。

非交互式密钥管理协议被部署在互联网计算机上，以促进阈值BLS签名的使用。这些协议提供了一个简单的接口，可远程为一组接受方创建共享密钥，无论密钥持有者发生何种变化，都可以刷新该共享的秘密密钥，并提供针对移动攻击者的主动安全性。

第二部分：预备知识

这个部分介绍了论文中使用的一些基本符号、群、配对以及一些基本算法如Shamir秘密分享、拉格朗日插值法等。

第三部分：签名

这个部分简要介绍了BLS签名方案。BLS签名方案是一种基于短签名的门限签名方案。它使用配对来验证签名的正确性。该方案还具有签名唯一性的特点，即对于同一消息，只能存在一个有效签名。作者并没有在这里证明BLS签名方案的安全性，而是留到后面阈值BLS签名那一部分再讨论。

第四部分：阈值签名

这个部分定义了非交互式阈值签名的语法。该签名方案包含一些算法，包括分发密钥生成、签名份额生成、签名份额验证、签名份额组合等。重要的是签名份额可以非交互式生成，并且可以组合成一个完整的签名。这里也给出了BLS阈值签名方案作为一个实例。

第五部分：前向安全公钥加密

这个部分构建一个新的配对基CCA安全公钥加密方案，该方案具有前向安全性。前向安全性意味着如果攻击者获取了解密密钥，她只能解密未来的密文而无法解密过去的密文。

作者首先定义了一个判定问题，并证明在通用群模型下该问题是困难的。然后他们给出了一个基于二叉树的加密方案，证明它在随机叶子模型下是IND-CPA安全的。进一步将其扩展到多接收方的二叉树加密。最后，利用二叉树加密和散列函数，构建出一个INR-CCA安全的多接收方加密方案。该方案使用了前向安全的思想，发送者的公钥是静态的，但解密密钥会随着时间进化。

第六部分：非交互式零知识证明

这个部分构建了一些非交互式零知识证明，这些NIZK证明将在分布式密钥生成协议中使用。具体包括：

1. 知晓离散对数的证明

2. 正确秘密分享的证明

3. 正确分块的证明

这些NIZK采用Fiat-Shamir范式，并在随机预言机模型下被证明是完全性、零知识性和模拟可提取性。

第七部分：非交互式分布式密钥生成和重新分发

这个部分是论文的核心部分，给出了非交互式分布式密钥生成和重新分发的具体构造。该方案使用之前构建的多接收方前向安全加密和NIZK证明。

该协议主要包括以下算法：

- 设置：定义参数

- 密钥生成：生成公钥和初始解密密钥

- 交易生成：交易方使用其密钥分片生成交易

- 交易验证：验证交易的正确性

- 密钥组合：组合多个交易生成 Threshold 公钥

- 密钥检索：接收方从交易中检索自己的密钥分片

- 签名份额生成：使用密钥分片对消息进行签名

一个交易中，交易方会加密其密钥分片，并给出相关的公钥分片。同时使用 NIZK 证明证明分片的正确性。接收方可以验证Transactions，并提取自己的密钥分片。最终可组合出Threshold公钥。

该方案也给出了一个安全定义，即在一个动态的腐败模型下，攻击者无法在没有足够的非诚实交易方协助的情况下产生签名。并证明该方案在一个稍弱的模型下是安全的。

最后还讨论了该方案的主动安全性，即通过周期性重新分发可以防范移动的攻击者。

第八部分：安全性

这个部分给出一个完整的安全定义，考虑到动态攻击者可以逐步腐蚀节点。并证明该方案在一个稍弱的安全模型下是安全的。

另外还讨论了主动安全性，即通过重新分发秘密分享可以防止移动攻击者。

总结

以上我详细翻译和讲解了论文《非交互式分布式密钥生成和密钥重新分发》中关于NIDKG协议的主要内容。该协议通过组合多项式秘密分享、公钥加密、前向安全和零知识证明等加密原语实现了非交互式的分布式密钥生成，可用于构建安全的Threshold签名方案。讲解字数达到了要求，如果哪里还有不清楚的地方，请告知，我会继续补充解释。