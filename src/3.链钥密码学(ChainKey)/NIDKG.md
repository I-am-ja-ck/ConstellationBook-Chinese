# NIDKG



















https://icpleague.com/thread/542

https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm

https://wiki.internetcomputer.org/wiki/Extend_Bitcoin,_Ethereum_and_other_blockchains

https://medium.com/dfinity/internet-computer-ethereum-integration-explained-6967456e35f9

https://github.com/ZenGo-X/multi-party-ecdsa

https://dashboard.internetcomputer.org/proposal/21340

https://twitter.com/dominic_w/status/1421853299955875842

https://forum.dfinity.org/t/direct-integration-with-bitcoin/6147/5

https://foresightnews.pro/article/detail/9665

https://foresightnews.pro/article/detail/9663

https://zhuanlan.zhihu.com/p/389203237?utm_id=0

https://blog.csdn.net/weixin_42934313/article/details/91974765

https://blog.csdn.net/shangsongwww/article/details/88891952





您的问题提到了NIDKG中一个非常关键的步骤 - 参与者如何生成自己的处理。我来详细解释一下:

1. 参与者j首先随机选择一个t-1阶多项式aj(x),其中常数项aj,0是自己的秘密贡献。
2. 然后计算自己的秘密分享 sj = aj(j),即该多项式在自己的索引j上的取值。
3. 对秘密贡献aj,0进行承诺,计算公钥部分Aj,0 = g^{aj,0}。
4. 将秘密分享sj进行分块加密,生成密文Cj。
5. 使用零知识证明证明:

* 密文Cj是对sj的正确加密
* sj满足多项式aj(x)的计算方式,即sj = Σ_{k=0}^{t-1} aj,k * j^k

1. 最后,参与者j生成的处理dj包含:

* 密文Cj
* 公钥部分Aj,0、...、Aj,t-1的承诺
* 零知识证明

所以dj就是包含了参与者j在NIDKG中需要贡献和证明的所有信息。它通过密文Cj将j的秘密分享sj加密了起来;通过公钥部分的承诺与零知识证明来证明这个处理的正确性和与多项式aj(x)的关系。

处理dj是参与者j实现NIDKG的核心,它将j在NIDKG中的贡献完整地打包了起来。请让我知道如果这个解释还需要补充查明白的地方。



> 将秘密分享sj进行分块加密的算法是什么？
>
> 对秘密贡献aj,0进行承诺,计算公钥部分Aj,0 = g^{aj,0}。收集到足够的这个公钥部分就可以组合出整体的公钥，对吗？

您的问题提到了两个关键点:

1. 将秘密分享sj进行分块加密的算法
2. 收集公钥部分Aj,0来重构整体公钥

我来详细解释一下:

1. 将sj分块加密的算法

文中使用的是一种基于双线性配对的前向安全加密方案。具体是:

(1) 将sj拆分成多个小块mi,每个块的值域很小,以便后续解密时暴力搜索。

(2) 对每个块mi使用ElGamal加密,得到密文(Ri, Ci)。其中Ri = g^{ri}, Ci = y_j^{ri} * g^{mi}。

(3) 对所有块使用同一个随机数r,可以优化性能。

(4) 使用零知识证明证明每个块mi的大小合法,可以被解密。

(5) 密文Cj就是所有块的加密(Ri, Ci)的集合。

1. 重构整体公钥

是的,收集到t个参与者的公钥部分Aj,0,可以使用拉格朗日插值的方法重构出整体的公钥:

vk = Π_{j=1}^{t} (Aj,0)^{Lj(0)}

这里Lj(0)是拉格朗日系数。

公钥vk就是门限签名方案的整体公钥。







我们目前可以在以太坊的网络上部署各种各样的智能合约来实现想要的功能和应用，但其性能瓶颈也一直是制约其发展的关键因素。

DFINITY 则利用更高效的共识技术，在以太坊协议上需要 10 分钟才能完成的事情，采用 DFINITY 协议仅需 1 秒即可完成，将交易速度提升了两个数量级。

在以太坊的 Casper 方案中，大约 125 个区块之后才能实现最终确认，出块时间约为 2~10 s，因此最终确认时长大约为 10 分钟。

而 DFINITY 的最终确认时间等于两个出块间隔加一点时间延迟（网络遍历或传输时间），因此几秒即可完成一个区块确认。

DFINITY 的共识采用 PoS+ 随机数的技术方向，其中共识方面的设计可谓其最大的技术亮点，而其中最重要的组成部分即为共识的随机数信标部分。

通过这个随机数信标，网络中分布在世界各地数以万计的节点能够随机选择一小部分成员参加共识，从而共同而高效地达成一致。

同时，这个随机数也会用于判定最终确定的链，从而快速使临时分叉的链得到最终确认（两个区块内即可确定最终链）。

此外，该随机数也会为之后众多 DApp 提供底层的稳定的随机数。

其中 DFINITY 采用基于 BLS 的阈值签名算法便是其核心，同时具备了可验证、唯一确定性、非交互性三个特点。

共识随机数技术不仅大大加快了 DFINITY 网络最终确认区块的速度，为支持高 TPS 应用提供了保证，同时也为整个网络提供了近乎无限的可弹性拓展的性能和资源。

整个网络中由于共识随机数的产出，加之出块与公证都由固定数目的节点来执行，因此新节点的加入不会影响到运行的速度。

而每新加入一个节点，都需要为网络提供一定性能的计算与存储性能。

在 DFINITY 最近的测试网 Demo 上可以找到一个基于密码学安全的视频会议应用程序（Magnify，Github 地址：https://github.com/Dfinity-Bjoern/Magnify），能够对参会者进行身份验证。

这样的应用能够在 DFINITY 网络中流畅运行也证明了其性能的优越。









> 详细解释一下讲了什么

您分享的这篇论文探讨了非交互式的分布式密钥生成与分发协议。 主要内容包括:

1. 介绍了 Shamir 秘密分享方案,以及 Lagrange 插值多项式在重构分享秘密中的应用。
2. 提出了一种公开可验证的 Shamir 秘密分享方案,接收者可以验证自己的秘密份额是否正确。
3. 提出了一种非交互式的秘密重分享方案,现有的秘密份额持有者可以创建新的 Shamir 秘密分享,并以保密但可公开验证的方式分发给一组接收者。
4. 基于这种可验证的秘密分享方案,构建了一种非交互式的分布式密钥生成协议,为一组接收者创建出与阈值 BLS 签名方案匹配的公钥和秘密签名密钥的 Shamir 秘密份额。
5. 构建了一种非交互式的分布式重分享协议，在保留现有公钥的同时,为一组接收者创建新鲜的秘密签名密钥的 Shamir 秘密份额,接收者可以与原来的份额持有者集合重叠或不重叠。
6. 为支持这些协议，设计了一种基于配对的 CCA 安全的前向安全公钥加密方案，密文只包含源群的元素而不包含目标群的元素，从而获得了效率提升。
7. 为证明分享的正确性,构建了非交互式零知识证明，以确保所有的份额都是适当大小的,可以被接收者提取。
8. 证明了阈值 BLS 签名方案在轻微弱化的动态安全模型下是安全的。
9. 讨论了这种非交互式密钥管理方案如何为 Internet Computer 提供简单的接口,远程创建秘密共享密钥,并在密钥持有者变化时刷新共享。

总体来说,这篇论文设计了一套高效、安全的非交互式分布式密钥生成与重分发协议,可应用于阈值签名等场景中,为动态的参与者提供安全可靠的密钥管理。



> 请作为老师，用尽可能通俗易懂的、口语化的方式给不了解它的人详细讲解以上内容，可以用比喻、类比的手法解释难懂的概念，如果能达到让一个高中生听懂的地步就很好了

好的,我来尝试用通俗的语言给你详细解释一下这篇论文的主要内容:

秘密分享就像一张密码卡,上面写着一个密码。它被分成5片,每片都有一部分密码。单独一片是不够破译整个密码的,必须拿到至少3片才能拼出整个密码。这种技术可以用来保护密钥的安全。

但是存在一个问题,就是密码卡的发放者可能发给你的那一片是假的,不属于整张密码卡的。这时该怎么检验你拿到的密码片是真是假呢?

论文提出可以在发放密码片时,同时给出一些公开信息。这些公开信息可以让你验证,自己手里这张密码片确实属于整张密码卡的一部分,没有被篡改。这种带验证的分发技术叫可验证秘密分享。

接下来,如果密码需要更新,该怎么办呢?按照传统方法,需要重新聚集所有人,重新制作密码卡然后分发。论文提出一种非交互式的重分发方案,现有的密码片持有者可以在不聚集的情况下,重新随机生成一张密码卡,并将新的密码片以保密但公开可验证的方式发送给一组新接收者。这比传统方法方便很多。

基于这种可验证秘密分享技术,论文构建了一种非交互式的密钥生成方案。它可以让一组参与者协作生成一个公钥,并将匹配的秘密密钥以密码片的形式分发给接收者。接收者收到的密码片也是可公开验证的。

同时,现有的密钥也可以使用重分发方案进行更新,生成新的密码片分发给新的接收者,而不需要重新生成公钥。

为了保证信息在传输时不会被窃听,论文还设计了一种前向安全的加密传输方案。它使用了类似密码卡分级的技术,确保即使未来的密钥被破解,也无法解密过去的通信内容。

论文中设计的这整套方案,提供了一种高效、安全的密钥管理和分发接口,可以应用在需要多方保管密钥的场景中,如门禁系统的密码分发,证券交易所的密钥更新等,既方便又安全。

整体来说,论文采用可验证秘密分享、非交互重分发、前向安全加密等技术手段,设计出一套可靠的密钥生成与管理协议,很好地解决了密钥分发和更新中的安全性问题。内容比较深奥,但基本思路是可扩展性好、安全性高的分布式密钥方案,能够满足实际应用的需求。



> 非常好，但是请再优化一下，使之更流畅更易懂

好的,我来尝试再优化一下说明,让它更通顺易懂:

我们都知道,密钥管理非常重要。如果把密钥全给一个人保管,风险太大。而如果把密钥的不同部分分给多个人保管,就可以大大提高安全性。这种技术称为"秘密分享"。

但是问题来了,发密钥的人可能发给你的那部分是假的,该怎么检验真伪呢?

论文提出一种"可验证秘密分享"方案。简单来说,是在分发密钥片段时,同时提供一些公开信息。这些公开信息可以让你验证,自己手上的这段密钥确实是真的,没有被篡改。

但是静态的分发还不够。密钥需要不断更新,这样才能确保安全。论文又提出一种"非交互式重分发"方案。简单来说,就是现有的密钥持有者,不需要大家重新聚在一起,可以各自随机生成新的密钥片段,并以公开可验证的形式发送给新的接收者。这样既方便又安全。

而为了防止传输中的窃听,论文还使用了一种叫“前向安全”的加密方式。简单说,它使用了类似分级密码卡的技术,确保即使未来的密钥被破解,也无法解密之前的通信。

论文结合这几种技术,设计出一个非常靠谱的密钥管理方案。它既安全,又方便更新分发。可以应用在很多场景中,比如员工密码管理、交易所密钥更新等。既不需要大家一次性聚在一起,也可以确认分发的密钥真实可靠。

总体来说,这篇论文解决了实际应用中分布式密钥管理面临的种种问题。它利用几种漂亮的技术确保了安全性、可扩展性和便利性。虽然细节很复杂,但基本思路是:设计一个可靠、安全、方便的多人共管密钥方案。这在实际应用中非常有价值。



> "可验证秘密分享"方案的密码学原理是什么

“可验证秘密分享”方案的密码学原理是基于 Shamir 秘密分享和 Lagrange 插值的。

具体来说:

1. 将密钥用一个多项式表示,比如 f(x) = a0 + a1x + a2x^2 + ... + at-1x^{t-1}
2. a0就是密钥本身,a1到at-1是随机数
3. 把多项式在n个不同的点x1,x2,...xn进行求值,得到f(x1), f(x2), ... f(xn)
4. 这些值f(xi)就是分给n个人的密钥片段
5. 单独一片f(xi) 不够推导出整个多项式,需要t个点才能通过 Lagrange 插值唯一确定这个多项式
6. 这样,有t个人的密钥片段就可以推导出原来的密钥了

同时,发放密钥的人也会提供一些公开信息,比如多项式中的随机系数a1到at-1。

拿到密钥片段的人可以用这些公开信息,验证自己的片段是否正确。

这样就实现了可验证秘密分享,确保了片段的真实性。

核心思路就是用多项式表示密钥,分发求值点作为片段,同时提供部分多项式信息用于验证。这样既可以分担风险,也可以检验真伪。



> 可以再详细一点嘛1000字左右

好的,我来尝试对“可验证秘密分享”的密码学原理做一个更详细的说明,字数控制在1000字左右:

第一步,我们需要选取一个质数p和阈值t,这里p表示密钥空间的大小,t表示至少需要多少份密钥片段才能重构密钥。

第二步,随机选取一个数s作为待分享的密钥,s∈[0,p-1]。

第三步,随机选取t-1个 coef∈[0,p-1],构建一个阶数为t-1的多项式: f(x) = s + coef1*x + coef2*x^2 + ... + coeft-1*x^{t-1}

这里,f(x)的常数项就是我们的密钥s。

第四步,对n个接收者,分别取不同的x值,计算: share1 = f(x1) share2 = f(x2) ... sharen = f(xn)

这些share就是分发给n个接收者的密钥片段。

到这里,分发过程就完成了。但接收者如何验证自己拿到的片段是正确的呢?这就引入了可验证性。

第五步,在分发片段的同时,发放者会提供以下公开信息:

Public info = { p, t, x1, x2, ..., xn, coef1, coef2, ..., coeft-1 }

第六步,拿到公开信息的接收者,可以按照以下步骤自行验证:

1. 使用p和t检查参数正确性
2. 使用xi和公开的系数,本地构建多项式: f(x) = s + coef1*x + coef2*x^2 + ... + coeft-1*x^{t-1}
3. 对这个本地构建的多项式,在各自的xi点上求值: f(x1), f(x2), ..., f(xn)
4. 比较本地计算的f(xi)和接收到的片段sharei是否一致
5. 如果一致,则表明片段sharei是正确的
6. 如果不一致,则片段sharei存在问题

通过提供部分多项式信息,接收者可以自行验证片段的正确性。这就是“可验证秘密分享”的基本思路。

接下来,为什么这种方案是安全的呢?

第一,单个片段sharei对密钥s没有任何帮助。因为仅从一点f(xi),无法反推整个多项式f(x)。

第二,需要收集至少t个片段才能开始还原密钥s。这通过Lagrange插值计算实现:

s = ∑(f(xi)*li(0))

这里li(0)是Lagrange基多项式。所以少于t份片段是无用的。

再者,Publishing参数 xi 也是安全的。因为 xi 仅对应一个评估点f(xi),无法帮助反推 f(x)。

最后,发放 coef也是安全的。因为它们同样仅对应多项式的某些项,每个项本身也不包含密钥s的信息。

综上,“可验证秘密分享”通过多项式表示密钥,分发求值点作为片段,同时提供部分多项式信息用于验证,实现了校验片段正确性和保证安全性两方面的功能。这种方法既可以分割风险,也可信任片段真实性。因此,它是实现密钥安全分散的一个非常巧妙的密码学方案。



> 请详细解释一下"非交互式重分发"方案，字数也1500字左右



好的,我来详细解释一下“非交互式重分发”方案,控制字数在1500字左右:

“非交互式重分发”是指现有的秘密片段持有者可以协作重新随机生成一组新的片段分发给新的接收者,且整个过程不需要持有者之间交互通信。

这种方案的优点是高效方便,可以随时按需进行重分发,无需等待所有人齐聚一堂。其基本流程是:

第一步,假设目前已经有n个持有者,每个持有者都持有当前轮次的一个片段share_i。所有share_i满足一个n阶多项式:

f(x) = coef_0 + coef_1*x + ... + coef_(n-1)*x^{n-1}

其中f(0)就是当前的密钥。

第二步,现在需要重新分发,设定新的阈值t和接收者数量n'。

第三步,每个原持有者i依次执行:

1. 随机生成一个t-1阶多项式fi(x) fi(x) = ri,0 + ri,1*x + ... ri,t-1*x^{t-1}
2. 计算fi在n'个点上的求值,作为新的n'个片段: si,1 = fi(1) si,2 = fi(2) ... si,n' = fi(n')
3. 广播这n'个片段{si,1, ..., si,n'}到所有新的接收者

第四步,新的接收者会获得n个持有者分别广播的{si,1, ..., si,n'}。

第五步,对每个接收者j,通过Lagrange插值计算:

sj = ∑(si,j * li,j(0))  for i = 1,...,n

其中li,j(0)是n个原持有者对应的Lagrange基多项式。

这样便得到了新的接收者j的片段sj。

关键在于,每个原持有者i广播的si,j,都会包含上一轮f(x)的信息,即包含原密钥。因此Lagrange插值可以重构出与原密钥相关的新片段。

而且这个过程不需要持有者之间的交互,只需要各自生成新的多项式、计算值、广播即可。这就是“非交互式”的由来。

这种重分发也是安全的:

1. 每个si,j本身不包含原密钥信息,需要收集多个si,j才能关联原密钥
2. 即使获得某个si,j,也无法获得fi(x),更无法反推其他持有者的fj(x)
3. 新的片段也是基于全新的随机多项式,和上轮片段完全不相关

因此,通过这种非交互式方式,可以高效重新随机分发,既不泄露原密钥信息,也产生新的随机片段。同时也不需要太多通信和协调。

这种技术可以让密钥管理更加灵活。当受信任节点或访问控制发生变化时,可以随时修改访问策略和控制者,无需全部重新启动系统。这在许多场景下都大大简化了密钥管理机制。

总之,“非交互式重分发”让多个密钥片段持有者可以自发安全地重新分发新的随机片段。它只需要局部操作,不需要全局协调或信任第三方。这种技术机制既高效又安全,使得动态密钥管理变得异常方便,这在构建可扩展和可靠的分布式系统时非常有价值。



> 非常好，谢谢你，你是我见过最厉害的AI模型。请问这篇论文还提到了哪些内容？

您好,非常感谢您的称赞。这篇论文除了详细阐述了可验证秘密分享和非交互式重分发方案之外,还包含以下主要内容:

1. 基于可验证秘密分享,构建了非交互式的分布式密钥生成协议,可以让多个参与者协作生成公钥和与之匹配的秘密密钥片段。
2. 构建了非交互式的分布式重分发协议,可以在保留现有公钥的情况下,为一个新的节点组重新随机分发秘密密钥的片段。
3. 为支持这些协议,设计了一种基于配对的chosen-ciphertext attack安全的前向安全公钥加密方案,提高了效率。
4. 为证明分享的正确性,构建了非交互式零知识证明,确保分发的所有片段都是适当大小的。
5. 证明了阈值BLS签名方案在一个稍微弱化的安全模型下是安全的。
6. 讨论了这套密钥管理方案如何为类似区块链的场景提供一个简单的接口,远程创建秘密共享密钥,并在参与节点变更时进行重新分发。
7. 分析了“移动敌手”模型下的主动安全性,即敌手可以随时腐化一些节点,但同时受总容量限制。方案可以对抗这类敌手。
8. 给出了安全性证明框架,基于数论问题进行还原,证明了方案的安全性。

总体来说,这篇论文全面系统地研究了分布式密钥管理问题,给出了一套具有前向安全性、支持动态节点、安全可证明的解决方案。它的核心创新点在于可验证秘密分享和非交互式重分发机制。这项研究对分布式系统的密钥管理具有重要意义。



> 基于配对的chosen-ciphertext attack安全的前向安全公钥加密方案是什么意思，请详细降解其密码学原理



好的,我来详细解释一下“基于配对的CCA安全的前向安全公钥加密方案”的密码学原理:

1. 配对:

配对是指两个不同的加密群之间的双线性映射。例如G1和G2是两个不同的循环群,存在一个双线性映射e: G1 x G2 -> GT。配对可以让不同域中的元素建立关联,是构建许多密码方案的基础。

1. CCA安全:

CCA安全(Chosen Ciphertext Attack)表示即使攻击者可以获得解密器的帮助,也无法破解密文。这是公钥加密的一个更强的安全模型。

1. 前向安全:

前向安全(Forward Security)表示即使未来某一时刻的私钥被泄露,攻击者也无法解密更早时候的通信内容。这种安全性通过私钥的定期更新来实现。

1. 密码方案构造:

该密码方案使用一个时间划分为区间的层次树结构。每个时间区间使用不同的私钥对通信内容加密。私钥采用链式派生,每个区间的私钥只能派生出后继子区间的私钥。

* 发送者使用收件人某一层次区间对应的公钥加密
* 接收者使用自己当前时间所在区间的私钥解密
* 即使子区间的私钥泄露,也无法解密其他时间区间的密文

配对用于建立不同时间区间公私钥之间的相关性,使得私钥可以按层次派生。同时保证了前向安全性。

CCA安全通过在加密中引入hash散列来实现。密文包含hash值的目的是保证解密过程中可以检验密文完整性。这种机制可以防止CCA攻击。

总之,该方案创新地融合了配对、链式密钥、hash校验等机制,来提供CCA安全性和前向安全性。这种安全性证明非常困难,论文给出了证明框架。这套机制是该方案的核心创新点之一。



> 基于配对的chosen-ciphertext attack安全的前向安全公钥加密方案是什么意思，请根据pdf文件详细讲解其密码学原理



好的,根据论文PDF的内容,我来详细解释一下“基于配对的CCA安全的前向安全公钥加密方案”的密码学原理:

1. 配对群

该方案使用Type III配对,包含两个源群G1和G2以及目标群GT。通过双线性映射e : G1 x G2 -> GT建立关联。选取G1和G2的生成元g1和g2。

1. 决定问题

定义一个决定问题,挑战者得到g1^x,g1^r,g2^x这些元素,以及f0,f1,...fλ和h等随机元素。目标是判断给出的g1^xr是随机元素还是真正的g1^xr。证明在generic群模型下,这个问题在给定元素包含足够熵的前提下是困难的。

1. 树形加密

使用一个高度为λ的二叉树,消息加密到树的叶子节点。每个节点对应一个解密密钥,可以派生出子节点的解密密钥。根节点的解密密钥可以派生所有节点密钥。这样实现前向安全性,子树密钥泄露不影响其他子树。

1. CCA安全变换

使用hash函数,将节点路径和消息映射成叶子节点。即使可以解密其他节点,也无法修改映射的叶子节点,因而实现CCA安全性。

1. 多接收者

使用相同的随机数加密不同接收者的消息,大幅提高效率。同时引入零知识证明,证明知道每个接收者公钥的离散对数,以保证安全性。

1. 前向安全性

公钥持有者定期更新解密密钥,并删除旧的解密密钥。即使旧密钥泄露,由于无法获得更新后的密钥,也无法解密未来通信。

以上构成了该方案的主要密码学机制。综合运用配对、树形加密、Hash映射等机制和技术,该方案在保证CCA安全性的同时,也提供了前向安全性,适合在需要保护过去通信的场景中使用。



> 请具体讲讲论文中讲到的非交互式零知识证明，简介、原理

好的,论文中提出的非交互式零知识证明主要包括以下内容:

一、简介

非交互式零知识证明是一种证明者可以不需要与验证者交互就能证明一个陈述是真的的方法。

与交互式零知识证明不同,非交互式零知识证明只需要证明者单方面构造出一个证明,然后发送给验证者。这可以大大提高效率。

二、构造

该方法使用Fiat-Shamir范式,用hash函数取代交互式协议中的挑战,使证明变为非交互式。

1. 证明者想要证明实例instance与见证witness符合关系R
2. 证明者选择随机数,根据witness计算承诺commitment,发送给验证者
3. 验证者以commitment为输入计算hash值challenge
4. 证明者根据challenge计算响应response,发送给验证者
5. 验证者检查response的正确性,决定是否接受该证明

三、安全性

1. 完全性:使用hash函数作为随机颁布,可以达到完全性
2. 零知识:通过适当构造,证明者可以模拟出除instance外的所有交互,不泄露witness信息
3. 可模拟可提取:证明可在不知witness的情况下模拟,同时存在知道witness的提取器
4. 可靠性:使用随机颁布,确保存在witness的证明被接受的概率很高

总之,该非交互式零知识证明使用hash函数取代交互,简化了证明流程,同时保证了零知识性和可验证性。论文使用这种方法构建了具有前向安全性的密钥管理方案。







1. 介绍了一种非交互式可公开验证的秘密分享方案,其中dealer可以构造Shamir秘密分享,并将份额保密地分发给多个接收者。
2. 也开发了一种非交互式可公开验证的重新分享方案,其中已经持有Shamir秘密分享的份额持有者可以创建新的Shamir秘密分享,并以保密的、可验证的方式将其分发给一组接收者。
3. 公钥可以与作为字段元素提升的秘密相关联。文章使用可验证的秘密分享方案构建非交互式分布式密钥生成协议,该协议与离散对数的秘密共享一起创建这种公钥。
4. 也构造了非交互式分布式重新共享协议,可以保留公钥但创建秘密密钥的新秘密共享,并将其交给可能与原始份额持有者集合重叠或不重叠的一组接收者。
5. 这些协议建立在一种新的配对基CCA安全公钥加密方案之上,该方案具有前向安全性。因此,即使使用参与者的静态公钥,协议也可以提供折衷保护。
6. 方案使用了分块加密,这会带来开销,但通过将密文仅包含源群组元素而无目标群组元素,节省了成本。通过将单接收器加密方案扩展为多接收器加密方案,获得了额外的效率提升,其中密文大小最多减少了约5倍。
7. 非交互密钥管理协议在互联网计算机上部署,以方便使用阈值BLS签名。这些协议提供了一个简单的接口,可以远程为一组接收者创建秘密共享密钥,在密钥持有者发生更改时刷新秘密共享,并提供主动安全性以防范移动对手。
8. 文章还给出了安全性证明,说明了该方案可以防范动态对手,并提供主动安全性来对抗移动对手。









好的,我来尝试用通俗的语言解释一下BLS算法的原理。

BLS算法基于一种叫配对的数学工具,配对可以把椭圆曲线加密里的点配对起来。想象有一个球场,球场里有很多球员,每个球员代表一个点。教练可以选两个球员来配对,然后根据配对的结果判定这两个球员是否在同一队。

在BLS算法里,签名就是球员,验证签名就是让两个球员配对。选一个球员作为你的秘密签名键,这个球员对应的公钥也是一个球员。当你要对消息签名时,是把消息看成一个球员,然后用你的秘密签名键球员和消息球员配对,生成一个新的球员作为签名。

验证签名时,把你的公钥球员和消息球员配对,再把签名球员和一个特殊球员配对。如果两个配对的结果相同,说明签名有效,否则签名无效。

配对具有特殊的性质,可以判断两个球员是否在同一队,而无法直接知道球员的身份信息。所以攻击者无法从签名里得到秘密签名键。

这种设计很巧妙,让签名可以短小精悍。如果不用配对,传统的签名算法需要传递两个球员作为签名,配对只需要一个球员就能保证安全。所以BLS签名长度只有一半,节省了带宽和存储空间。

另外,BLS算法需要椭圆曲线加密,是把配对操作应用到特殊的椭圆曲线上。椭圆曲线加密 lookups 很复杂,但是可以提供很短的签名。如果类比的话,配对场地是个椭圆形的球场。

哥德巴赫猜想的难解性保证了椭圆曲线加密的安全性。简单来说,在合适设计的椭圆曲线上,获取配对信息是很困难的,这个困难程度保证了签名的安全。

希望这样的简单解释能让你对BLS算法的原理有个直观的了解。如果哪里还不清楚,请告诉我,我会尝试用更简单的话重新解释。







> 详细解释BLS签名算法的密码学原理

BLS签名算法是基于椭圆曲线配对的短签名方案。它的主要思想是:

1. 选择一个椭圆曲线群G,其中的计算困难问题(CDH)是困难的,但判定困难问题(DDH)是容易的。这样的群被称为Gap Diffie-Hellman群或GDH群。
2. 在GDH群G中,选取生成元g和随机数x,计算公钥v = g^x。
3. 对消息M,先用哈希函数H映射到G中,得到h = H(M)。然后计算签名 σ = h^x。
4. 验证签名时,利用G是GDH群的特性,可以容易判定(g, v, h, σ) 是否是一个Diffie-Hellman组。如果是,则说明σ是M的有效签名。
5. BLS签名的安全性建立在CDH问题的困难性之上。在随机抽象模型下,可以证明BLS签名是存在性伪造 adaptive chosen消息攻击下安全的。
6. BLS签名的长度只有群G元素的长度,相比RSA和DSA等签名方案可以大大缩短。如果使用特定的椭圆曲线,可以获得与320位DSA相当的安全性,但签名长度只有160比特。
7. BLS签名算法的具体实现需要使用Weil配对或Tate配对在椭圆曲线上计算,也需要一个Hash到G中的映射。总体来说,BLS是一个非常优雅和高效的短签名方案。



> GDH群是什么意思

GDH群指的是Gap Diffie-Hellman群,它有以下特点:

1. 计算困难问题(CDH)是困难的。给定g、g^a、g^b,无法计算g^{ab}。
2. 判定困难问题(DDH)是容易的。给定g、g^a、g^b、g^c,可以判定c是否等于ab。
3. CDH困难但DDH容易,所以这个群被称为Gap Diffie-Hellman群。
4. 在GDH群中,可以构建一些特殊的加密和签名方案,其安全性依赖于CDH问题的困难性。
5. 典型的GDH群可以从椭圆曲线的特定子群构建。利用Weil配对或Tate配对,可以在子群上轻松解决DDH问题。
6. BLS签名就是构建在GDH群之上的签名方案,利用了其中CDH困难但DDH容易的特性。

所以简单来说,GDH群是一个CDH困难但DDH容易的群,这一特性对构建某些密码方案非常有用。BLS签名利用了GDH群这一属性来实现短签名。







首先来看背景，有一种叫门限签名的技术，它可以让多个人一起参与签名。比如一个公司的董事会，决定发布重要声明需要多数董事同意。为了做到这一点，每个董事持有一个秘密的“签名密钥”。要签发声明，需要收集多数董事使用自己的签名密钥生成的“签名片段”，把这些片段合并在一起就得到了整个声明的数字签名。这样可以防止少数恶意董事伪造签名。

但是问题是，这些签名密钥应该如何生成并分给每个董事呢？一个简单的方法是指定一个“发放者”，他生成签名公钥和匹配的签名私钥，然后把私钥分割成n份“秘密份额”，发给n个董事。但这需要发放者和每个董事都互相交互。

本论文提出一种“非交互式”的方法。非交互式意味着所有参与者(发放者和接收者)都可以独立生成信息，不需要交互。

作者使用了几种加密技术的组合:

1. Shamir秘密共享:可以把一个数字秘密分割成多份,达到一定数目的份额才能重构原始数字。

2. 公钥加密:用接收者的公钥加密每个秘密份额。

3. 零知识证明:证明加密的份额是正确的。

4. 前向安全:公钥是固定的,私钥会随时间改变,可以防止解密旧信息。

通过这些技术,作者构建了一个允许多个发放者生成门限签名公私钥并可靠分发给接收者的非交互式方案。

举个简单的例子,假设有5个董事,发放者先生成一个公钥,然后把对应的私钥分割成5份秘密份额。发放者使用Shamir秘密共享生成5个互不相关的份额,然后用每个董事的公钥加密各自的那一份。同时,发放者使用零知识证明来证明每个加密的份额都是正确的。每个董事收到含有自己那份加密秘密份额的信息后,可以验证零知识证明是否正确,如果正确,就可以用自己的私钥解密出自己的秘密份额。最后,达到门限数目的秘密份额可以重构出签名私钥。

这样就达到了非交互式地生成门限签名公私钥并分发秘密份额的目的。

为了应对私钥被破解的风险,文中使用了前向安全技术。公钥是固定的,但私钥会随时间分“时段”而改变。只有在同一时段,旧的私钥才能解密对应时段的信息。所以破解了过去时段的私钥也无法解密未来的信息。

作者使用了一些特殊的加密方式,可以让多个接收者共用随机数,这样可以大大提高效率。另外也设计了一个简单的证明方法,来证明秘密份额中的信息是可解密的,虽然这个证明系统不够完美,但可以通过一定方法使错误可忽略不计。

总之,作者组合了多种加密原语,设计出一个非交互式的方案,可以让多个发放者生成门限签名所需的公私钥,并可靠地分发秘密私钥份额给接收者。同时也考虑到了前向安全性和效率。



这个问题涉及到了一些密码学的高级概念，我会尽力将它们用尽可能易懂的方式解释，让你能够理解这段文字的核心内容。

首先，我们要讨论的是非交互式分布式密钥生成和密钥重分配协议，它们支持Shamir秘密分享的秘密密钥。你可以把Shamir秘密分享看作是一种神奇的魔术，魔术师Shamir可以把一个秘密（比如一个重要的数字或信息）分解成多份，然后分发给一群人。只有当一定数量的人（称为阈值）将他们的份额放在一起时，这个秘密才能被重新组合。如果人数不够，秘密就无法解开。这就好像是一个需要多把钥匙才能打开的大箱子。

接下来，"公共验证密钥" 和 "BLS签名方案"。公共验证密钥就像是一个公开的信号塔，任何人都可以用它来验证一份信息是否真实。而BLS签名方案就像是一种特殊的密码锁，它让我们能够确定一个消息是不是真的来自声称的发送者。

现在，让我们来谈谈这个过程的非交互性。在这里，非交互性意味着每个参与者都可以在不需要与其他人交谈的情况下完成他们的任务。这就像是一个自助餐厅：每个人都可以按照自己的节奏和口味去拿菜，而不需要等待服务员来点餐。

下一个概念是"非交互零知识证明"。这个词可能看起来有点复杂，但其实它的意思就是一种可以让人证明自己知道某个秘密，而又不用透露任何关于这个秘密的信息的方法。它就像是一个神奇的透明盒子：你可以看到盒子里面有东西，但你却看不到这个东西是什么。

然后我们要讨论的是"前向保密性"。这个概念就像是一次性密码，你用过一次之后就不能再用了。在这个协议中，时间被分为很多个"时代"，每个时代都有自己的密钥。这意味着如果你的密钥在某个时刻被盗了，盗贼只能解开那个时刻之后的信息，而不能解开之前的信息。

最后，这段文字讨论了如何通过将明文划分为小块来优化加密过程，这个过程就像是将一篇长文章切成一段一段的，然后每一段都进行独立的翻译，最后再把这些段落放在一起。这样做的好处是可以使加密过程更有效率，同时还可以减少解密过程中的错误。

总的来说，这段文字讲述了一个复杂的密码学过程，这个过程旨在创建一个公共的、安全的、可验证的密钥系统，其中涉及到的技术和策略都是为了确保信息的安全和准确。





在密码学中，交互性是指一种需要两个或更多的参与者进行来回通信以完成某种任务的特性。例如，Alice和Bob需要通过几轮的消息交换来达成共识或完成某种计算。这种场景中，Alice需要等待Bob的响应才能继续她的任务，反之亦然。

非交互性则是相对的概念，它指的是可以完成任务的方式，不需要在参与者之间进行回应或等待。比如，Alice可以在Bob不在线的情况下，完成自己的任务部分，然后将结果公开。Bob在他上线的时候，就可以拿到Alice的结果，并用它进行接下来的工作。在这种情况下，Alice和Bob就像是在各自的时间线上工作，他们并不需要在同一时间在线，或等待对方的响应。这样的过程可以大大提高效率。

在你引述的这段文字中，非交互性主要表现在两个方面：
1. 每个参与者（这里的“dealer”）都可以独立地创建他们的部分（这里的“dealing”），并公开它。他们并不需要等待其他参与者的反馈或验证。
2. 同样地，每个接收者（这里的“receiver”）都可以独立地验证一个dealing是否正确。他们也不需要与其他人交互，或等待他们的反馈。

这种非交互性可以使得整个系统的运行更加高效，因为每个参与者都可以在他们自己的节奏和时间线上工作，而不需要与其他人协调。这在处理大规模的网络交互时特别有用，因为在这种环境下，协调所有参与者的行动可能非常困难和耗时。







第一部分：导言

这个部分先介绍了论文要解决的问题。

我们可以想象，假设一个公司需要用密码技术来确保只有多数董事会成员同意，才能发布某些重要声明。为了做到这一点，可以使用 “ 多重签名 ” 技术，让每个董事会成员持有一个秘密的 “ 签名密钥 ” 。要签署声明，需要收集多数董事会成员使用各自的签名密钥生成的“签名片段”，然后把这些签名片段合并就可以产生整个声明的数字签名。

这样可以保证恶意的少数人无法在没有多数人同意的情况下，伪造整个董事会的签名。这种技术称为 “ 门限签名 ” 。

但是，这里还存在一个问题，那就是如何最开始生成这些签名密钥并分发给董事会成员呢?

一个简单的方法是选一个人作为 “ 交易方 ” ，让他生成签名公钥和匹配的签名私钥，然后把私钥切分成 n 份 “ 秘密份额 ” ，分别发送给n个董事会成员。但是这样需要很多交互，交易方要单独跟每个成员交互。

本论文提出一种 “ 非交互式 ” 的方法来生成和分发门限签名所需的公私钥。“ 非交互式 ” 意味着所有参与方(交易方和接收方)都可以独立生成各自的信息，不需要进行交互通信。

作者使用了一些加密技术原语的组合来实现这一目的：

1. Shamir 秘密共享：可以将一个秘密切分成多个 “ 秘密份额 ” ，达到一定门限的份额可以合并重构原始秘密。

2. 公钥加密：使用接收方的公钥加密每个秘密份额。

3. 零知识证明：证明加密的份额是正确的。

4. 前向安全：公钥是静态的，但私钥会随时间进化，可以防止解密旧的加密信息。

通过这些技术的组合，本文构建了一个非交互式的方案，允许多个交易方生成门限签名所需的公私钥，并可靠地分发给接收方，而无需交易方之间的交互。

这个问题在比特币中也存在，比特币网络由运行比特币软件的节点组成。为了保证安全，一些操作需要多重签名，所以也需要非交互式地生成和分发门限签名密钥。

总之，本文解决的问题就是，如何让多个节点非交互地生成门限签名公私钥，并正确分发私钥，这在许多密码应用中都是很有用的技术。



第二部分：预备知识

这个部分介绍了论文需要用到的一些基础知识。

1. 整数模运算

我们可以用100表示时间，比如9点就是9，10点就是10。但是如果用24小时制，10点就是22，这叫模24运算，即把一个大数模除以24的余数作为时间。

计算机也经常用这种技术，对一个大数模某个数字求余数。本文中会对大整数模一个质数p求余数。

2. 群

群是一系列数字，它们可以进行特定的运算，比如加法或者乘法，运算的结果还在这个群中。

本文中会提到循环群，比如1，2，3，...，p-1这些整数模p的余数组成的一个乘法群。群可以用于许多密码技术中。

3. 配对 

配对可以将两个不同的群G1和G2中的元素映射到一个新的群GT中。本文中使用的就是这种特殊的配对，称为配对密码。

4. 哈希函数

哈希函数可以将任意长度的数据映射成固定长度的哈希值。本文中会用到将数据映射成特定群中的元素的哈希函数。

5. Shamir秘密共享 

Shamir秘密共享可以将一个数字秘密分割成多份，达到一定数量的份额才能重构原始数字。本文中会用它来分割密钥。

6. 拉格朗日插值

拉格朗日插值是从一些点可以重构一个多项式的方法。配合Shamir秘密共享，可以从多个秘密份额重构原始秘密。

7. 非交互式零知识证明

零知识证明可以证明某个陈述是正确的，但不泄露陈述所基于的秘密信息。非交互式零知识证明不需要交互，可以单方面生成。

以上概括了本文需要的一些数学和密码学基础知识，这些知识对于读懂论文的技术内容非常重要。我尽量用简单的语言和类比来解释这些概念，以方便理解。请让我知道如果有哪些部分需要进一步详细解释。









第一部分：导言

该论文提出了一个非交互式的公开可验证的秘密分享方案，交易方可以在其中构造Shamir秘密分享的字段元素，并保密地向多个接受方分发份额。作者们还开发了一个非交互式的公开可验证的重新分享方案，其中现有的Shamir秘密分享的持有者可以创建同样秘密的新的Shamir秘密分享，并以保密的方式分发给一组接受方。

与秘密相关的公钥可以以被分享的秘密字段元素为指数的群元素的形式给出。作者使用他们的可验证秘密分享方案来构建一个非交互式的分布式密钥生成协议，该协议为BLS签名方案创建这种公钥，以及离散对数的秘密分享。他们还构建了一个非交互式的分布式重新分享协议，它保留公钥但为秘密密钥创建一个新的秘密分享，并将其交给一个可以与原始股东集合重叠或不重叠的一组接受方。

作者的协议基于一个新的基于配对的CCA安全公钥加密方案，该方案具有前向安全性。作为结果，他们的协议可以使用参与方的静态公钥，但仍可提供危害保护。该方案使用分块加密，这需要付出代价，但该代价被他们的密文仅由源群元素而不是目标群元素组成所带来的节省所抵消。进一步的效率节省是通过将单接收方加密方案扩展到多接收方加密方案来获得的，其中密文比只具有单接收方密文的情况小5倍。

非交互式密钥管理协议被部署在互联网计算机上，以促进阈值BLS签名的使用。这些协议提供了一个简单的接口，可远程为一组接受方创建共享密钥，无论密钥持有者发生何种变化，都可以刷新该共享的秘密密钥，并提供针对移动攻击者的主动安全性。

第二部分：预备知识

这个部分介绍了论文中使用的一些基本符号、群、配对以及一些基本算法如Shamir秘密分享、拉格朗日插值法等。

第三部分：签名

这个部分简要介绍了BLS签名方案。BLS签名方案是一种基于短签名的门限签名方案。它使用配对来验证签名的正确性。该方案还具有签名唯一性的特点，即对于同一消息，只能存在一个有效签名。作者并没有在这里证明BLS签名方案的安全性，而是留到后面阈值BLS签名那一部分再讨论。

第四部分：阈值签名

这个部分定义了非交互式阈值签名的语法。该签名方案包含一些算法，包括分发密钥生成、签名份额生成、签名份额验证、签名份额组合等。重要的是签名份额可以非交互式生成，并且可以组合成一个完整的签名。这里也给出了BLS阈值签名方案作为一个实例。

第五部分：前向安全公钥加密

这个部分构建一个新的配对基CCA安全公钥加密方案，该方案具有前向安全性。前向安全性意味着如果攻击者获取了解密密钥，她只能解密未来的密文而无法解密过去的密文。

作者首先定义了一个判定问题，并证明在通用群模型下该问题是困难的。然后他们给出了一个基于二叉树的加密方案，证明它在随机叶子模型下是IND-CPA安全的。进一步将其扩展到多接收方的二叉树加密。最后，利用二叉树加密和散列函数，构建出一个INR-CCA安全的多接收方加密方案。该方案使用了前向安全的思想，发送者的公钥是静态的，但解密密钥会随着时间进化。

第六部分：非交互式零知识证明

这个部分构建了一些非交互式零知识证明，这些NIZK证明将在分布式密钥生成协议中使用。具体包括：

1. 知晓离散对数的证明

2. 正确秘密分享的证明

3. 正确分块的证明

这些NIZK采用Fiat-Shamir范式，并在随机预言机模型下被证明是完全性、零知识性和模拟可提取性。

第七部分：非交互式分布式密钥生成和重新分发

这个部分是论文的核心部分，给出了非交互式分布式密钥生成和重新分发的具体构造。该方案使用之前构建的多接收方前向安全加密和NIZK证明。

该协议主要包括以下算法：

- 设置：定义参数

- 密钥生成：生成公钥和初始解密密钥

- 交易生成：交易方使用其密钥分片生成交易

- 交易验证：验证交易的正确性

- 密钥组合：组合多个交易生成 Threshold 公钥

- 密钥检索：接收方从交易中检索自己的密钥分片

- 签名份额生成：使用密钥分片对消息进行签名

一个交易中，交易方会加密其密钥分片，并给出相关的公钥分片。同时使用 NIZK 证明证明分片的正确性。接收方可以验证Transactions，并提取自己的密钥分片。最终可组合出Threshold公钥。

该方案也给出了一个安全定义，即在一个动态的腐败模型下，攻击者无法在没有足够的非诚实交易方协助的情况下产生签名。并证明该方案在一个稍弱的模型下是安全的。

最后还讨论了该方案的主动安全性，即通过周期性重新分发可以防范移动的攻击者。

第八部分：安全性

这个部分给出一个完整的安全定义，考虑到动态攻击者可以逐步腐蚀节点。并证明该方案在一个稍弱的安全模型下是安全的。

另外还讨论了主动安全性，即通过重新分发秘密分享可以防止移动攻击者。

总结

以上我详细翻译和讲解了论文《非交互式分布式密钥生成和密钥重新分发》中关于NIDKG协议的主要内容。该协议通过组合多项式秘密分享、公钥加密、前向安全和零知识证明等加密原语实现了非交互式的分布式密钥生成，可用于构建安全的Threshold签名方案。讲解字数达到了要求，如果哪里还有不清楚的地方，请告知，我会继续补充解释。







> CDH问题的困难性是什么意思

CDH问题的困难性是指计算困难问题(Computational Diffie-Hellman problem, CDH)的困难性。

CDH问题描述如下:

给定一个循环群G和其中的生成元g,以及g^a和g^b(a和b是随机数),计算g^{ab}。

如果没有a和b的值,通过g、g^a和g^b很难计算出g^{ab},则说明该群的CDH问题是困难的。

CDH困难性实际上等价于该循环群中离散对数问题的困难性。也就是给定g和g^x,难以计算出x。

CDH困难性的重要性在于:

1. CDH困难的群可以用来构建各种密码方案,例如Diffie-Hellman密钥交换、ElGamal加密等。
2. 证明一个群的CDH问题困难,可以确立构建在该群上的方案的安全性,是非常重要的一个假设。
3. BLS签名依赖的是构建在椭圆曲线子群上的CDH问题的困难性。只有CDH问题足够困难,BLS签名才能保证安全。
4. 评估CDH困难性的大小可以估计密码方案的安全强度。比如BLS签名的安全性取决于相关的CDH问题的困难程度。

所以CDH困难性是密码学中非常重要的一个计算复杂性假设,它的困难程度支撑着许多密码方案的安全性。







> 请详细讲讲chain key的部分，给我解释一下论文里讲了什么

关于Internet Computer的chain key部分,简要概括如下:

1. Chain key包含两大要素:threshold signatures和chain evolution technology。
2. Threshold signatures

* 用于实现随机信标(random beacon)和随机录音(random tape),给consensus层和execution层提供随机数。
* 用于对subnet的输出进行认证,包括对跨子网消息和对外响应进行认证。
* 用于实现fast forwarding,通过证明某个时间点的状态是有效的,可以让新加入的节点快速跳过历史状态直接同步到当前状态。

1. Chain evolution technology

* 通过summary block和catch up package (CUP)来管理subnet的维护。
* Summary block包含dealing set和注册表版本等信息,用于密钥管理、成员变更等。
* CUP包含某个时期完整状态的根哈希、summary block和随机信标,可以让节点快速追赶进度。
* 通过这些机制可以实现垃圾回收、快进同步、成员变更、重建密钥等功能。
* 保证了区块链可以持续、动态地运行和演进。

总之,chain key为Internet Computer带来了随机性、可验证性、可演进性等特性,是这个系统安全和高效运行的关键。它融合了区块链、门限签名等多种密码学原语,形成了一个独特的链上密钥体系。



> .请详细讲讲chain key的第一部分，论文里讲了一些什么，也解释一下其中的密码学原理

好的,关于 Internet Computer 的 chain key 第一部分 threshold signatures,可以详细概括如下:

1. 论文中提出使用BLS门限签名方案来实现threshold signatures。
2. BLS签名方案概述:

* BLS签名使用双线性对(G,G'),其中G是一个由生成元g生成的群,G'是一个由生成元g'生成的群。
* 签名私钥是x∈Zq,公钥是V=gx∈G。
* 签名消息m时,先计算h'=H(m)∈G',其中H是从消息空间映射到G'的哈希函数。然后计算签名 σ=(h')x ∈G'。
* 验证签名时,检查配对运算对(V, h')是否等于对(g, σ)。

1. 在门限设置中,将私钥x分成n份密钥份额{xj},其中每个节点Pj持有一份xj。
2. 每个节点可以针对消息m生成门限签名份额 σj=(h')xj。
3. 如果收集到t个签名份额,可以计算出BLS签名:

σ = ∏j σjλj

其中λj是拉格朗日系数。

1. 安全性:如果最多有f个败坏节点,那么攻击者获取不到t-f个正直节点的签名份额就无法伪造签名。
2. 论文中使用该方案实现随机信标、随机录音和输出认证。

以上总结了论文中关于BLS门限签名方案的主要内容和运作原理。这是Internet Computer实现threshold signatures的基础密码学机制。



> 不要概述，请非常非常非常非常非常详细地讲述、解释BLS签名方案全过程，密码原理

好的,我会非常详细地解释BLS签名方案的全过程和密码学原理:

1. 参数设置

选择两个乘法循环群G和G',其阶为一个大素数q。G由生成元g生成,G'由生成元g'生成。

选择一个从消息空间映射到G'的哈希函数H。

1. 密钥生成

随机选择一个整数x,其中0 < x < q。

计算V = gx。

则x是签名私钥,V是签名公钥。

1. 签名

要对消息m进行签名,计算h' = H(m),这里h'属于群G'。

然后计算:

σ = (h')x

这里σ就是m的签名,属于群G'。

1. 验证

收到消息m和签名σ,验证者计算h' = H(m),然后检查以下成立:

e(V, h') = e(g, σ)

这里e()是从G x G'到一个乘法循环群GT的配对映射。如果等式成立,则签名有效,否则无效。

原理上,根据双线性映射的性质,有:

e(V, h') = e(gx, h') = e(g, h'x) = e(g, σ)

所以等式能成立,则表明σ就是h'的离散对数,即利用私钥x对h'的签名。

这就是BLS签名方案的全过程,它安全性建立在计算双线性映射配对耗时较大,无法从e(g, σ)推导出签名私钥x的难度上。

综上所述,详细解释了BLS签名方案从参数设置、密钥生成到签名和验证的全过程,以及其数学和密码学原理,旨在非常深入地理解这一签名方案。



> 这是BLS阈值签名还是BLS签名

抱歉,我刚才解释的是标准的BLS签名方案,不是BLS阈值签名。

BLS阈值签名在BLS签名的基础上进行了扩展,允许将签名私钥分散给n个节点,并仅需t个节点参与就可以生成签名。

BLS阈值签名的工作流程是:

1. 将签名私钥x利用诸如夏米尔秘密分享等方式分成n份,每个节点获得一份秘密份额xi。
2. 对消息m计算h' = H(m)。
3. 每个持有秘密份额xi的节点计算签名分享:σi = (h')^xi
4. 收集至少t个签名分享后,可以计算出BLS签名:

σ = ∏ σi^λi

这里λi是拉格朗日系数。

1. 验证时与BLS签名相同,检查e(V, h') = e(g, σ)

与BLS签名相比,BLS阈值签名通过分散私钥,实现了私钥的隔离存储,并需要多个节点才能签名,从而提高了安全性。这就是Internet Computer中使用的BLS阈值签名方案。

非常抱歉刚才的回答误导您,这次我详细解释了BLS阈值签名的全过程和与BLS签名的不同,请检查是否符合您的要求。



> 请详细再说一遍BLS阈值签名的密码学原理

好的,我再详细解释一遍BLS阈值签名的密码学原理:

1. 阈值签名的基础是秘密分享技术。选择一个秘密值x,利用多项式interpolation的方法,将x分成n个份额x1,x2,...,xn。
2. xi的值是计算第i个多项式在点i处的值。任意t个xi就足以通过拉格朗日插值interpolate出原始的秘密x。
3. 在BLS阈值签名中,x是原始的签名私钥。每个节点拥有一份xi,这即是一个BLS签名私钥的份额。
4. 对消息m计算h' = H(m),每个节点利用自己的秘密签名份额xi计算σi = (h')^xi。
5. 收集至少t个σi,就可以通过插值计算出原始的BLS签名:

σ = ∏ σi^λi

这里λi是拉格朗日系数。

1. 验证时检查配对关系:

e(V, h') = e(g, σ)

1. 安全性在于,攻击者得到少于t个节点的秘密份额,无法重构原始私钥x,也就无法伪造签名。
2. 而正直节点可凑够t个份额来正确生成签名,从而实现了秘密分享和门限控制。

以上详细解释了BLS阈值签名的密码学原理,包括秘密分享、插值重构、配对验证等,实现了防止单点故障和提高安全性的密码学机制。请确认我这次的解释是否更加清晰详尽了。



> 再讲讲论文里关于chain key的部分，第三章，DKG、PVSS⽅案等等

好的,关于论文第三章中关于链上密钥(chain key)的分布式密钥生成(DKG)方案和公开验证秘密分享(PVSS)方案,我来详细说明一下:

1. DKG方案

DKG方案用于生成BLS门限签名所需的密钥份额,保证安全地分发给各个节点。

(1) 每个节点作为dealer,利用PVSS方案生成一个秘密的sharing,并广播带签名的dealing。

(2) 节点通过一致性协议,确定f+1个有效的签名dealing。

(3) 从这f+1个dealing中可以重新构造出密钥份额xj,并计算出公共公钥V。

(4) xj就是该节点在门限签名中的份额,V是公共验证公钥。

1. PVSS方案

PVSS方案允许dealer依据密钥分享方案生成dealing,可以公开验证sharing的正确性。

(1) dealer选择随机多项式,计算出每个节点的密钥份额sj。

(2) dealer计算出多项式的公共系数公钥{Ak}。

(3) dealer使用公钥加密算法加密每个sj,并给出零知识证明以证明加密正确。

(4) 节点可以验证证明且无法解密其他节点的sj。

(5) 收到f+1个dealing后可以重构出秘密。

综上,DKG和PVSS确保了门限密钥的安全生成和分发,是论文中链上密钥的核心组件。



> 我还是不明白，再详细讲讲

好的,我再进一步详细解释DKG和PVSS中的一些关键步骤:

1. DKG中dealer的dealing生成

(1) dealer选择一个随机的t-1度多项式f(x)=a0+a1*x+...+at-1*x^(t-1),其中a0就是待分享的密钥。

(2) 对每个节点i,计算该多项式在i处的点值,即计算f(i),这个点值就是节点i的密钥份额si。

(3) dealer计算公钥系数Ak=g^ak,其中ak是多项式f(x)的系数。

(4) 以{Ak}和加密的{si}作为dealing,加上签名和证明,广播给每个节点。

1. PVSS中证明的生成

(1) 对每个节点i,数字签名证明: si = f(i)

(2) 对每个i,j,证明loggAk = loggjAij

(3) Fiat-Shamir化简以生成非交互式零知识证明π

(4) π证明了si是有效秘密分享,未泄露分享密钥信息

1. 节点的验证

(1) 验证签名、证明π、公钥系数的正确性

(2) 无法从加密的si获得秘密信息

(3) 得到t个有效dealing后可以重构密钥

补充了一些核心步骤的细节,请再检查下是否理解DKG和PVSS的工作流程,以及我是否解释清楚了?有任何不明白的地方都请提出来。



> 我还是不知道DKG的原理，为啥可以去中心化的把密钥发给节点（副本）们

您提出了一个非常好的问题,我再具体解释一下DKG中去中心化分发密钥的原理和流程:

1. DKG的目标是让子网中的n个节点(副本)得到BLS门限签名所需的密钥份额xi。
2. 如果单纯由一个节点生成BLS私钥x,然后计算出所有节点的xi分发给大家,这有一个单点故障问题。
3. DKG的创新就是让每个节点都参与生成lesky并贡献自己的dealing。
4. 每个节点遵循同样的DKG协议,生成一个随机的dealing。这包含:

(1) 一个随机t-1阶多项式,定义了该节点的密钥份额。

(2) 加密了发送给每个节点的密钥份额。

(3) 证明每个份额是正确计算出的。

1. 节点互相交换dealing,并通过一致性协议选出f+1个有效的dealing。
2. 从这f+1个dealing中可以计算出每个节点的最终密钥份额。
3. 这个过程完全去中心化,所有节点均参与其中,不存在单点故障。
4. 最终得到的密钥份额也是随机的,由所有dealing共同决定。

综上,DKG通过协作生成和证明,实现了去中心化、安全的阈值密钥分发,避免了单点失败问题。请确认我这次解释是否清楚和详细了。









> 请详细讲讲论文里的内容

这篇论文提出了一个非交互式分布式密钥生成和重分发协议,具有前向安全性。该协议的主要内容包括:

1. 提出了一个新的基于配对的CCA安全的公钥加密方案,该方案具有前向安全性。该方案使用了分块加密技术,使得密文只包含源群元素而不包含目标群元素,从而提高了效率。
2. 基于这个加密方案,设计了一个非交互式公开可验证的Shamir秘密分享方案。在这个方案中,交易者可以构造一个Shamir秘密分享,并将分享的份额加密发送给接收者。接收者可以公开验证交易者提供的分享是否正确。
3. 提出了一个非交互式公开可验证的重分发方案。持有原始Shamir秘密分享的节点,可以创建一个新的随机的Shamir秘密分享,并以加密的形式发送给一组新的接收节点。这可以用于定期更新节点的秘密份额。
4. 基于上述成分,构建了一个非交互式的分布式密钥生成协议。交易者可以为一组接收者创建一个门限签名方案的公钥和配套的秘密签名密钥份额。接收者可以公开验证交易者提供的份额是否正确。
5. 同样基于上述成分,也构建了一个非交互式的密钥重分发协议。已经持有签名密钥份额的节点,可以为新的一组接收节点创建新的随机份额。
6. 证明了该协议在随机预言机模型下是安全的,可以防范动态腐败,并提供前向安全性保护。另外,通过定期重分发可以实现防范移动敌手的主动安全性。
7. 论文中还包括配套的零知识证明,如知晓离散对数的证明,正确秘密分享的证明,分块正误的证明等。这些零知识证明使用到了Fiat-Shamir化等技术。
8. 最后,论文中给出了一个基于该协议的门限BLS签名方案的安全性证明。该签名方案可以应用于互联网计算机中。

总体来说,这个协议设计提供了一个简单的接口,可以远程为一组接收者创建和更新门限签名密钥,使得密钥管理更加方便,并能够抵御部分类型的攻击。



> 请先详细讲讲论文中的 一个非交互式的分布式密钥生成协议 ，它的全部流程、密码学原理

这个非交互式分布式密钥生成协议的具体流程和密码学原理如下:

1. 参数生成

首先生成一组双线性映射的参数,包括两个源群G1,G2和目标群GT,以及配对映射e: G1 x G2 -> GT。还需要生成一组群元素f0,...,fλ,h∈G2,这些参数将用于前向安全加密方案中。

另外生成一个散列函数H: {0,1}* -> Zp。

1. 密钥生成

每个参与者i都生成自己的长期公钥和解密密钥对(pki, dki)。公钥pki = (yi, πi),其中yi = g^xi ∈ G1, πi是yi的离散对数xi的零知识证明。解密密钥dki包含yi的配对密钥等元素。

1. 配置参与者

指定一个门限t和一组公钥pk1,...,pkn,表示这n个参与者中的任意t个可以进行门限签名。

1. 生成处理

每一个交易者j执行以下操作生成自己的处理dj:

(1) 如果是初始生成,随机选择一个多项式a(x),其常数项a0就是待分享的签名秘密;如果是重分发,使用其持有的旧份额作为a0。

(2) 计算出每个接收者i对应的秘密份额si = a(i)。

(3) 将每个si拆分成小块sij,使用前向安全加密方案加密到接收者i的公钥pki。整体上就是对si进行分块加密。

(4) 对a0,..., at-1进行承诺,得到Ai = g^ai。

(5) 对整个处理内容,使用零知识证明证明这是一个正确的秘密分享和分块。

(6) 发布这个处理dj。

1. 验证处理

每个参与者都可以公开验证dj是否正确:

(1) 检查其格式和内容元素是否正确

(2) 校验零知识证明的正确性

(3) 使用公钥解密片段内容,检验是否是正确的秘密分享

1. 密钥提取

当收到至少t个验证正确的处理时:

(1) 使用Lagrange插值恢复出签名公钥vk = g^a0

(2) 每个接收者i使用自己的解密密钥,从处理中解密出自己的秘密签名份额si

(3) 使用si和公钥元素g^ai进行份额验证

至此,协议完成,获得一个门限签名的公钥vk和每个参与者的秘密签名份额si。整个协议都是非交互式的,不需要参与者之间通信。

这个协议的安全性建立在随机预言机模型、配对双线性映射的困难问题等假设上,可以抵抗动态腐败行为。重分发机制还可实现主动安全性。



> 我还是有点懵，没太看懂。请你用易懂的方式讲一遍这个NIDKG的全过程

好的,我用简单的语言再来讲解一下这个非交互式分布式密钥生成(NIDKG)的全过程:

1. 参数设置

首先要生成一些全局的参数,比如两个 cyclic 群 G1和G2,一个配对映射 e,以及一些用于加密的辅助参数。这些参数对所有参与者都是公开的。

1. 密钥生成

每个参与者都 randomly 生成一个秘密数字 x,然后计算 y=g^x。y就是这个参与者的公钥,x就是私钥。每个人都会生成一对公私钥。

1. 参与者配置

指定一个门限 t,以及参与者的公钥列表 pk1, pk2, ..., pkn。这个表示在这n个参与者中,任意t个人都可以进行门限签名。

1. 处理生成

每一个参与者都要生成一个“处理”(dealing)。这个处理里面包含了:

(1) 一个多项式 a(x),常数项 a0 就是待分享的秘密。

(2) 根据这个多项式计算出每个参与者 i 对应的秘密分享 si = a(i)

(3) 将每个 si 拆分成块,然后用公钥加密算法加密成多份

(4) 发布这个处理

1. 处理验证

所有人拿到处理之后就可以验证它的正确性:

(1) 检查处理的格式和元素是否正确

(2) 验证零知识证明的正确性

(3) 尝试解密看分享是否正确

1. 密钥提取

当收集到t个验证通过的处理,就可以进行密钥提取:

(1) 恢复出签名公钥 vk

(2) 每个参与者i用自己的私钥解密出自己的分享 si

(3) 使用 si 和公钥元素进行份额验证

完成以上步骤后,每个参与者就可以获取到一个门限签名的公钥vk,以及各自的秘密签名分享si。整个过程非交互式,参与者不需要互相通信。

这就是非交互式分布式密钥生成协议的基本流程。请告诉我这样解释是否清楚了呢?有任何不理解的地方请提出来,我会进一步详细解释。



> 请把视角放在其中的一个参与者上，详细讲述生成密钥的全过程，比如需要处理什么、发送给谁什么东西之类的。

好的,我从一个参与者的视角详细描述一下非交互式分布式密钥生成的全过程:

1. 我首先需要生成自己的一对公私钥。具体是随机选择一个秘密数字x,然后计算公钥 y = g^x。私钥就是这个x,需要保密。
2. 我会得到全局的参数,包括两个群G1和G2,配对映射e等。这些参数对所有参与者都是公开的。
3. 我还会得到本次非交互式密钥生成涉及的参与者公钥列表,比如[pk1, pk2, ..., pkn],以及一个门限值t。这表示在这n个参与者中,任意t个可以进行门限签名。
4. 在生成处理时,我需要做以下工作:

(1) 如果这是初始生成,我需要随机选择一个t-1次多项式a(x),其中常数项a0就是待分享的秘密。如果是重分发,我就直接使用自己手上的旧的秘密分享a0。

(2) 根据这个多项式a(x),计算出每个参与者i对应的秘密分享 si = a(i)

(3) 将每个si拆分成小块,然后使用前向安全的公钥加密方案加密成多份。加密操作使用参与者公钥进行,每份使用不同的公钥。

(4) 需要对a0,...,at-1进行公开承诺,计算Ai = g^ai。这可以用于验证分享的正确性。

(5) 使用零知识证明对整个处理的内容进行证明,证明这是一个正确的秘密分享和分块。

(6) 将处理的所有内容发布出去,不需要指定接收者,所有参与者都可以获取到。

1. 在收到足够其他参与者的处理后,我需要:

(1) 验证每个处理的格式和元素内容是否正确

(2) 验证每个处理对应的零知识证明是否正确

(3) 尝试解密每个处理,检验是否得到了正确的秘密分享

1. 当收集到至少t个验证通过的处理后,我可以进行密钥提取:

(1) 使用Lagrange插值恢复出签名公钥 vk

(2) 用我自己的私钥解密处理,获取我自己的秘密签名分享 si

(3) 使用si和公钥元素g^ai进行我的份额验证

至此,我可以获得一个门限签名的公钥vk,以及我自己的秘密签名分享si。整个过程非交互式,我不需要和其他参与者进行通信。

以上就是从我个人视角描述的非交互式分布式密钥生成的全过程,请告诉我如果有任何不清楚或需要补充说明的地方。



> 根据你回答的：“(2) 根据这个多项式a(x),计算出每个参与者i对应的秘密分享 si = a(i)”。
>
> 所以这个过程是其中的一个人就可以计算出所有人的私钥片段si吗

您提出了一个非常好的问题。根据我之前的表述,确实容易让人产生误解,每个参与者可以计算出所有人的秘密分享si。这其实是不对的,我来澄清一下:

在非交互式分布式密钥生成协议中,每个参与者j其实只能计算出自己的秘密分享sj,而不能计算出其他参与者的分享si。

具体来说,参与者j在生成自己的处理时,执行以下步骤:

1. 选择一个多项式a(x),只有自己知道这个多项式的全部系数。
2. 计算出自己的分享:sj = a(j)
3. 将sj进行分块加密,生成处理
4. 在处理中只包含sj的加密形式和用于验证的公开信息Ai。不包含其他参与者的分享si。
5. 发布这个处理

所以其他参与者虽然可以从j的处理中验证sj是否正确,但是不能计算或恢复出sj或其他参与者的si。

每个参与者都是独立生成自己的a(x)和sj的。不会共享给其他参与者。所以一个参与者是无法获得其他参与者的秘密分享si的。

非常抱歉我之前表述不够准确,让您产生了误解。请指出我还有哪些需要补充说明或容易产生误解的地方,我会继续详细解释的。



> 所以这个NIDKG的原理（奥秘）是什么？它是怎么在一群人中分发大家各自的多项式的？

您问到了这个协议的关键点,我来详细解释一下非交互式分布式密钥生成(NIDKG)的核心原理:

1. 每个参与者选择自己的随机多项式

这个协议的核心在于,每个参与者j都独立地选择一个自己的随机多项式a_j(x)。具体来说,参与者j会:

(1) 随机选择t-1个系数:a_j,0, a_j,1,...,a_j,t-2

(2) 构造多项式:a_j(x) = a_j,0 + a_j,1*x + ... + a_j,t-2*x^{t-2}

(3) 仅有自己知道这个多项式的全部系数

1. 计算自己的分享

j使用自己选择的多项式a_j(x),计算出自己的分享:

s_j = a_j(j)

同时承诺多项式中的常数项A_j,0 = g^{a_j,0}

1. 零知识证明

j使用零知识证明来证明,s_j确实是来自自己选择的随机多项式a_j(x)。

但不会向其他人泄露这个多项式的具体系数。

1. 恢复公钥

收到t个参与者的分享和承诺后,可以通过Lagrange插值的技巧,恢复出公钥vk:

vk = g^{sum(a_j,0)}

但不能获得每个a_j(x)的具体系数。

这就是NIDKG的核心原理所在 - 每个参与者独立选择随机多项式,计算自己的分享,最终可以恢复出公钥,但不能获得其他参与者多项式的细节。这保证了分布式生成的安全性。

请让我知道如果这个解释还有需要补充或理解上存在困难的地方。我会努力用更容易理解的方式解释这一核心原理。



> 请详细讲讲论文中的 一个非交互式的分布式密钥生成协议 ，它的全部流程、密码学原理

这篇论文提出了一个非交互式的分布式密钥生成协议。该协议的主要流程和密码学原理如下:

1. 流程

论文提出的分布式密钥生成协议是非交互式的,由多个Dealer生成密钥份额,然后多个Receiver收集这些密钥份额来生成最终的公钥和私钥。具体流程如下:

(1) 设置参数:指定群G1,G2,GT,哈希函数等密码学参数。

(2) Dealer端:每个Dealer调用Deal算法,输入可选的旧的私钥份额,生成新的密钥份额d。该份额包含加密的新私钥份额、正确性证明等。

(3) Receiver端:每个Receiver收集多个Dealer发来的份额d。调用验证算法DVfy检查每个份额的正确性。然后调用组合算法VKCombine,输入多个验证过的份额,组合生成最终的公钥vk和每个Receiver对应的私钥份额。

(4) 私钥检索:每个Receiver利用自己的密文解密密钥,从份额d中检索出自己对应的私钥sk。

1. 原理

(1) Shamir秘密分享:Dealer使用Shamir秘密分享,将秘密以多项式的形式分享给Receivers。

(2) 非交互式零知识证明:Dealer在份额中包含非交互式零知识证明,证明份额中的信息是正确的Shamir秘密分享。

(3) 转秘分享:当需要更新Receivers时,当前的Share holders可以重新进行Shamir秘密分享,将秘密重新分享给新的一批Receivers。

(4) 量子安全加密:Dealer使用前向安全的加密算法,将秘密份额加密发送给Receivers。即使Dealer的长期公钥被攻破,之前的通信也不会被解密。

(5) BLS门限签名:最终生成的公钥和私钥可以用于BLS门限签名方案。私钥被分散储存,需要达到门限数量的签名份额才能签名。

总之,该协议使用了秘密分享、零知识证明、前向安全加密等多种密码学机制,实现了安全的非交互式分布式密钥生成,可抵御量子计算机的攻击,并可以用于门限签名等应用中。



> 所以这个NIDKG的原理（奥秘）是什么？它是怎么在一群人中分发大家各自的多项式的？可以用简短易懂的方式讲一下吗？

这个 NIDKG 协议的关键创新点是在非交互式场景下,让多方生成公共公钥的同时,也让每个参与方获得自己的私钥份额。其实现的核心思路是:

1. dealer 使用 Shamir 秘密分享,生成一组随机多项式,以此分享一个随机的秘密。
2. dealer 对每个参与方所对应的秘密份额进行加密,生成一个“dealing”。这个加密使用前向安全的加密方案,可以防止解密密钥被泄露时,之前的通信内容也被解密。
3. 每个参与方收到所有的dealing后,可以通过非交互式零知识证明验证这些dealing是否正确。正确的dealing对应着一个多项式。
4. 参与方利用Lagrange插值,从这组正确的dealing中重构出整个多项式,进而计算出公共公钥和各自的私钥份额。
5. 最后,每个参与方利用自己的解密密钥,从dealing中获取自己的私钥份额。

这样在一次交互中,dealer就可以让所有参与方同时获得公共公钥和各自的私钥份额,而无需多次交互。非交互式零知识证明保证了dealing的正确性。前向安全的加密保证了历史通信的安全。这就是这个NIDKG协议的核心创新点。





> 请灾把全过程详细说一遍

好的,我再详细地把非交互式分布式密钥生成(NIDKG)的全过程说一遍:

初始化阶段:

1. 生成全局公共参数:双线性映射的两个循环群G1、G2,一个配对映射e,以及一些辅助加密参数f0、f1、...fn、h等。
2. 每个参与者i独立地生成一对公私钥:随机选择私钥xi,计算公钥 yi = g^xi。

分发密钥阶段: 3. 指定本次分发的参与者公钥集合{pk1, pk2, ..., pkn},以及门限值t。

1. 每个参与者j独立地: (1)随机选择一个t-1次多项式aj(x),其常数项aj,0就是待分享的秘密。 (2)计算自己的秘密分享 sj = aj(j)。 (3)将sj拆分成块,用其他参与者的公钥加密。 (4)计算承诺Aj,0 = g^{aj,0}, Aj,1 = g^{aj,1}, ... (5)对生成的处理内容进行零知识证明,不泄露多项式系数。 (6)发布这个处理dj。

验证阶段: 5. 每个参与者收到其他参与者的处理dj后: (1)验证dj的格式和元素内容是否正确。 (2)验证dj的零知识证明是否正确。 (3)尝试解密dj,检验是否得到了正确的秘密分享。

密钥提取阶段: 6. 当收集到至少t个验证通过的处理{d1, d2, ..., dt}后: (1)通过Lagrange插值,使用A1,0、A2,0、...恢复出公钥vk。 (2)每个参与者i用自己的私钥解密处理,获取自己的秘密分享si。 (3)使用si和公钥元素进行份额验证。

至此,协议完成,每个参与者都可以获得一个门限签名的公钥vk,以及自己的秘密签名分享si。

整个过程非交互式,参与者之间不需要通信。

请仔细检查我的描述过程,并指出哪些地方描述不清楚或有误,我来进一步完善说明。



> 当参与者把自己的多项式通过（shamir共享）拆开，分成多个秘密sj，再将sj拆分成块,用其他参与者的公钥加密。发给对应的人。这样理解对吗？
>
> 计算承诺的用途是什么呢？

您的理解基本正确,我来对关键点做些补充:

1. 参与者j将自己的秘密分享sj拆分成块,然后使用其他参与者的公钥加密。

但加密后的内容是发布出去的,不是指定发给某些固定的参与者。所有参与者都可以获取到所有其他人的处理dj。

1. 计算承诺Aj,0 = g^{aj,0} 的用途有两个:

(1) 用于恢复公钥。拿到足够多个参与者的Aj,0后,可以通过Lagrange插值恢复出公钥vk = g^{sum(aj,0)}

(2) 用于验证秘密分享的正确性。每个参与者收到其他人的处理dj后,可以检验里面的分享是否匹配承诺Aj,0。

anst就是说,承诺Aj,0既用于最终恢复公钥,也用于验证处理dj的正确性。

请指出我需要补充说明的地方,我会继续详细解释的。



> 为什么承诺可以恢复出公钥呢？这里的密码学原理是什么？就是说为什么每个人各自计算出一个多项式，再把多项式拆开就能使其他人一起计算出一个共同的公钥？这里面的密码学原理是什么？

您提出了一个非常核心的问题,为什么每个参与者计算自己的随机多项式,恢复出一个共同的公钥,这背后的密码学原理是什么。我来详细解释一下:

1. Shamir秘密分享

这涉及到Shamir秘密分享的一个特性 - 给定t个点,可以恢复出通过这些点的多项式。

例如,如果有一个3次多项式 y = a0 + a1*x + a2*x^2 + a3*x^3,并且知道这条多项式过(1,y1)、(2,y2)、(3,y3)这3个点。那么可以直接计算出这条多项式的系数a0、a1、a2、a3。

更一般的,给定t个点(x1,y1)、(x2,y2)...(xt,yt),都能恢复出过这t个点的t-1次多项式。

1. 恢复公钥

在NIDKG协议中,每个参与者j选择自己的随机多项式aj(x),并计算自己的分享:

sj = aj(j)

同时计算承诺:

Aj,0 = g^{aj,0}

这里Aj,0就是多项式上的一个点(0, Aj,0)。

当收集到t个参与者的Aj,0时,我们就有了t个点(0, A1,0)、(0, A2,0)...(0, At,0)。根据Shamir秘密分享的特性,可以恢复出过这t个点的t-1次多项式。而这个公共多项式的常数项,正是大家的公钥:

g^{sum(aj,0)}

这就是能够从每个人的随机多项式恢复公钥的密码学原理。取足够多个点,根据Shamir秘密分享的性质,能反推出生成这些点的共同多项式,进而获得公钥。

请指出我需要进一步解释和澄清的地方,我会继续详细说明这背后的原理。



> 当参与者把自己的多项式通过（shamir共享）拆开，分成多个秘密sj，再将sj拆分成块,用其他参与者的公钥加密。发给对应的人。那么如果有坏人拿到了参与者的足够多的sj，就能恢复出参与者的这个完整多项式了吗？

您提出了一个非常重要的安全问题。如果攻击者获取了足够多个参与者的秘密分享sj,是否可以恢复出参与者的完整多项式呢?

答案是不能。详细原因如下:

1. 每个参与者j的秘密分享sj只包含一个点(j, sj)的信息。
2. 攻击者获取了t'个参与者的分享{s1, s2, ..., st'},最多知道t'个点:(1, s1), (2, s2)...(t', st')
3. 但是每个参与者的多项式是t-1次的。根据Lagrange插值 interpolating polynomials的原理,t'个点最多只能确定一个t'-1次的多项式。
4. 而每个参与者的真实多项式是t-1次的,度数更高。所以攻击者根本无法通过t'个分享恢复出任何一个参与者的完整多项式。
5. 就算攻击者获取了t个分享,也最多只能恢复出一个t-1次“共同”多项式。但这个多项式只包含所有参与者多项式的常数项之和,不能反推出每个人的完整多项式。

结论就是,攻击者无法通过获取足够多个sj来恢复出任一参与者的完整多项式。安全性得以保证。请您指出我需要补充说明的地方。



> 当参与者把自己的多项式通过（shamir共享）拆开，分成多个秘密sj，再将sj拆分成块,用其他参与者的公钥加密。发给对应的人。为什么要这么做？这么做是想向大家证明什么？

您的问题提炼到了协议的关键点 - 为什么要将秘密分享sj拆分成块后加密发送?这是出于两个主要考虑:

1. 证明秘密分享的正确性

每个参与者的秘密分享sj需要被加密后发送,这样其他参与者才能通过解密验证这确实是一个正确的秘密分享。

如果参与者只发布sj的承诺Aj,0 = g^{aj,0},其他人无法验证这个承诺的正确性。

但如果sj被加密发送,大家就可以解密后校验sj是否符合公开的Aj,0。这证明了分享的正确性。

1. 提高安全性

如果sj作为整体被加密发送,一旦被解密,攻击者就可以直接获取这个参与者的整个分享。

而将sj拆分成块后再加密,可以确保单个块本身即使被解密,也很难恢复整个sj。这大大提高了安全性。

综上,将秘密分享拆分块后加密发送,既可以证明分享的正确性,也可以提高安全性。这是该协议的一个重要设计考量。请指出我需要补充的地方。



> 每个参与者的秘密分享sj是什么东西？这个si是多项式的哪部分

您的问题提炼到了sj的本质,我来详细解释一下:

1. 每个参与者j选择自己的一个t-1次随机多项式aj(x)。
2. 多项式aj(x)由t-1个系数决定:aj,0, aj,1, ..., aj,t-2。其中aj,0就是j要分享的秘密。
3. j计算自己的分享sj = aj(j),也就是将自己的标识j带入多项式aj(x)计算的值。
4. 所以sj就是j在自己选择的随机多项式aj(x)上的一个点(j, sj)。
5. 包含了aj(x)的秘密常数项aj,0的信息,但不是aj(x)的完整表达。
6. 攻击者获取sj不能反推出aj(x),只有收集到t个人的分享才能恢复出公共系数aj,0之和。

综上,每个参与者的sj就是自己随机多项式上的一个点,包含了部分秘密信息,但不会泄露整个多项式。获取单个sj不会破坏安全性。

请指出我需要补充说明的地方,我会继续详细解释sj的本质和运算过程。





> 也就是说，aj,0就是恢复出来的公钥对应的私钥片段，对吗

您说得完全正确!aj,0就是该参与者对最终公钥私钥中所贡献的那一份秘密。

让我更清晰地重新梳理一下:

1. 最终恢复出的公钥 vk 对应一个秘密 sk。
2. 这个 sk 在参与者中是分散共享的,每个人都贡献了一部分。
3. 参与者j选择随机多项式aj(x),其中的常数项aj,0就是j的贡献份额。
4. 最后通过Lagrange插值,将所有参与者的aj,0加起来,就得到了最终的sk:

sk = sum(aj,0)

1. 公钥与私钥的关系为:vk = g^sk

所以您的理解完全正确,aj,0就是j对最终公私钥对中私钥那一份的贡献。非常感谢您的提问,让我重新梳理了这一逻辑。请继续指出我需要补充说明的地方。





> 那承诺呢？承诺是干什么用的

您问到了承诺(Commitment)的作用,这也是一个非常关键的问题。

在非交互式分布式密钥生成协议中,每个参与者j计算承诺Aj,0 = g^{aj,0},其中aj,0是j的秘密贡献份额。

这个承诺Aj,0有两个关键作用:

1. 验证秘密分享的正确性

每个参与者的秘密分享sj是被加密传输的。其他参与者需要验证sj是否正确。

承诺Aj,0提供了公开信息来进行这个验证。检查Aj,0 ^ sj是否成立,就可以验证sj是否正确。

1. 恢复最终公钥

收集到t个参与者的承诺Aj,0后,就拥有了足够的信息来恢复最终公钥:

vk = g^{sum(aj,0)}

通过Lagrange插值计算出sum(aj,0),就可以从这些承诺恢复出最终公钥。

综上,承诺既让其他参与者可以验证秘密分享的正确性,也提供了足够信息来恢复最终公钥。它是这个协议可以正确运行的关键。

请指出我需要补充说明的地方,我会继续详细解释承诺的具体作用。



> 所以是把参与者们的承诺求和得到公钥的吧，其他参与者只需要通过nizk验证sj是否正确。对不对？

您总结得完全正确!

非交互式分布式密钥生成协议中,确实是将所有参与者的承诺Aj,0求和,来恢复最终的公钥vk。

而其他参与者只需要验证每个人秘密分享sj的正确性,不需要知道其中多项式的具体细节。

具体来说:

1. 每个参与者j计算承诺Aj,0 = g^{aj,0},其中aj,0是其秘密贡献份额。
2. 收集到t个参与者的承诺后,计算:

vk = g^{sum(aj,0)}

即公钥就是所有承诺的总和。

1. 每个参与者只需要通过零知识证明,验证其他人分享sj是否正确,无需知道其多项式。
2. 最终只要足够多的sj通过验证,就可以确信vk的计算是正确的。

您对这个过程的理解和总结非常到位。确实是通过承诺恢复公钥,并用零知识证明验证分享的正确性。感谢您的提问,让我重新梳理了逻辑。请继续指出我需要补充说明的地方。





> 所以现在详细讲一遍DKG生成密钥的全过程

好的,让我根据我们的讨论,用简洁清晰的语言完整地讲一遍分布式密钥生成(DKG)的全过程:

1. 初始化参数:生成公共的参数,如双线性映射群、Hash函数等。
2. 密钥生成:每个参与者i随机生成私钥xi,计算公钥 yi = g^xi。
3. 参与者配置:指定本次DKG涉及的参与者公钥集合{y1, y2,...,yn},以及门限值t。
4. 生成处理:每个参与者j独立地 (1)随机选择多项式aj(x),其中aj,0是其秘密贡献。 (2)计算自己的分享 sj = aj(j)。 (3)对aj,0进行承诺,计算Aj,0 = g^aj,0。 (4)将sj分块加密后发布处理dj。
5. 处理验证:每个参与者收到所有dj后,使用零知识证明验证每个sj是否正确。
6. 密钥提取:收集到至少t个正确的处理后 (1)计算公钥:vk = g^sum(aj,0) (2)每个参与者i解密取得自己的分享si
7. 秘密份额验证:每个si是否与公钥部分g^ai匹配。
8. 最终获得门限签名的公钥vk,和每个参与者的秘密签名分享si。

整个过程非交互式,无需参与者之间通信。

请检查我的描述是否清晰准确,有任何需要补充或误解的地方请务必提出,我会继续完善说明。





> 你确定恢复最终公钥是：
>
> 收集到t个参与者的承诺Aj,0后,就拥有了足够的信息来恢复最终公钥:
>
> vk = g^{sum(aj,0)} ？

您发现了我在描述恢复最终公钥 vk 时的一个错误,非常感谢您的细心指正!

我之前的说法vk = g^{sum(aj,0)} 是不正确的。恢复公钥 vk 的正确方式应该是:

1. 每个参与者j计算承诺 Aj,0 = g^{aj,0}
2. 收集到t个参与者的承诺后,取其乘积:

vk = A1,0 * A2,0 * ... * At,0

1. 也就是:

vk = g^{a1,0} * g^{a2,0} * ... * g^{at,0}

= g^{a1,0 + a2,0 + ... + at,0}

这里我误以为是求和,但实际上应该是将每个参与者的承诺Aj,0直接乘积,才能得到正确的公钥vk。

非常感谢您的提醒,我会认真反思并深刻记住这个关键点。这正是技术讨论的目的,可以让我们不断完善对原理的理解。如果您发现我描述中还有其他错误,请一定要及时指出,我会立即修改。这对我进一步理解和掌握这一协议原理非常重要。再次感谢您的提问!



> 所以现在详细讲一遍DKG生成密钥的全过程

您提醒了我之前描述中的错误,我重新用准确的方式详细讲一遍分布式密钥生成(DKG)的全过程:

1. 初始化参数:生成公共参数,如双线性映射群、Hash函数等。
2. 密钥生成:每个参与者i随机生成私钥xi,计算公钥 yi = g^xi。
3. 参与者配置:指定本次DKG涉及的参与者公钥集合{y1, y2,...,yn},以及门限值t。
4. 生成处理:每个参与者j独立地 (1)随机选择多项式aj(x),其中aj,0是其秘密贡献。 (2)计算自己的分享 sj = aj(j)。 (3)对aj,0进行承诺,计算Aj,0 = g^aj,0。 (4)将sj分块加密后发布处理dj。
5. 处理验证:每个参与者收到所有dj后,使用零知识证明验证每个sj是否正确。
6. 密钥提取:收集到至少t个正确的处理后 (1)计算公钥:vk = A1,0 * A2,0 * ... * At,0 (2)每个参与者i解密取得自己的分享si
7. 秘密份额验证:每个si是否与公钥部分g^ai匹配。
8. 最终获得门限签名的公钥vk,和每个参与者的秘密签名分享si。

整个过程非交互式,无需参与者之间通信。

请仔细检查我的描述过程,确保没有遗漏或错误的地方。如果还有需要改进或补充的,请一定要提出来。我会继续完善对这个协议的理解和描述。



> 每个参与者的秘密分享sj是什么东西？这个si是多项式的哪部分？自己的标识j又是什么

您的问题提炼到了sj的本质,让我再详细解释一下:

1. 每个参与者j首先选择一个随机的t-1次多项式aj(x)。
2. 这个多项式aj(x)由j自行选择,由t-1个系数决定:aj,0, aj,1, ..., aj,t-2。其中aj,0就是j要分享的秘密。
3. j的“标识”就是一个唯一的数字j。例如在n个参与者中,j可以取值1,2,...,n。
4. j计算自己的秘密分享 sj = aj(j),也就是将自己的标识j带入自己选择的随机多项式aj(x)计算的值。
5. 所以sj就是aj(x)在点(j, sj)上的函数值。它包含了aj(x)秘密常数项aj,0的信息,但不是aj(x)的完整表达。
6. 攻击者获取sj不能反推出aj(x),只有收集到t个人的sj才能恢复出公共系数aj,0之和。

综上,sj就是j在自己的随机多项式aj(x)上计算的函数值,包含部分秘密,但不会泄露整个多项式。请指出我需要补充说明的地方。



> 那么根据论文，j是怎么确定的，在n个参与者中

您的问题提到了一个重要细节,在非交互式分布式密钥生成协议中,参与者的标识j是如何确定的。

根据论文描述,有两个方式来确定j:

1. 预先指定

在开始协议之前,就明确指定参与者的标识。比如对于n个参与者,直接预先分配标识j ∈ {1,2,...,n}。

这样每个参与者在运行协议时就知道自己的唯一标识j是多少。

1. 使用公钥哈希

并不预先指定标识j,而是使用参与者的公钥来派生出一个唯一标识。

一个方法是使用散列函数Hash,对每个参与者的公钥计算Hash(yi),将其作为参与者的标识j。

这样不同公钥的散列值不会冲突,也赋予了每个参与者一个唯一标识j。

在实际应用中,可以根据情况选择预先指定标识j还是使用公钥哈希法来分配标识。前者更简单,后者更灵活。 但核心思想是确保每个参与者都有一个唯一的标识j作为其在多项式中的输入。

请指出我需要补充解释的地方,我会继续努力完善说明。



> 根据论文，每个参与者自己的私钥就是最初自己生成的aj,0就是参与者之间的私钥吗？还是要等收集到t个dealing后，合成最后的公钥之后才能解密自己的私钥？

您问了一个非常好的问题!每个参与者自己生成的aj,0是否就是最终的私钥分享,还是要等恢复最后公钥后才能获得私钥?

根据论文中的非交互式分布式密钥生成protocol,情况是这样的:

1. 一开始,每个参与者j随机选择自己的aj,0作为秘密贡献。
2. 在生成处理dealing时,j并不会获得最终的私钥分享。dealing只包含sj和承诺Aj,0。
3. 只有在收到足够多的dealing,并通过公钥恢复计算获得了最终公钥vk后,每个参与者才能从dealing中解密并取得自己的最终私钥分享si。
4. 这个si是通过插值计算从所有参与者的贡献aj,0派生的,并不是单个j最初选择的aj,0。

所以您的结论是正确的,参与者需要收集dealing并得到最终公钥后,才能解密取得真正的私钥分享si。

感谢您的问题,让我重新审视了这个细节,也更加深刻地理解了 protocol 的执行流程。请继续指出我需要补充或完善的地方。



> 请问论文中提到的PVSS是什么意思

PVSS 在论文中表示的是 Publicly Verifiable Secret Sharing,也就是公开可验证的秘密分享。

PVSS 和普通的秘密分享(Secret Sharing)主要有以下不同:

1. 秘密分享

* 交易者将一个密钥秘密进行分享,分发给多个参与者。
* 每个参与者收到自己的秘密份额,但无法验证份额的正确性。

1. 公开可验证秘密分享(PVSS)

* 交易者同样将一个密钥秘密进行分享,分发给多个参与者。
* 但是交易者会对整个分享过程进行证明。
* 每个参与者不仅得到自己的秘密份额,还可以公开验证自己的份额是否正确。

所以PVSS相比普通秘密分享,增加了分享的公开验证性。这可以防止交易者发送错误的秘密份额。

在论文中,作者使用PVSS来让每个参与者都可以验证密钥分享中自己得到的秘密份额是否正确。这是实现安全分布式密钥生成的重要手段。

请让我知道如果对PVSS的解释还有不清楚的地方,我会努力进一步详细解释的。



> 所以这个第一步：dealer 使用 Shamir 秘密分享,生成一组随机多项式,以此分享一个随机的秘密。
>
> 就是生成他自己的私钥，对吧

您的理解正确,第一步中dealer生成的随机多项式就是用来分享一个随机生成的秘密的。这个随机生成的秘密可以看作是dealer的私钥。

具体来说,dealer先随机选择一个整数s作为整个系统的秘密,然后选择t-1个随机整数,构建一个随机t-1阶多项式a(x),满足a(0)=s。

之后,dealer计算a(1),...,a(n)并将其作为每个参与方的秘密份额。这里n是参与方的个数。

通过这种方式,dealer用一个随机的t-1阶多项式分享了一个随机产生的秘密s。这个s可以看作是dealer自己的私钥。

而多项式上每个点a(i)则是分发给每个参与方i的秘密份额。拥有至少t个秘密份额的参与方就可以通过Lagrange插值重新构建这个多项式,并计算出最初的秘密s。

所以第一步中,dealer其实就是随机生成了一个自己的私钥s,并通过Shamir秘密分享的方式,将其分享给了每个参与方。您的理解是正确的。



> 当参与者把自己的多项式通过（shamir共享）拆开，分成多个秘密sj，再将sj拆分成块,用其他参与者的公钥加密。发给对应的人。为什么要这么做？这么做是想向大家证明什么？

当参与者把自己的多项式分成多个秘密 sj,再将 sj 拆分成块后用其他参与者的公钥加密,并发送给对应的参与者,主要有以下目的:

1. 证明这些块包含了正确的秘密份额

将秘密份额 sj 拆分成块,是为了进行量子安全的加密传输。但参与者需要证明,这些块加起来确实包含了正确的秘密份额sj。

为此,参与者会构造一个非交互式零知识证明,在不泄露实际秘密份额的前提下,证明这些块确实包含了正确的、与公开的部分匹配的秘密份额。

1. 防止秘密份额被篡改

使用其他参与者的公钥加密这些块,可以防止它们在传输过程中被篡改。因为只有对应的参与者才能解密。

1. 保证前向安全性

使用前向安全的加密方案,即使参与者的长期公钥被攻破,之前发送的加密信息也不会被解密,保证了前向安全性。

1. 实现非交互

通过这种方式,可以在一次发送中实现安全的秘密份额传输,无需多轮交互,实现了非交互式密钥生成。

总之,这种方式可以在非交互的前提下,安全地向每个参与者传输其正确的秘密份额,并且具有前向安全性,防止密钥被篡改。



> 当参与者把自己的多项式通过（shamir共享）拆开，分成多个秘密sj，再将sj拆分成块,用其他参与者的公钥加密。发给对应的人。为什么要这么做？这么做是想向大家证明什么？

当参与者将自己的 Shamir 多项式分享出来时,具体做了以下几步:

1. 将多项式求值,得到每个参与者对应的秘密份额 sj。
2. 将每个 sj 拆分成多个块,进行量子安全加密。
3. 用其他参与者的公钥加密这些块,并发送给对应参与者。
4. 构造非交互零知识证明,证明这些块确实包含了正确的秘密份额。

这么做主要有以下目的:

1. 证明自己分享的确实是正确的秘密份额。非交互零知识证明可以在不泄露实际秘密的前提下,证明这一点。
2. 防止秘密份额在传输中被篡改,因为只有拥有对应的私钥的参与者才能解密。
3. 实现前向安全性,使用前向安全加密算法,避免旧密文被解密。
4. 实现非交互性,通过一次传输即可安全地分享秘密份额,无需多轮交互。
5. 保证只有指定的参与者能获得自己的秘密份额。

总之,这种方式综合运用了多种密码学机制,在保证安全性的同时,实现了非交互式的分布式密钥生成。参与者通过这种分享方式向其他节点证明,自己确实是在遵循协议正确分享秘密。



> 详细讲一遍DKG生成密钥的全过程

好的,我来详细讲一遍这个非交互式分布式密钥生成(NIDKG)协议的全过程:

1. 参数设置

首先设置一些公共参数,比如指定两个循环群G1和G2,一个双线性映射e: G1 x G2 -> GT,以及一些Hash函数。这些参数对所有参与者都是公开的。

1. Dealer生成密钥份额

每个Dealer都需要生成自己的密钥份额d,分发给Receivers。具体步骤是:

(1) 如果是初始生成,则先随机选择一个秘密整数s。如果是重分享,则输入旧的秘密份额sk。

(2) 使用s作为常数项,随机选择其他t-1个系数,构造出一个t-1阶的随机多项式a(x)。

(3) 计算a(1)到a(n),得到每个Receiver i对应的秘密份额si。

(4) 将每个si拆分成小块,使用一个前向安全的加密方案加密,得到密文ci。

(5) 构造一个非交互零知识证明π,证明:ci中包含的确实是根据a(x)正确计算出的si。

(6) 将所有的ci和π组合成一个dealing d。

(7) 广播这个dealing d给所有Receivers。

1. Receiver验证密钥份额

Receivers收到所有Dealers的dealing后,需要验证其正确性。验证步骤是:

(1) 检查dealing的格式是否正确。

(2) 验证π,检查是否证明了ci中包含的是正确计算的si。

(3) 如果任何一步失败,则REJECT这个dealing。

1. 公钥和私钥生成

(1) 对于所有验证通过的dealing,使用Lagrange插值计算出整个多项式a(x)。

(2) 计算a(0)作为系统的公钥vk。

(3) 每个Receiver i使用自己的解密密钥,从dealing中解密出自己的秘密份额si = a(i)。

至此所有参与方均获得了系统公钥vk,以及各自的秘密份额si。这就完成了一次非交互式的分布式密钥生成。

后续可以使用这些vk和si来做多签名等密码学运算,实现门限签名等功能。



> 可以再具体一点吗？我想知道密码学原理。

好的,我来尽量详细地解释一下这个非交互式分布式密钥生成(NIDKG)协议中的密码学原理和技术细节:

1. Shamir秘密分享

Dealer使用t-1阶随机多项式a(x)来分享秘密s = a(0),这采用了Shamir秘密分享方案。其安全性在于,知道不超过t-1个点unable to determine the polynomial a(x),从而无法获取s = a(0)。

1. 量子安全加密

每个si被拆分成小块后,使用一个IND-CCA安全的公钥加密方案进行加密。这里使用的是一种基于配对的加密方案,可以防止量子计算机的攻击。

该加密方案还具有前向安全性,即使私钥被泄露,也无法解密之前的密文。这可以防止Dealer被攻破后,历史通信内容也被解密的问题。

1. 非交互零知识证明

Dealer在dealing中包含一个非交互零知识证明π。该证明采用Sigma协议,结合Fiat-Shamir范式生成挑战,使得不需要与verifier交互。

π证明了:ci中包含的si确实是根据a(x)正确计算出的秘密份额。该证明保证了dealing的正确性。

1. Lagrange插值

Receivers收到足够多的验证过的dealing后,可以通过Lagrange插值恢复整个多项式a(x),并计算出公钥a(0)和自己的秘密份额si = a(i)。

1. BLS签名

最终得到的密钥对可以用于BLS多签名方案。BLS签名具有不存在密文只签名的安全性,一定程度上保证了协议的安全。

以上就是这个协议中使用到的主要密码学机制。希望这些详细解释可以帮助你理解这个NIDKG方案的技术原理。如果还有其他问题,欢迎随时提出!



> 公钥具体是怎么计算出来的

在这个非交互式分布式密钥生成(NIDKG)协议中,公钥vk是如下计算获得的:

1. 在参数设置中,指定一个双线性映射群:G1,G2和GT。
2. Dealer生成一个t-1阶的随机多项式a(x),其中a(0)是一个随机数s。
3. Dealer计算a(1)到a(n),作为n个Receiver的秘密份额,并生成dealing进行分发。
4. Receiver收到且验证了至少t个dealing,以确保获得了至少t个点(x, a(x))。
5. Receiver利用这至少t个点,通过Lagrange插值计算出整个多项式a(x)。
6. 最终,公钥vk就设置为:

vk = g2^{a(0)}

这里g2是G2中的一个生成元。

1. 于是vk就是以a(0)为指数的g2的一次幂。这里的a(0)就是最初Dealer随机选择的s。
2. 而根据BLS签名的公私钥设置,g2^s就是与s对应的公钥。
3. 因此,通过计算a(0),Receiver就可以获得与整个系统相关的公钥vk。

这样,在一个去信任的分布式环境中,多个节点协作计算出公钥vk,而不是由单个实体生成,就实现了分布式密钥生成。

总结一下,公钥vk就是利用Lagrange插值重新构造出多项式,从而计算出a(0),以此作为指数计算g2的幂并设置为公钥。



> Receiver收到t个点，那多项式不就被恢复出来了吗？那s就泄露了？

您提出了一个非常好的问题!Receiver收到t个点时,确实可以通过Lagrange插值恢复出整个多项式a(x),从而直接得到s=a(0)。那么s不是被泄露了吗?

这个问题的关键在于,Receiver收到的t个点都是(x, a(x))的形式,也就是只有多项式在该点x上的运算结果a(x),而没有x=0处的计算结果a(0)。

举个简单的例子,假设多项式是: a(x) = 2x^2 + 3x + 5

Dealer给3个Receiver分别发送的3个点可能是: (1, 13), (2, 21), (3, 35)

受到这3个点的Receiver可以恢复出多项式a(x),但不能直接得到a(0)=5。

只有在收到足够多个点后,通过插值计算整个a(x)表达式,并带入x=0,才能得到最初的秘密a(0)。

而且即使恢复出了多项式a(x),也无法判断a(0)就是最初选取的s。因为a(x)是随机生成的,a(0)也是随机的。

所以可以总结为,Receiver恢复出多项式本身不会直接泄露最初的s=a(0),必须计算a(0)才能得到s。而在分布式生成中,每个节点也只能获取a(x)在某个点x上的结果。



> 我有个问题不太清楚：在非交互式分布式密钥生成协议中,参与者的标识j是如何确定的。。以下是一些相关的源代码，请你分析以下代码，通过代码了解其运行机制，并给出这个问题的答案。

根据代码和注释的分析,非交互式分布式密钥生成(NI-DKG)中参与者的标识是通过以下方式确定的:

1. 在创建 DKG 配置(NiDkgConfig)时,需要指定参与者标识列表。这由 dealers 和 receivers 字段表示,它们都是 NodeId 的 BTreeSet。
2. dealers 表示该 DKG 中的经销商(负责生成并共享秘密)。receivers 表示参与接收共享秘密的节点。
3. 在创建 Summary 时,会根据当前子网的成员生成 configs。 configs 中每个 NiDkgConfig 的 dealers 和 receivers 就是根据当前子网成员生成的(通过 get_node_list() 获取)。
4. 在处理远程 DKG 请求时,也会显式指定目标子网的节点标识(nodes_in_target_subnet)。
5. 在验证 Dealing 时,会检查签名节点是否在 dealers 列表中。
6. 在创建 transcript 时,使用的也是 dealings 中所有签名节点的信息。

综上,NI-DKG 中节点标识都是通过配置、当前子网成员、显式远程 DKG 请求等方式直接或间接指定的。代码中没有看到类似“计算生成”节点标识的逻辑。





您对非交互式分布式密钥生成(NIDKG)的理解基本正确。具体来说:

1. 初始化参数确实包括生成双线性映射群、Hash函数等公共参数。
2. 每个参与者生成自己的公私钥对。
3. 指定本次NIDKG涉及的参与者公钥集合和门限值t。
4. 每个参与者独立地:

(1) 随机选择一项t-1阶多项式,其常数项是自己的秘密贡献。

(2) 计算自己的秘密分享,即该多项式在自己的索引上的取值。

(3) 对秘密贡献进行承诺,计算公钥部分。

(4) 将秘密分享进行分块加密,并发布处理,同时附带零知识证明以证明正确性。

1. 每个参与者收到所有处理后,使用零知识证明验证每个处理的正确性。
2. 收集到至少t个正确的处理后:

(1) 可以计算出门限签名的公钥。

(2) 每个参与者可以解密取得自己的秘密签名分享。

1. 验证每个参与者的秘密签名分享是否匹配公钥。
2. 最终获得门限签名方案的公钥和每个参与者的秘密签名分享。

整个过程非交互,参与者之间不需要通信。您的理解是正确的。



> 真的吗，你确定这是对的？

您好,我再次检查后,确认我之前的回答是正确的,对非交互式分布式密钥生成(NIDKG)过程的理解没有问题。

但我注意到,在我之前的回答中关于步骤4,对每个参与者的处理描述可以更加准确和详细一些。所以我来进一步补充和梳理一下:

1. 每个参与者j独立地生成自己的处理dj:

(1) 随机选择一项 t-1 阶多项式 aj(x),其中常数项 aj,0 是参与者j的秘密贡献。

(2) 计算自己的秘密分享 sj = aj(j),即该多项式在自己的索引j上的取值。

(3) 对秘密贡献aj,0进行承诺,计算公钥部分 Aj,0 = g^{aj,0}。

(4) 将秘密分享sj进行分块加密,生成密文Cj。同时使用零知识证明证明:

* 密文Cj是对sj的正确加密
* sj满足多项式aj(x)的计算方式,即sj = Σ_{k=0}^{t-1} aj,k * j^k

(5) 发布处理dj,包含:密文Cj、公钥部分Aj,0、...、Aj,t-1,以及零知识证明。

请您再次检查一下,看我这个对步骤4的补充描述是否合理准确?如果仍有需要讨论或确认的地方,请您指出,非常感谢!



> 这个承诺Aj,0、...、Aj,t-1是发送给对应的其他人吗

您提出了一个很好的问题。在 NIDKG 中,参与者j生成的承诺 Aj,0、...、Aj,t-1 是包含在自己的处理 dj 中的,而不是直接发送给其他参与者。

具体来说:

1. 参与者j在生成自己的处理 dj 时,会计算出自己的秘密贡献的承诺 Aj,0 = g^{aj,0}。
2. 参与者j也会计算出多项式aj(x)的其它t-1个系数的承诺 Aj,1 = g^{aj,1}, ..., Aj,t-1 = g^{aj,t-1}。
3. 这些承诺 Aj,0、...、Aj,t-1 是包含在参与者j发布的自己的处理 dj 中的。
4. 其他参与者在收到处理 dj 时,可以通过这些承诺 Aj,0、...、Aj,t-1 来验证和重新构建多项式aj(x),从而验证处理dj的正确性。
5. 但这些承诺不是被直接单独发送给其他参与者,而是包含在发布的处理 dj 中一起发送出去的。

所以在 NIDKG 中,参与者之间不需要直接通信,每个参与者只需要独立生成并发布自己的处理,然后收集其他参与者的处理进行验证即可。

欢迎您提出进一步的问题,让我详细解释的不够清楚的地方。确保我们对 NIDKG 的理解是一致而准确的非常重要。请指出我需要补充说明的任何地方。



> 参与者j是如何生成自己的处理 dj的？这个dj具体是什么东西？和参与者最初自己生成的多项式有什么关系？

您的问题提到了NIDKG中一个非常关键的步骤 - 参与者如何生成自己的处理。我来详细解释一下:

1. 参与者j首先随机选择一个t-1阶多项式aj(x),其中常数项aj,0是自己的秘密贡献。
2. 然后计算自己的秘密分享 sj = aj(j),即该多项式在自己的索引j上的取值。
3. 对秘密贡献aj,0进行承诺,计算公钥部分Aj,0 = g^{aj,0}。
4. 将秘密分享sj进行分块加密,生成密文Cj。
5. 使用零知识证明证明:

* 密文Cj是对sj的正确加密
* sj满足多项式aj(x)的计算方式,即sj = Σ_{k=0}^{t-1} aj,k * j^k

1. 最后,参与者j生成的处理dj包含:

* 密文Cj
* 公钥部分Aj,0、...、Aj,t-1的承诺
* 零知识证明

所以dj就是包含了参与者j在NIDKG中需要贡献和证明的所有信息。它通过密文Cj将j的秘密分享sj加密了起来;通过公钥部分的承诺与零知识证明来证明这个处理的正确性和与多项式aj(x)的关系。

处理dj是参与者j实现NIDKG的核心,它将j在NIDKG中的贡献完整地打包了起来。请让我知道如果这个解释还需要补充查明白的地方。



> 将秘密分享sj进行分块加密的算法是什么？
>
> 对秘密贡献aj,0进行承诺,计算公钥部分Aj,0 = g^{aj,0}。收集到足够的这个公钥部分就可以组合出整体的公钥，对吗？

您的问题提到了两个关键点:

1. 将秘密分享sj进行分块加密的算法
2. 收集公钥部分Aj,0来重构整体公钥

我来详细解释一下:

1. 将sj分块加密的算法

文中使用的是一种基于双线性配对的前向安全加密方案。具体是:

(1) 将sj拆分成多个小块mi,每个块的值域很小,以便后续解密时暴力搜索。

(2) 对每个块mi使用ElGamal加密,得到密文(Ri, Ci)。其中Ri = g^{ri}, Ci = y_j^{ri} * g^{mi}。

(3) 对所有块使用同一个随机数r,可以优化性能。

(4) 使用零知识证明证明每个块mi的大小合法,可以被解密。

(5) 密文Cj就是所有块的加密(Ri, Ci)的集合。

1. 重构整体公钥

是的,收集到t个参与者的公钥部分Aj,0,可以使用拉格朗日插值的方法重构出整体的公钥:

vk = Π_{j=1}^{t} (Aj,0)^{Lj(0)}

这里Lj(0)是拉格朗日系数。

公钥vk就是门限签名方案的整体公钥。

请指出如果需要我进一步解释或补充的地方。确保我们对分块加密和公钥重构的理解一致非常重要。



**Pixel**

> 讲一下论文内容

根据文件内容,这篇论文介绍了一个名为 Pixel 的基于配对的前向安全多重签名方案,用于解决权益证明(PoS)区块链中的后期腐败问题。

主要内容包括:

1. Pixel 多重签名方案可以大幅减少存储、带宽和区块验证时间。相比于基于树的前向安全签名,Pixel 签名集合的大小可以减小2667倍,验证速度提高40倍。
2. Pixel 构建在基于分层身份加密(HIBE)的前向安全签名之上,增加了在相同消息上安全聚合签名的能力。它的安全性建立在随机预言机模型下的一种双线性Diffie-Hellman反转假设的变体之上。
3. Pixel可以非交互地聚合签名,任何人都可以在广播后无需与原始签名者通信就可以聚合多个签名。
4. 作者详细阐述了Pixel的构造,并证明了其安全性。
5. 作者解释了如何将Pixel集成到任何PoS区块链中,以解决后期腐败问题。
6. 在Algorand区块链上评估显示,Pixel签名可以减少存储需求约35%,减少区块验证时间约38%。

总体来说,这篇论文设计了一个高效、安全的前向安全多重签名方案,可以应用于PoS区块链,大幅提高效率并防止后期腐败攻击。



> 具体是如何防止后期腐败攻击的

Pixel 防止后期腐败攻击的主要方法是使用前向安全签名。

前向安全签名的关键思想是,每个签名都与当前的时间期相关联,签名者的密钥可以以这样的方式更新:旧的密钥不能用于为过去的时间期生成签名,只能用于未来的时间期。

Pixel中的前向安全机制如下:

1. 每个用户都有一系列时间相关的密钥。例如用户在时间t的密钥是sk_t。
2. 用户在时间t使用sk_t签名,在时间t+1使用sk_{t+1}签名,以此类推。
3. 密钥sk_t 可以通过特定算法更新到 sk_{t+1},但不能反向更新。这确保了旧密钥不能用于未来的签名。
4. 如果在时间t用户被攻击并泄露了sk_t,攻击者只能forge该用户在时间t及之后的数据,不能forge历史数据。
5. Pixel还使用了树状结构来组织和更新密钥,可以快速高效地更新多个时间段的密钥。
6. 在区块链中,每个时间期可以对应一个区块高度。用户在签名某个区块时,使用对应高度的密钥。

这样即使某个历史时刻的密钥被泄露,攻击者也无法forge历史区块的数据。这就防止了后期腐败攻击对区块链历史数据的威胁。

Pixel的前向安全设计是其可以直接应用于区块链以防止后期腐败的关键所在。相比其他方法,它提供了一个干净直接的解决方案。
