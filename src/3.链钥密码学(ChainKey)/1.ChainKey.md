https://www.youtube.com/watch?v=vUcDRFC09J0&t=1s



## 链钥密码学

（配这部分的合影图，类似于首页的第一张图，各种内容聚集到一起）

链钥密码学（Chain-key cryptography）是对嵌入 IC 底层系统密码学的统称，是 IC 运行时依赖的一套完整的密码学协议，包括了 BLS 阈值签名、非交互式密钥分发协议（NIDKG）、非交互式零知识证明（NIZK）、阈值 EDCSA 、可验证加密阈值密钥（VETKeys） 。

其中最重要的是 BLS 阈值签名。



## BLS阈值签名

先讲讲 BLS 阈值签名是什么东东？ ฅʕ•̫͡•ʔฅ 

它是链钥密码学最重要、最核心、最根本的部分。子网运行要靠 BLS 阈值签名达成共识，靠 BLS 阈值签名给用户返回消息认证，靠 BLS 阈值签名生成共识依赖的随机信标，靠 BLS 阈值签名签署追赶包等等。

举例来说的话，BLS 阈值签名就像一个 “ DAO ” ，只要是需要子网签名的地方，都要子网里足够的副本 “ 同意 ” （签名）才行。足够的副本同意，即代表达成共识，少数服从多数。



在传统的非对称加密算法中，我们可以生成一把公钥、一把私钥；公钥公开，私钥保密；公钥加密信息，私钥解密信息；私钥签名信息，公钥验证信息。还可以在[这里]()先了解了解非对称加密。

像之前[共识](../2.核心协议/2.共识层.md)讲的那样，比如子网里的某个副本打包一个区块，当大家认为区块没问题时，就会用私钥对区块留下自己的签名，表示自己的认可。

如果每个副本都生成一对公私钥，密钥管理既复杂有低效🥲。而且更重要的是：如果用户想验证链上内容，就得下载几百个 G 的数据来亲自验证😭。这太不友好了。



Dfinity 为了解决这个问题，选择了 BLS 签名的阈值方案来实现子网签名。

<img src="assets/1.ChainKey/image-20230818124536695.png" style="zoom:50%;" />



### BLS签名

先来说说为啥选择 BLS 签名吧。

它和 RSA 、DSA 这些常见的签名算法有很多不同的地方。

首先 BLS 签名的长度很短也更安全。

一个签名值只需要一个椭圆曲线点的一个坐标，大概 160 比特就够了。但 RSA 签名和 DSA 签名包含两个大整数，通常需要 320 比特才能达到同等安全级别，长度上 BLS 签名明显优势。BLS 签名的安全性不是依赖整数分解之类的数学问题，而是依赖椭圆曲线上的计算困难问题，比如 CDH 问题。这种问题目前看来更难破解。



虽然 BLS 签名的验证速度比较慢，因为需要计算一些配对运算。但是签名生成很快，只需要一个简单的点乘运算。RSA 和 DSA 恰恰相反，签名慢但是验证很快。 

BLS 签名还有一个优点就是不需要保存签名状态，只要消息内容不变，签名就是固定的。但 RSA 和 DSA 签名还需要保存随机数才能防止重放攻击。

另外，BLS 可以非常高效地同时批量验证多个签名，在很多应用场景下可以大幅提升效率。这是 RSA 和 DSA 做不到的。



这些特性让它在很多对签名长度和可扩展性要求很高的区块链应用里面非常合适。

这个算法本身非常优雅，是一种很有前景的签名算法。在[这里]()可以了解更多 BLS 签名算法的密码学原理。

当然，最重要的一点是 BLS 签名可以把私钥拆分为私钥片段，升级为多签方案或者**阈值签名**（也叫门限签名）！RSA 和 DSA 要直接做到这点就很难了。



### BLS阈值签名

把私钥拆分为私钥片段！

听起来很高大上，但其实就是一种让多个人共同参与签名的算法。把私钥分成许多份，发给不同的人保管。在签名时，必须由足够多的人（达到阈值）一起参与签名，才能把签名片段合成一个有效的签名。

<img src="assets/1.ChainKey/image-20230818123248527.png" style="zoom:45%;" />

在动画和游戏情节中，有很多必须收集多个钥匙、水晶或其它物品才能打开通往最后关卡或获得终极宝藏的大门。比如《复仇者联盟 3 ：无限战争》中，灭霸要集齐六颗无限宝石来消灭宇宙一半的生命。《哈利波特》系列中，伏地魔分裂了自己的灵魂制作了多个魂器，哈利必须找到并销毁所有的魂器才能完全消灭伏地魔。《七龙珠》里是集齐七颗龙珠可以召唤神龙实现心愿等。

<img src="assets/1.ChainKey/image-20230818135016018.jpg" style="zoom:33%;" />

这种通过收集或组合物品来产生某种神奇效果的情节在各种电影、书籍和游戏中屡见不鲜。



现实中的 BLS 阈值签名通过密码学实现了这种魔法。每个人拿着一个私钥片段生成一个签名片段，只要人们的签名片段达到阈值就能合成一个完整的签名。即使子网中有一部分（小于三分之一）副本故障了或者网络连接不上了，也能完成签名。而用来验证签名的公钥是唯一的！

虽然阈值签名方案很早之前就有了，但 IC 是第一个将这种技术整合到底层协议中的区块链。

没有完整的私钥，只有分散的私钥片段，即使是作为持有私钥片段的副本，也无法直接得到签名结果。必须要拿到足够的签名片段才能合成签名。在区块链上的操作需要多个副本共同确认，从而提高了安全性和可靠性。敌手很难控制足够多的节点来伪造签名。

<img src="assets/1.ChainKey/image-20230818153704812.png" style="zoom:37%;" />

它是唯一能产生非常简单且高效的阈值签名协议的签名方案。持有私钥片段的副本可以轻松地生成对消息的签名片段，达到阈值数量的签名片段可以组合出消息对应的完整签名。而且副本之间不需要交互，每个人只要向大家广播出签名片段就好了。而且继承自 BLS 的优良基因，签名是唯一的，对于给定的公钥和消息，只有一个有效的签名。无论哪几个私钥片段签名，只要达到凑够足够的签名片段了，最终都能生成唯一的签名。



BLS 阈值签名是 IC 的根基，有了阈值签名，子网里的副本就可以依靠 BLS 阈值签名来达成共识啦：

* 子网里足够数量的副本对新区块签了名，就能合成完整签名，也就意味着达成了共识，少数服从多数。其他副本可以拿子网公钥验证区块。

* 子网里足够数量的副本对随机信标签了名，就能合成完整签名，也就意味着新的签名就是一个新的随机数。只要每次签名的消息不一样，签名结果肯定就不一样。而且每个私钥片段其他副本可以拿子网公钥验证这个随机数。
* 子网里足够数量的副本对默克尔树根签了名，就能合成完整签名，也就意味着子网里的大部分副本的状态是一致的。用户可以拿子网公钥验证输出。



BLS 阈值签名还有一个很重要的优点：用户要确保子网发回来的消息没有被篡改，万一消息被黑客替换掉就麻烦了。

所以子网要对返回给用户的消息签名。

<img src="assets/1.ChainKey/image-20230818163340357.jpg" style="zoom:30%;" />

前面说过：如果每个副本都生成一对公私钥，密钥管理既复杂有低效🥲。因为每次出块都由不同的节点签名，如果用户想验证链上内容，就得下载几百个 G 的数据来亲自验证😭。这太不友好了。

而子网使用 BLS 阈值签名之后，就相当于一个子网只有 “ 一对公私钥 ” 。私钥有子网里的副本共同保管，而对应子网公钥只有一个！任何人都可以拿着子网公钥验证子网签名过的内容👍！

也就是说，想验证链上的数据再也不用下载几百个 G 的全部数据啦，只要用一个 48 kb 的子网公钥单独验证某个消息就好了。用户的手机、电脑甚至物联网设备都能验证子网签名过的消息。

<img src="assets/1.ChainKey/image-20230818163244831.png" style="zoom:25%;" />

同样的，在需要跨子网通信时，子网 B 也可以用子网公钥 A 验证子网 A 发来的消息。

这种跨分片验证的能力使 IC 能横向扩展，只要节点够多，就能创造出无限个分片（子网）。

<img src="assets/1.ChainKey/image-20230818175102179.png" style="zoom:37%;" />

每个子网可以看成是一个独立的 “ 小型区块链 ” ，子网之间靠子网公钥验证通信。因为已经在子网 A 内部达成共识了，所以只要通过子网公钥 A 验证子网 A 发来的消息就行了。这就极大的优化了 “ 跨分片 ”（跨子网）的通讯问题，简单高效。



等等，但是每个子网都有一个子网公钥，那以后有上万个子网怎么办？还是要管理上万把子网公钥吗？

没事😏，还有系统子网：NNS 呢。NNS 有个注册表 Canister ，会保管 IC 上的每个子网公钥。想要哪个子网的公钥找 NNS 要。

当然，为了以防万一，还有 NNS 子网对其他子网公钥的签名。这样就能拿着 NNS 的子网公钥验证 NNS 子网对其他子网公钥的签名了 ~ 

再把几把常用的子网公钥缓存进用户的设备里，就 ok 了👌。

<img src="assets/1.ChainKey/image-20230820221935349.png" style="zoom:37%;" />

好的，现在验证 BLS 阈值签名是没啥问题了。



然而这还远远不够。



## NIDKG

子网里的副本要靠 BLS 阈值签名跑起来，首先要做的是给每个副本分发密钥。而阈值签名方案通常需要依赖一个可信的密钥生成中心，负责分发密钥。但在区块链里，不能轻易相信某一个副本，假设它不是恶意的。

<img src="assets/1.ChainKey/image-20230820224815507.png" style="zoom:33%;" />

这就需要一个分布式的密钥分发方案（DKG）了，这种方案过去应用场景很小，技术实现复杂，而且运行起来低效耗时，光分发密钥就要花不少时间，根本不够实用。

更主要的原因是：传统的 DKG 协议要么是假设在一个同步网络中通信，，要么没有健壮性，或者既需要同步通信又没有健壮性。

同步网络中通信意味着，如果消息稍微有点延迟，整个 DKG 过程就会失败或不安全。没有健壮性也就是说，如果 DKG 过程中有一个节点崩溃，整个 DKG 都白折腾了。



可想要在区块链上实现 BLS 阈值签名就得用 DKG ，不然还叫区块链嘛！没办法，Dfinity 的老师傅们只能埋头研究提高 DKG 效率的办法。



要是一般人，只能看着天书一般复杂的密码学理论望洋兴叹了，好在 Dinity 的师傅们各个身怀绝技。

Dfinity 有许多经验丰富的老师傅，很多人之前在 IBM、谷歌、亚马逊等大厂工作过，其中不乏来自苏黎世联邦理工学院、麻省理工学院、斯坦福大学、加州大学洛杉矶分校、耶鲁大学 等顶尖大学的计算机科学家、密码学家、研究员、博士组成的[研究团队](https://dfinity.org)。

首席技术官 **Jan Camenisch** 是计算机科学家， IEEE 和 IACR 院士，在隐私和密码学领域发表了 120 多篇被多次引用的论文。此前，他在 IBM 担任了 19 年首席研究员。**Ben Lynn** 是 BLS 签名算法的创造者之一。他的 “ L ” 就是 BLS 中间那个 “ L ” 。从斯坦福博士毕业后他在 Google 工作了 10 年。 **Timo Hanke** 之前是亚琛工业大学的数学和密码学教授。2013 年创建了 AsicBoost ，将比特币开采的效率提高了 20 - 30 ％ ，现在已成为大规模挖矿作业的标准。

还有超级密码学家 **Jens Groth** ，他发明了基于配对的非交互式零知识证明（NIZK）、基于配对的 SNARKs ，以及对 Bulletproofs 基础技术的对数大小的证明系统。奥胡斯大学博士，在加州大学洛杉矶分校获得了校长博士后研究奖，成为伦敦大学学院密码学教授，并发表了 50 多篇论文。



哦，对了，现在的主角就是 Jens 。

<img src="assets/1.ChainKey/image-20230820221756941.png" style="zoom:67%;" />

传统的 DKG 协议都无法满足 IC 的高要求。IC 需要一个在有许多故障节点的异步网络中，也能保证安全性和健壮性的 DKG 协议。

为了解决 DKG 低效麻烦的问题，他直接从底层入手，针对 DKG 需要多轮交互的复杂过程做了大量优化。DKG 过程中需要用到零知识证明，而一般的零知识证明需要多轮交互才能完成， 2 个人之间的交互就已经足够繁琐了，子网里那么多节点哪能交互的过来。而且零知识证明计算复杂度高，需要复杂的加密算法和交互协议，证明生成和验证都需要大量计算资源。

于是 Jens 大佬亲自操刀，手撕密码学：发明了一种高效的非交互式零知识证明（NIZK）。在不需要多轮交互的情况下，完成零知识证明。

有了 NIZK ，新的 DKG 协议如虎添翼。很快，NIDKG 便横空出世！



多米尼克发文炫耀的他们的科学家团队👇。

<img src="assets/1.ChainKey/image-20230820231353543.png" style="zoom:80%;" />



顺便提一嘴，零知识证明是一种前沿密码学技术，它可以让你向对方证明一件事，而你又不用告诉他是什么事。听起来是不是很不可思议！这在密码学上是可以做到的。这特别像女票对你说：“ 我想跟你说个事儿，你得答应我。” 你问：“ 你得告诉我什么事儿。” 女票说：“ 你必须先答应我嘛。” 



密码学狂人们已经打算在 ii 上加入零知识证明了！

<img src="assets/1.ChainKey/image-20230820230117316.png" style="zoom:73%;" />

非交互式密钥分发协议，这个非交互式嘛，就是副本之间不需要交互，不用

就像在考场上传纸条作弊：

A 问 B：第 15 题你会不会？

B 说：不会。

A 说：哦。。。

A ：21 题呢？

B 说：不会。

A 说：哦。。。

。。。

监考老师眼中纸条满天飞。。。



该协议在异步网络上运行且具有很高的健壮性（即使子网中多达三分之一的节点崩溃或损坏，它仍然可以成功），同时仍然能够提供可接受的性能。除了生成新密钥外，此协议还可用于重新共享现有密钥。此功能对于实现 IC 拓扑的自主演进至关重要，因为子网随着时间推移会发生成员变化。

这只是 ChainKey 的冰山一角，它还能运行节点任意的退出与加入网络，从而轻松的把新节点接入网络进行扩容，这都归功于非交互式分布式密钥生成（Noninteractive Distributed Key Generation）技术的突破。

IC 的拓扑结构可以自主演化——可以添加新的节点和子网，可以恢复故障节点，可以自主升级协议。



### 具体过程





### 再共享协议





## 链上进化技术





### 时期





### 摘要块





### 追赶包





## CK代币

（Chain Key Token）

如果能如此轻松的对区块链进行验证，那我们是不是能在其他的区块链上直接运行一个 DFINITY 的验证节点？没错，ChainKey 极易验证的特性也让 DFINITY 天然适合跨链操作，我们甚至可以在一个 ETH 的智能合约中存下 DFINITY 的区块链公钥，直接进行跨链交易的验证。这会带来大量的业务空间！



### 阈值ECDSA



CKBTC



### VETKeys





## 应用

该公钥还用于定期验证子网的整个状态，从而实现诸如向子网添加新节点以及使崩溃节点快速追赶上其他节点等功能。这提高了 IC 的可扩展性，并对实现 IC 拓扑在 NNS 的指导下随时间自主演进至关重要。

此外，这些阈值签名还用作创建不可预测伪随机数的来源，这在两方面有所应用：

作为任何智能合约可用的不可预测且不可偏见的伪随机数来源，这是区块链世界中的一个独特功能，使得在其他区块链上无法实现的应用成为可能（例如，NFT 抽奖）；作为 IC 共识协议中伪随机选择领导者的机制，这增强了共识的效率和公平性。

> 有一个简单的问题：所有的块都是永久存储的吗？

我们不依赖历史区块进行验证。所以每个副本只存储足够的块来保持网络健康（例如帮助其他副本赶上），并在不再需要时删除旧的。

这也是由于终结算法。一旦输入块最终确定，我们确信可以确定地计算新状态，并且只需要保持最新的容器状态。较旧的块和较旧的状态不是那么有用。



使用 BLS 签名方案的另一个原因是签名是唯一的，对于给定的公钥和消息，只有一个有效的签名。这种唯一签名属性对于为智能合约生成不可预测且无偏差的伪随机数至关重要：在智能合约请求伪随机数之后（而不是之前！），会生成对特殊消息的签名，然后通过哈希函数将此签名传递，以从中导出种子，然后从种子中生成所需的伪随机数。根据签名方案的安全特性，无法预测或偏置这个种子或衍生的伪随机数。



## 总结









> 这里的关键创新是什么？ICC 协议如何或为什么比具有汇总和分片或类似协议的以太坊更好？

我认为子网实际上是共识的孤岛这一事实是主要的创新。有了链密钥，它们可以安全地相互通信，仍然形成一台互联网计算机，但因为不需要“全球”共识，我们可以通过添加子网来横向扩展。







我来概述一下关于 Threshold ECDSA Signing 的主要内容:

Threshold ECDSA Signing 是一种分布式数字签名方案，可以在不露出私钥的情况下生成 ECDSA 签名。它基于 Shamir's Secret Sharing 技术，将私钥分成 N 个片段，分布在 N 个节点上。要生成签名，需要至少 T 个节点参与协作计算。

该方案的工作流程如下:

1. 将私钥通过 Shamir's Secret Sharing 分割成 N 个片段，分发给 N 个节点。
2. 当需要生成签名时，选择至少 T 个节点参与协作。这些节点互相交换信息，共同计算出签名。
3. 签名验证只需要公钥，不需要私钥片段。所以可以公开验证签名的正确性。
4. 即使攻击者获取了少数节点上的私钥片段，也无法恢复出完整的私钥。只有当攻击者同时控制了至少 T 个节点时，才可能合谋破坏签名或恢复私钥。

Threshold ECDSA可以防止单点故障，提高签名服务的可用性。也可以防止私钥被单一实体控制或泄漏。因此具有更好的安全性。

这是 Threshold ECDSA Signing 的主要内容概述。总体来说，它通过分布密钥、 Threshold 计算等手段，实现了安全可靠的分布式 ECDSA 签名方案。让数字签名服务更加可扩展、可用和安全。



> 可以再详细一些吗？多讲讲，1500字左右

好的，我来尝试 Threshold ECDSA Signing 做一个更加详细的概述:

Threshold ECDSA Signing是一种分布式签名方案，允许多个实体共同参与ECDSA数字签名的生成，而无需泄露私钥。它基于Shamir密钥分割方案，将ECDSA私钥分割成N个片段，分发给N个参与者。只有收集到至少T个片段，才能重构出原始私钥进行签名。

具体来说，Threshold ECDSA Signing的工作流程如下:

1. 设置参数:选择参与签名的节点数量N，以及需要多少节点才能重构私钥的阈值T。通常设置T<=N/2，即需要大多数节点才能签名。
2. 密钥生成:随机选择一个ECDSA私钥，使用Shamir密钥分割方案将其分割成N个片段，每个片段分发给一个节点。
3. 签名请求:当需要签名时，客户端向N个节点发出签名请求。
4. 节点交换信息:收到请求的节点互相交换信息，进行 Threshold ECDSA 签名协议的交互计算。这通过多轮广播和点对点通信实现。
5. 聚合签名:最终有至少T个节点将计算结果发送回客户端，客户端可以通过Lagrange 插值法恢复出ECDSA签名。
6. 验证签名:任何第三方只需要ECDSA公钥就可以验证签名的正确性，而无需知道私钥或其片段。

Threshold ECDSA Signing的安全性基于以下几点:

1. 单个节点无法在不知道其它节点的片段情况下生成签名。这通过零知识证明实现。
2. 收集少于T个分片无法重构私钥。根据Shamir秘密共享的属性。
3. 即使单个节点被攻破，也只能获取该节点上的单个分片，不影响整个私钥的安全。
4. 异步网络模型下也可以安全执行算法，防止攻击者利用时序攻击获取信息。

相比单点集中的ECDSA签名，Threshold ECDSA Signing解决了单点故障问题，具有更好的可用性。也解决了私钥容易被泄露或滥用问题，大大提高了安全性。适合构建大规模可扩展、可靠且安全的签名服务。

Internet Computer采用Threshold ECDSA Scheme来生成链上账户的公私钥对。私钥通过Threshold方式分割在多个节点，只有节点协作才能使用。这样既防止单个节点私钥泄露，又实现了高可用性。用户可以安全可靠地在链上进行交易和状态变更。

Threshold ECDSA Signing是一个活跃的研究课题，目前还有一些改进空间:

1. 进一步减少通信和计算复杂度。
2. 加入后量子算法安全机制，抵御量子计算机攻击。
3. 引入诚实多数计算模型，降低对节点作恶的要求。
4. 支持动态加入和退出节点，增加灵活性。
5. 丰富支持的曲线种类和签名算法。

综上所述，Threshold ECDSA Signing通过分布式密钥和多方计算技术，实现安全高效的数字签名。Internet Computer使用了该机制来增强链上账户安全性和系统可用性。这是一个值得进一步研究和应用的重要密码技术。



> 请详细讲解：https://internetcomputer.org/how-it-works/chain-key-technology/

好的，我来详细概述一下关于Internet Computer的链上密钥技术:

Internet Computer使用了独特的链上密钥生成和管理机制来增强安全性。其核心思路是:不再依赖单一集中实体来生成密钥，而是通过分布式多方计算的方式生成和管理链上密钥。

具体技术细节如下:

1. 引入了“区块链随机密钥生成(Blockchain Random Beacon，BRB)”机制。这依赖于VRF和Threshold ECDSA两种密码技术。
2. BRB在每个区块生成时都会产生一个随机数。该随机数依赖于当前区块的信息，而且无法预知。
3. 将BRB生成的随机数作为种子，可以派生出该区块对应的一批公私钥对。这批密钥可以分配给新创建的链上账户使用。
4. 密钥生成和签名都依赖 Threshold ECDSA 进行分布式计算。避免单点故障和攻击。
5. 整个过程不依赖任何中心化的证书机构或密钥管理机构。新的账户地址和公钥是链上根据协议算法动态生成的。
6. 可以为每个账户派生出用于治理、调用智能合约等多个密钥对。所有权通过链上验证来建立。
7. 支持密钥定期轮换。旧密钥对在到期后会失效，需要使用新的密钥对。
8. 链上 contract 代码也含有公钥。这可以验证 contract 调用者身份，防止篡改或滥用。

这样的设计相比传统的中心化密钥管理机制，有以下优势:

1. 去中心化，不依赖中心实体，更可靠和安全。
2. 动态派生密钥，而不是重用固定密钥，可以有效抵御量子计算攻击。
3. 支持密钥定期轮换，可以减轻密钥泄露的损害。
4. 基于区块链历史的数据生成密钥，保证随机性和不可预测性。
5. 采用多方计算生成密钥和签名，可以防止单点攻击和控制。
6. 简化账户和合约管理，不需要外部证书中心。

通过这种链上密钥技术的创新设计，Internet Computer实现了去中心化、安全、可靠的区块链计算平台。其安全性不依赖任何集中式密钥基础设施。这对于构建高度可扩展和可用的公共区块链具有里程碑意义。

当然，这种链上密钥技术也还有改进空间，未来可望支持更多类型密钥和算法，引入零知识证明进一步增强安全性，简化用户操作等等。但总体来说，这是区块链技术安全演进的重要一步。









来讲讲Chain Key中的第二部分——Chain Evolution Technology。

Chain Evolution Technology由两部分组成:Summary Blocks和Catch-up Packages(CUP)。它们的作用是帮助区块链平滑地进行链上变更和升级。

什么是链上变更和升级呢?区块链网络在运行过程中，参与的节点可能会增加或离开，算法也需要不断优化。这就需要对区块链状态进行动态调整。

如果不考虑Compatibility，直接在链上做Hard Fork，势必会造成不同版本链之间的分叉。这对去中心化网络是灾难性的。

所以我们需要能够平滑地做到Backward Compatibility，也就是新老版本链可以兼容和重叠运行。这需要一套精心设计的链上变更机制，即Chain Evolution Technology。


先来看Summary Blocks，顾名思义，它存储每轮的链上摘要数据。主要包含以下信息:

1. 当前子网的成员节点列表

2. 用于链上签名的公钥信息 

3. 链上升级的版本号

4. 随机数种子

5. 一些其它元数据


将这些关键信息汇总到Summary Block中，具有以下好处:

1. 新节点可以快速同步链状态，不需要从创世块全部执行一次。

2. 旧版本节点可以验证Summary Block的签名，安全地与新版本交互。

3. 关键参数集中管理，便于链上治理和升级。

可以看出，Summary Blocks在平滑地进行链上变更中起了“锚点”的作用。新老版本链都可以参照这个汇总数据进行交互和状态迁移。

接下来看另一部分——Catch-up Packages (CUP)。

CUP包含当前阶段完整的链状态快照。具体来说，包含:

1. 该阶段所有链数据的Merkle树根

2. 对应的Summary Block

3. 随机数种子

4. 签名信息


当新节点加入网络时，可以请求CUP来快速同步状态，而不需要从创世块开始执行全部交易。

当旧版本节点需要升级时，也可以用CUP安全地切换到新版本链上。

可以看到，CUP进一步增强了版本链的兼容性和平滑迁移。新节点和旧节点都可以依据CUP快速安全地同步状态。

总结一下，Chain Evolution Technology启用了Summary Blocks和CUP这两个锚点机制，通过存储关键参数、链状态快照等数据，帮助不同链版本之间进行兼容和平滑迁移。

这就避免了Hard Fork在去中心化网络中的大量问题，确保了区块链平台的持续演进。

当然，Chain Evolution也存在一些限制:

1. 提取和签名链状态快照需要额外计算开销。

2. 需要链上治理协议来管理和发布新的Summary Blocks。

3. 不足以应对全部的链上变更场景。

这仍是一个活跃的研究领域，我们需要更多实践来完善链上变更的技术方案。

但Chain Evolution Technology无疑是迈向实用和演进的区块链的重要一步。它为链上参数调整、节点迁移、算法升级等提供了基础框架。

相信随着技术的进一步成熟，区块链平台会变得越来越易用和灵活，才能真正被广泛应用起来。









阈值签名

链钥密码学的第一个组成部分是阈值签名：阈值签名是一个成熟的加密技术，它允许子网拥有一个公共的验证签名密钥，对应的签名私钥分成片段分配给子网中的节点副本，而分配保证作恶节点无法伪造任何签名，而诚实节点拥有的私钥片段可以允许子网生成符合IC原则和协议的签名。

这些阈值签名的一个关键应用在于一个子网的单独输出可以由另一个子网或是外部用户进行验证，验证可以简单地利用该子网（第一个子网）的公共验证签名密钥来验证电子签名实现。

需要注意的是，子网的公共验证签名密钥可以从NNS中获取—该公共验证签名密钥在子网的生命周期中保持不变（即使子网的成员在该生命周期中可能发生变化）。这与许多不可扩展的区块链协议形成鲜明的对比，其需要验证整个区块链来验证单个输出。



正如我们所看到的，这些阈值签名在IC中还有许多其他应用。一个应用于让子网中的每个节点副本可以访问无法预测的伪随机数位（衍生于此类阈值签名）。这是共识层使用的随机信标和执行层使用的随机磁带的基础。

为了安全地部署阈值签名，IC采用了创新性的分布式密钥生成（以下简称DKG）协议，来构建公共签名验证密钥，并为每个节点副本提供对应签名私钥的一个片段，用于我们的故障和通信模型。



链钥密码学也包括一系列复杂的技术，用于随时间推移健壮和安全地维护基于区块链的复制状态机，合起来我们称之为链演进技术。每个子网在包含多轮（通常大约是几百轮）的时期（Epoch）内运行。利用阈值签名和其他一些技术，链演技术实现了许多按时期定期执行的基本维护工作：

**垃圾回收**：在每一时期的末尾，所有已经被处理的输入以及所有排序这些输入所需要的共识层消息，可以安全地从每个节点副本的内存中清除。这对防止对于节点副本的存储需求的无限增长至关重要。这也与许多不可扩展的区块链协议形成对比，它们必须存储从创世区块开始的整个区块链。

**快速转发**：如果一个子网中的节点副本大幅落后于其同步节点（因为其宕机或是网络断连很长时间），或是一个新的节点副本被添加入子网，他们可以通过快速转发至最新时期的起始点，不需要运行共识协议并处理该点之前的所有输入。这也与许多不可扩展的区块链协议形成对比，它们必须处理从创世区块开始的整个区块链。

**子网成员变更**：子网的成员（由NNS决定，详见章节1.5）可能会随着时间变化。这仅可能发生在时期的边缘，需要小心操作以确保一致且正确的行为。

**主动秘密再共享**：我们在上面的章节1.6.1中提到 IC 是如何使用链钥密码学——具体来说，阈值签名——来进行输出验证。它基于的就是**秘密共享**，通过将一个秘密（在这里就是签名私钥）拆分成片段分别存储在节点副本中，从而避免了任何单点故障。在每个时期开始时，这些片段都会被**主动再共享**。这实现了两个目标：

* 当一个子网的成员发生变动时，再共享可以确保任何新成员都有相应的秘密片段，而任何不再是成员的节点副本就不再会拥有秘密片段。

* 如果在任意一个时期，甚至每个时期都有少量的秘密片段被泄露给攻击者，这些片段也不会帮助到攻击者。

**协议升级**：如果IC协议本身需要升级，修复漏洞或是增加新功能，可以在时期开始时通过特殊协议（CUP）自动完成。





再共享协议

基础DKG协议可以被很容易地修改，因此不需要创建一个新的随机密钥$x$的共享，而是创建一个先前共享密钥的新随机共享。

- 修改基础协议的第1步，以便每个节点可以广播已有共享片段的已签名dealing
- 修改第2步，以便就$t$个有效的已签名dealing集合达成共识。此外，每个dealing都经验证以确保是现有共享片段的dealing（这意味着在第$i$个dealing中$A_{i，0}$的值应当等于$V_i$的旧值）。
- 第3步中，通过计算$i$个拉格朗日插值系数的和（和乘积），等于新的$x_j$（和$V_j$）。





**垃圾回收：**因为CUP包含特定时期的信息，因此每个节点副本可以安全地清除该时期前所有已处理的输入，以及对这些输入排序的共识层消息。

**快速转发：**如果一个子网中的节点副本大幅落后于其同步节点（因为其宕机或是网络断连很长时间），或是一个新的节点副本被添加入子网，他们可以通过快速转发至最新时期的起始点，不需要运行共识协议并处理该点之前的所有输入。该节点副本可以通过获取最新CUP做到。利用从CUP中包含的摘要块和随机信标，以及来自其他节点副本的（还没有被清除的）共识消息，该节点副本可以从相应时期的起始点开始，向前运行共识协议。该节点也可以使用状态同步子协议来获取对应时期开始时的复制状态，这样它也可以开始处理共识层产生的输入。

图5描绘了快速转发。此处，我们假设需要一个需要追赶的节点副本处于时期起始点，（比方说）块高为101，有一个CUP。这个CUP包含了块高101的复制状态的默克尔树的根，块高101的摘要块（绿色标识）和块高101的随机信标。该节点会使用状态同步子协议，从它的对等节点中获取块高101的所有复制状态，并用CUP中的默克尔树来验证此状态。在获取到该状态后，节点副本可以参与到协议之中，从对等节点中获取块高102，103等等的区块（以及其他和共识相关的消息），并更新其复制状态的副本。如果其对等节点已经确认了更高高度的区块，该节点副本将尽快处理（以及公证和最终确认）这些从对等节点获取的已最终确认区块（以执行层所允许的最快速度）。

<img src="assets/1.ChainKey/图5：快速转发.png" alt="截屏2022-02-13 23.36.57" style="zoom:80%;" />

<center>图5：快速转发</center>

**子网成员变更：**我们已经讨论过特定时期内，如何使用摘要块来加密，使用哪个版本的注册表以及它如何决定子网成员，更具体来说，是各种任务的委员会成员。需要注意的是，即使一个节点副本从一个子网中移除，（如果可能的话）它应当额外履行一个时期的所分配到的委员会职责。

**主动秘密再共享：**我们已经讨论过了，如何使用摘要块生成和转发签名密钥。如有必要，需要的摘要块也可以从CUP中获取。

**协议升级：**CUP 也可用于协议升级。协议升级由 NNS 发起（详见[章节1.5](#1.5 权限模型)）。不考虑所有细节，基本细节如下：

- 当需要安装新版本的协议时，时期开始时的摘要块会做出指示；
- 所有运行老版本协议的节点副本，将继续运行共识协议直到最终确认摘要块并创建对应的CUP；然而，他们只会创建空区块，并不会将任何荷载传递给消息路由层和执行层；
- 安装新版本的协议后，运行新版本共识协议的节点副本，将从上述的CUP开始继续运行完整的协议。









链密钥签名

链密钥签名扩展了链密钥技术，允许针对其他区块链的交易在链上使用 Internet Computer 协议完全计算。通过链密钥签名，IC 可以与比特币和以太坊等其他区块链完全无信任地集成，无需任何桥接。Canister 现在可以安全地存储和交易比特币。比特币的私钥在运行 Canister 的所有节点之间共享。当至少三分之二的节点同意进行交易时，Canister 可以使用链密钥签名的交易进行比特币交易。事实上，使用链密钥签名是整合区块链的最强大、最分散的方式，因为除了两个区块链之外，不需要任何其他信任假设，尤其是不需要管理签名密钥或其份额的其他方。



比特币整合

Internet Computer 上的比特币整合基于两个支柱：链密钥签名和 Internet Computer 节点与比特币对等网络之间的直接互动。虽然链密钥签名使 Canister 可以拥有自己的比特币地址并创建有效的交易，用于支付这些地址持有的比特币，但 Internet Computer 和比特币网络之间的直接消息交换用于在 Internet Computer 中维护关于比特币区块链状态的信息（如地址余额），并将 Canister 发起的比特币交易传输到比特币网络。



链密钥代币

链密钥代币 —— 以及链密钥比特币（ckBTC）—— 是一种基于密码学的替代包装代币，具有强大的去中心化优势：链密钥代币消除了传统基于中介的代币包装所带来的风险，同时还具有使来自其他区块链的代币可用于转账和交易的优势。链密钥密码学使这成为可能：以比特币为例，Canister 智能合约可以拥有 ECDSA 密钥对，并派生出可以在比特币网络上进行真实比特币转账的比特币地址。当接收到比特币时，Canister 以 1:1 的比例向比特币的发送者铸造并发行 ckBTC。相反，兑换 ckBTC 为基础比特币会将 ckBTC 从流通供应中移除并退还比特币。这使得链密钥代币成为具有相同属性和估值的原始代币的“双胞胎”，但托管在 Internet Computer 上。







这段文字详细介绍了一个阈值签名方案及其匹配的分布式密钥生成协议，包括各种算法。阈值签名方案的目标是防止未授权签名，确保只有达到阈值的参与者共同参与签名过程。

在安全性定义中，诚实的参与者可以生成新的公钥，这些公钥对敌手是公开的。我们假设公钥具有足够的熵以唯一标识参与者。敌手可以在满足某些条件的情况下，要求参与者更新解密密钥。

参与者有时会创建新的阈值签名验证密钥，并分配相应的签名密钥份额。敌手可以决定何时创建新的验证密钥，但需要提供一个参与者配置以及阈值和纪元。此外，敌手可以触发诚实的交易创建，模拟诚实参与者运行交易算法。所有诚实的交易都包含在 Qd 集合中。

之后，敌手可以将诚实的交易与自己的任意交易组合，生成一个让互联网计算机识别的新公钥。在安全性定义中，我们要求敌手在交易记录中至少包括一个诚实的交易。如果交易记录被接受，交易将组合导出一个验证密钥，该密钥将注册在 Qvk 中。

参与者有时还希望重新共享现有的秘密阈值签名密钥。在这种情况下，敌手也需要创建一个配置，但这次配置必须引用先前的配置和它所依赖的现有公钥的交易记录。被诚实节点处理的分享签名密钥也会被记录。

诚实的参与者可以使用分享签名密钥为任意消息提供签名份额。在我们的模型中，我们让敌手控制何时以及哪个参与者为哪个消息签名。

在互联网计算机上，诚实的参与者会在分享签名密钥过时时擦除它。当然，只有在参与者无法再通过解密密钥恢复分享签名密钥时，擦除才有意义。因此，我们只允许敌手要求擦除无法再次被诚实参与者恢复的分享签名密钥。

最后，我们的安全模型旨在捕获动态腐败，因此我们允许敌手腐化参与者。每当敌手腐化一个参与者时，她会了解到该参与者拥有的所有相关数据，如解密密钥和所有未擦除的份额。此后，与该参与者有关的记录将被删除，因为模型只记录诚实参与者，而敌手现在可以代表该参与者行动。

