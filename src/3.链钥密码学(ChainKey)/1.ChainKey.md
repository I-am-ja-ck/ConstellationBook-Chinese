https://www.youtube.com/watch?v=vUcDRFC09J0&t=1s



## 链钥密码学

（配这部分的合影图，类似于首页的第一张图，各种内容聚集到一起）

链钥密码学（Chain-key cryptography）是对嵌入 IC 底层系统密码学的统称，是 IC 运行时依赖的一套完整的密码学协议，包括了 BLS 阈值签名、非交互式密钥分发协议（NIDKG）、非交互式零知识证明（NIZK）、阈值 EDCSA 、可验证加密阈值密钥（VETKeys） 。

其中最重要的是 BLS 阈值签名。



## BLS阈值签名

先讲讲 BLS 阈值签名是什么东东？ ฅʕ•̫͡•ʔฅ 

它是链钥密码学最重要、最核心、最根本的部分。子网运行要靠 BLS 阈值签名达成共识，靠 BLS 阈值签名给用户返回消息认证，靠 BLS 阈值签名生成共识依赖的随机信标，靠 BLS 阈值签名签署追赶包等等。

举例来说的话，BLS 阈值签名就像一个 “ DAO ” ，只要是需要子网签名的地方，都要子网里足够的副本 “ 同意 ” （签名）才行。足够的副本同意，即代表达成共识，少数服从多数。



在传统的非对称加密算法中，我们可以生成一把公钥、一把私钥；公钥公开，私钥保密；公钥加密信息，私钥解密信息；私钥签名信息，公钥验证信息。还可以在[这里]()先了解了解非对称加密。

像之前[共识](../2.核心协议/2.共识层.md)讲的那样，比如子网里的某个副本打包一个区块，当大家认为区块没问题时，就会用私钥对区块留下自己的签名，表示自己的认可。

如果每个副本都生成一对公私钥，密钥管理既复杂有低效🥲。而且更重要的是：如果用户想验证链上内容，就得下载几百个 G 的数据来亲自验证😭。这太不友好了。



Dfinity 为了解决这个问题，选择了 BLS 签名的阈值方案来实现子网签名。

<img src="assets/1.ChainKey/image-20230818124536695.png" style="zoom:50%;" />



### BLS签名

先来说说为啥选择 BLS 签名吧。

它和 RSA 、DSA 这些常见的签名算法有很多不同的地方。

首先 BLS 签名的长度很短也更安全。

一个签名值只需要一个椭圆曲线点的一个坐标，大概160比特就够了。但 RSA 签名和 DSA 签名包含两个大整数，通常需要 320 比特才能达到同等安全级别，长度上 BLS 签名明显优势。BLS 签名的安全性不是依赖整数分解之类的数学问题，而是依赖椭圆曲线上的计算困难问题，比如 CDH 问题。这种问题目前看来更难破解。



虽然 BLS 签名的验证速度比较慢，因为需要计算一些配对运算。但是签名生成很快，只需要一个简单的点乘运算。RSA 和 DSA 恰恰相反，签名慢但是验证很快。 

BLS 签名还有一个优点就是不需要保存签名状态，只要消息内容不变，签名就是固定的。但 RSA 和 DSA 签名还需要保存随机数才能防止重放攻击。

另外，BLS 可以非常高效地同时批量验证多个签名，在很多应用场景下可以大幅提升效率。这是 RSA 和 DSA 做不到的。



这些特性让它在很多对签名长度和可扩展性要求很高的区块链应用里面非常合适。

这个算法本身非常优雅，是一种很有前景的签名算法。在[这里]()可以了解更多 BLS 签名算法的密码学原理。

当然，最重要的一点是 BLS 签名可以把私钥拆分为私钥片段，升级为多签方案或者**阈值签名**（也叫门限签名）！RSA 和 DSA 要直接做到这点就很难了。



### BLS阈值签名

把私钥拆分为私钥片段！

听起来很高大上，但其实就是一种让多个人共同参与签名的算法。把私钥分成许多份，发给不同的人保管。在签名时，必须由足够多的人（达到阈值）一起参与签名，才能把签名片段合成一个有效的签名。

<img src="assets/1.ChainKey/image-20230818123248527.png" style="zoom:45%;" />

在动画和游戏情节中，有很多必须收集多个钥匙、水晶或其它物品才能打开通往最后关卡或获得终极宝藏的大门。比如《复仇者联盟 3 ：无限战争》中，灭霸要集齐六颗无限宝石来消灭宇宙一半的生命。《哈利波特》系列中，伏地魔分裂了自己的灵魂制作了多个魂器，哈利必须找到并销毁所有的魂器才能完全消灭伏地魔。《七龙珠》里是集齐七颗龙珠可以召唤神龙实现心愿等。

<img src="assets/1.ChainKey/image-20230818135016018.jpg" style="zoom:33%;" />

这种通过收集或组合物品来产生某种神奇效果的情节在各种电影、书籍和游戏中屡见不鲜。



现实中的 BLS 阈值签名通过密码学实现了这种魔法。每个人拿着一个私钥片段生成一个签名片段，只要人们的签名片段达到阈值就能合成一个完整的签名。而用来验证签名的公钥是唯一的！

虽然阈值签名方案很早之前就有了，但 IC 是第一个将这种技术整合到底层协议中的区块链。

没有完整的私钥，只有分散的私钥片段，即使是作为持有私钥片段的副本，也无法直接得到签名结果。必须要拿到足够的签名片段才能合成签名。在区块链上的操作需要多个副本共同确认，从而提高了安全性和可靠性。敌手很难控制足够多的节点来伪造签名。

<img src="assets/1.ChainKey/image-20230818153704812.png" style="zoom:37%;" />

BLS 阈值签名是 IC 的根基，有了阈值签名，子网里的副本就可以依靠 BLS 阈值签名来达成共识啦：

* 子网里足够数量的副本对新区块签了名，就能合成完整签名，也就意味着达成了共识，少数服从多数。其他副本可以拿子网公钥验证区块。

* 子网里足够数量的副本对随机信标签了名，就能合成完整签名，也就意味着新的签名就是一个新的随机数。其他副本可以拿子网公钥验证这个随机数。
* 子网里足够数量的副本对默克尔树根签了名，就能合成完整签名，也就意味着子网里的大部分副本的状态是一致的。用户可以拿子网公钥验证输出。



BLS 阈值签名还有一个很重要的优点：用户要确保子网发回来的消息没有被篡改，万一消息被黑客替换掉就麻烦了。

所以子网要对返回给用户的消息签名。

<img src="assets/1.ChainKey/image-20230818163340357.jpg" style="zoom:30%;" />

前面说过：如果每个副本都生成一对公私钥，密钥管理既复杂有低效🥲。如果用户想验证链上内容，就得下载几百个 G 的数据来亲自验证😭。这太不友好了。

而子网使用 BLS 阈值签名之后，就相当于一个子网只有 “ 一对公私钥 ” 。私钥有子网里的副本共同保管，公钥只有一个！任何人都可以拿着子网公钥验证子网签名过的内容👍！

也就是说，想验证链上的数据再也不用下载几百个 G 的全部数据啦，只要用一个 48 kb 的子网公钥单独验证某个消息就好了。用户的手机、电脑甚至物联网设备都能验证子网签名过的消息。

<img src="assets/1.ChainKey/image-20230818163244831.png" style="zoom:25%;" />

同样的，在需要跨子网通信时，子网 B 也可以用公钥 A 验证子网 A 发来的消息。

这种跨分片验证的能力使 IC 能横向扩展，只要节点够多，就能创造出无限个分片（子网）。

<img src="assets/1.ChainKey/image-20230818175102179.png" style="zoom:37%;" />







讲阈值签名，<u>然后接⑤</u> 



最重要的是，这个公钥可以用于验证 IC 的输出，包括来自外部用户的入口消息的响应，以及一个容器到另一个容器的消息。这是 IC 和其他区块链之间的根本区别：其他区块链的状态只能通过从创世区块运行整个协议来验证，而在 IC 上，只需验证单个数字签名即可。因此，这是实现互联网计算机空前可扩展性的关键技术之一。

该公钥还用于定期验证子网的整个状态，从而实现诸如向子网添加新节点以及使崩溃节点快速追赶上其他节点等功能。这提高了 IC 的可扩展性，并对实现 IC 拓扑在 NNS 的指导下随时间自主演进至关重要。

此外，这些阈值签名还用作创建不可预测伪随机数的来源，这在两方面有所应用：

作为任何智能合约可用的不可预测且不可偏见的伪随机数来源，这是区块链世界中的一个独特功能，使得在其他区块链上无法实现的应用成为可能（例如，NFT 抽奖）；作为 IC 共识协议中伪随机选择领导者的机制，这增强了共识的效率和公平性。



实施

IC实现的阈值签名方案是著名的BLS签名方案的阈值版本。使用BLS签名方案的一个原因是，它是唯一能产生非常简单且高效的阈值签名协议的签名方案。实际上，持有私钥份额的机器可以非常轻松地生成对某个消息的签名份额，这些签名份额可以组合成对该消息的BLS签名——这些机器之间不需要进一步交互。

使用BLS签名方案的另一个原因是签名是唯一的，这意味着对于给定的公钥和消息，只有一个有效的签名。这种唯一签名属性对于为智能合约生成不可预测且无偏差的伪随机数至关重要：在智能合约请求伪随机数之后（而不是之前！），会生成对特殊消息的签名，然后通过哈希函数将此签名传递，以从中导出种子，然后从种子中生成所需的伪随机数。根据签名方案的安全特性，无法预测或偏置这个种子或衍生的伪随机数。

尽管使用阈值 BLS 签名相当简单，但设计一个安全的、去中心化的协议来生成和分发私钥份额——即一个分布式密钥生成（DKG）协议——仍然具有挑战性。尽管已经有很多关于 DKG 设计的研究，但文献中的绝大多数 DKG 协议都无法满足互联网计算机（IC）的高要求，因为它们要么假设一个同步网络（这意味着如果消息意外延迟，协议将失败或变得不安全），要么没有健壮性（这意味着如果一个节点崩溃，产生签名的能力就完全丧失），或者两者兼有。在IC上，这些假设都是不可接受的：即使在一个有许多故障节点的异步网络中，安全性和生存性也必须保持。

DFINITY已经设计、分析并实现了一种新的DKG协议，该协议在异步网络上运行且具有很高的健壮性（即使子网中多达三分之一的节点崩溃或损坏，它仍然可以成功），同时仍然能够提供可接受的性能。除了生成新密钥外，此协议还可用于重新共享现有密钥。此功能对于实现IC拓扑的自主演进至关重要，因为子网随着时间推移会发生成员变化。





IC的共识协议确实使用了区块链，但它也采用了公钥加密技术，特别是电子签名：NNS 维护的注册表用于将公钥绑定至节点副本及子网形成一个整体。



链密钥密码术的一个关键组成部分是阈值签名方案，它类似于普通的数字签名方案，不同之处在于秘密签名密钥分布在子网中的所有副本中，这样密钥就不会被泄露窃取子网中的一个（甚至很大一部分）副本。该技术有很多好处，包括：

1. 任何人都可以通过简单地验证签名来验证从互联网计算机接收到的内容，而无需同步整个区块链。
2. IC 的拓扑结构可以自主演化——可以添加新的节点和子网，可以恢复故障节点，可以自主升级协议。
3. Canister 的不可预测和无偏伪随机数的来源。容器可以安全地运行需要随机性的算法。



互联网计算机协议使用先进的加密机制工具箱，统称为链密钥加密，它允许 IC 实现其他区块链上不可能实现的功能和可扩展性。

链密钥密码术的关键组成部分是*门限签名方案*，它与普通的数字签名方案类似，不同之处在于秘密签名密钥分布在子网中的所有副本中，使得密钥无法通过泄露而被窃取。子网中的一个（甚至大部分）副本。该技术有很多好处，包括：

1. 任何人都可以通过简单地验证签名来验证从互联网计算机接收的内容，而无需同步整个区块链。
2. IC的拓扑可以自主演化——可以添加新的节点和子网，可以恢复故障节点，可以自主升级协议。
3. 不可预测且无偏的罐伪随机数来源。容器可以安全地运行需要随机性的算法。



链锁密码学技术 （ Chain Key ）通过聚合签名，让子网节点产生一个唯一的公钥签名 ( 子网 key / Subnet Key ) 。这是 IC 无限扩展性能的基础技术。

每个子网可以看成是一个独立的 “ 小区块链 ” ，子网之间靠 Chain Key 通信。因为已经在子网内部达成共识了，所以只要通过 Chain Key 验证就行了。



每个子网根据 **root key** 生成自己的**子网公钥** ( 子网 key / Subnet Key ) ，子网之间通信依靠子网公钥验证数据的真实性，所以不用下载其他子网的旧区块数据，可以直接发请求过去。

>   子网 1 用自己的子网 key 对信息签名，然后发给子网 2 ，子网 2 收到信息后用子网 1 的 key 验证信息。
>
>   只要拿着某个子网 key ，就能随时随地验证这个子网上的信息是否正确。每个 key 只有 48 kb 。

root key 是公开的，客户端浏览器可以用 root key 验证消息是不是 IC 网络发过来的、有没有被篡改。



ChainKey 是互联网计算机背后的核心技术，它为 DFINITY 的区块链创建了一个只有48字节的唯一公钥。因此任何的设备，即使是智能手表，也能亲自去验证 DFINITY 的链。

相比之下，去验证 ETH 这些传统区块链时，因为每次出块都由不同的节点签名，设备需要同步几百 GB 的签名数据，而在 DFINITY 中，所有节点一起签名一个区块，因此设备只需要保存 48 个字节的唯一公钥即可验证每一个区块。

这只是 ChainKey 技术的冰山一角，它还能运行节点任意的退出与加入网络，从而轻松的把新节点接入网络进行扩容，这都归功于非交互式分布式密钥生成（Noninteractive Distributed Key Generation）技术的突破。

同时，每一个“子网/分片”都具备自己的唯一公钥，不同“子网/分片”上合约的互相调用，之需要使用这个“子网/分片”的公钥去验证它发来的区块消息即可，这就极大的优化了“片间/网间”的通讯问题。

如果能如此轻松的对区块链进行验证，那我们是不是能在其他的区块链上直接运行一个 DFINITY 的验证节点？没错，ChainKey 极易验证的特性也让 DFINITY 天然适合跨链操作，我们甚至可以在一个 ETH 的智能合约中存下 DFINITY 的区块链公钥，直接进行跨链交易的验证。这会带来大量的业务空间！



> 有一个简单的问题：所有的块都是永久存储的吗？

我们不依赖历史区块进行验证。所以每个副本只存储足够的块来保持网络健康（例如帮助其他副本赶上），并在不再需要时删除旧的。

这也是由于终结算法。一旦输入块最终确定，我们确信可以确定地计算新状态，并且只需要保持最新的容器状态。较旧的块和较旧的状态不是那么有用。



> 这里的关键创新是什么？ICC 协议如何或为什么比具有汇总和分片或类似协议的以太坊更好？

我认为子网实际上是共识的孤岛这一事实是主要的创新。有了链密钥，它们可以安全地相互通信，仍然形成一台互联网计算机，但因为不需要“全球”共识，我们可以通过添加子网来横向扩展。





接下来我用一个具体例子，讲解BLS签名法的工作原理:

假设我们有5个节点，每个节点被分配到一个秘钥片段x1，x2，...x5。其中x1+x2+...+x5=x，x就是完整的签名秘钥。

要签名一条消息M，第一步是计算出M的哈希值h。然后每个节点使用自己的秘钥片段计算一个中间签名:

节点1: σ1 = hx1
节点2: σ2 = hx2
...
节点5: σ5 = hx5

最后把这5个中间签名合并，就可以得到完整的签名:

σ = σ1 * σ2 * ... * σ5 = hx

验证签名时，只需要知道总的公钥:y = gx
然后检查签名是否满足:

h = σ^y

只要≥3个节点提供了正确的中间签名，结果就会通过验证。而单独一个节点的签名是不足以通过验证的。

这样，就实现了一个3-out-of-5的BLS Threshold Signature。它可以防止单个节点私自伪造交易，增强了区块链的安全性。同时，不需要所有节点每次都参与，也提高了效率。

这个BLS签名法用到一些数学知识，比如模运算、对数、哈希函数等，这对普通人来说可能还是有些难懂。但不用太纠结细节，简单理解为“把签名切片分发，必须聚集足够多片才能签名”就可以了。

区块链技术虽然看起来很神秘，但其实都是一些编程技巧和数学原理的组合。希望我用通俗的语言解释清楚了Threshold Signature的主要思路。这是让区块链更安全可靠的一种重要技术手段，也为之后讲解Chain Key的第二部分——Chain Evolution技术，奠定了基础。如果示例中某些地方还不太明白，可以提问我进一步解释。





好的，我来概述一下该网页里关于 Threshold ECDSA Signing 的主要内容:

Threshold ECDSA Signing 是一种分布式数字签名方案，可以在不露出私钥的情况下生成 ECDSA 签名。它基于 Shamir's Secret Sharing 技术，将私钥分成 N 个片段，分布在 N 个节点上。要生成签名，需要至少 T 个节点参与协作计算。

该方案的工作流程如下:

1. 将私钥通过 Shamir's Secret Sharing 分割成 N 个片段，分发给 N 个节点。
2. 当需要生成签名时，选择至少 T 个节点参与协作。这些节点互相交换信息，共同计算出签名。
3. 签名验证只需要公钥，不需要私钥片段。所以可以公开验证签名的正确性。
4. 即使攻击者获取了少数节点上的私钥片段，也无法恢复出完整的私钥。只有当攻击者同时控制了至少 T 个节点时，才可能合谋破坏签名或恢复私钥。

Threshold ECDSA可以防止单点故障，提高签名服务的可用性。也可以防止私钥被单一实体控制或泄漏。因此具有更好的安全性。

这是该网页里 Threshold ECDSA Signing 的主要内容概述。总体来说，它通过分布密钥、 Threshold 计算等手段，实现了安全可靠的分布式 ECDSA 签名方案。让数字签名服务更加可扩展、可用和安全。



> 可以再详细一些吗？多讲讲，1500字左右

好的，我来尝试对该网页中的Threshold ECDSA Signing做一个更加详细的概述:

Threshold ECDSA Signing是一种分布式签名方案，允许多个实体共同参与ECDSA数字签名的生成，而无需泄露私钥。它基于Shamir密钥分割方案，将ECDSA私钥分割成N个片段，分发给N个参与者。只有收集到至少T个片段，才能重构出原始私钥进行签名。

具体来说，Threshold ECDSA Signing的工作流程如下:

1. 设置参数:选择参与签名的节点数量N，以及需要多少节点才能重构私钥的阈值T。通常设置T<=N/2，即需要大多数节点才能签名。
2. 密钥生成:随机选择一个ECDSA私钥，使用Shamir密钥分割方案将其分割成N个片段，每个片段分发给一个节点。
3. 签名请求:当需要签名时，客户端向N个节点发出签名请求。
4. 节点交换信息:收到请求的节点互相交换信息，进行 Threshold ECDSA 签名协议的交互计算。这通过多轮广播和点对点通信实现。
5. 聚合签名:最终有至少T个节点将计算结果发送回客户端，客户端可以通过Lagrange 插值法恢复出ECDSA签名。
6. 验证签名:任何第三方只需要ECDSA公钥就可以验证签名的正确性，而无需知道私钥或其片段。

Threshold ECDSA Signing的安全性基于以下几点:

1. 单个节点无法在不知道其它节点的片段情况下生成签名。这通过零知识证明实现。
2. 收集少于T个分片无法重构私钥。根据Shamir秘密共享的属性。
3. 即使单个节点被攻破，也只能获取该节点上的单个分片，不影响整个私钥的安全。
4. 异步网络模型下也可以安全执行算法，防止攻击者利用时序攻击获取信息。

相比单点集中的ECDSA签名，Threshold ECDSA Signing解决了单点故障问题，具有更好的可用性。也解决了私钥容易被泄露或滥用问题，大大提高了安全性。适合构建大规模可扩展、可靠且安全的签名服务。

Internet Computer采用Threshold ECDSA Scheme来生成链上账户的公私钥对。私钥通过Threshold方式分割在多个节点，只有节点协作才能使用。这样既防止单个节点私钥泄露，又实现了高可用性。用户可以安全可靠地在链上进行交易和状态变更。

Threshold ECDSA Signing是一个活跃的研究课题，目前还有一些改进空间:

1. 进一步减少通信和计算复杂度。
2. 加入后量子算法安全机制，抵御量子计算机攻击。
3. 引入诚实多数计算模型，降低对节点作恶的要求。
4. 支持动态加入和退出节点，增加灵活性。
5. 丰富支持的曲线种类和签名算法。

综上所述，Threshold ECDSA Signing通过分布式密钥和多方计算技术，实现安全高效的数字签名。Internet Computer使用了该机制来增强链上账户安全性和系统可用性。这是一个值得进一步研究和应用的重要密码技术。



> 请详细讲解网页里的内容：https://internetcomputer.org/how-it-works/chain-key-technology/

好的，我来详细概述一下该网页里关于Internet Computer的链上密钥技术:

Internet Computer使用了独特的链上密钥生成和管理机制来增强安全性。其核心思路是:不再依赖单一集中实体来生成密钥，而是通过分布式多方计算的方式生成和管理链上密钥。

具体技术细节如下:

1. 引入了“区块链随机密钥生成(Blockchain Random Beacon，BRB)”机制。这依赖于VRF和Threshold ECDSA两种密码技术。
2. BRB在每个区块生成时都会产生一个随机数。该随机数依赖于当前区块的信息，而且无法预知。
3. 将BRB生成的随机数作为种子，可以派生出该区块对应的一批公私钥对。这批密钥可以分配给新创建的链上账户使用。
4. 密钥生成和签名都依赖 Threshold ECDSA 进行分布式计算。避免单点故障和攻击。
5. 整个过程不依赖任何中心化的证书机构或密钥管理机构。新的账户地址和公钥是链上根据协议算法动态生成的。
6. 可以为每个账户派生出用于治理、调用智能合约等多个密钥对。所有权通过链上验证来建立。
7. 支持密钥定期轮换。旧密钥对在到期后会失效，需要使用新的密钥对。
8. 链上 contract 代码也含有公钥。这可以验证 contract 调用者身份，防止篡改或滥用。

这样的设计相比传统的中心化密钥管理机制，有以下优势:

1. 去中心化，不依赖中心实体，更可靠和安全。
2. 动态派生密钥，而不是重用固定密钥，可以有效抵御量子计算攻击。
3. 支持密钥定期轮换，可以减轻密钥泄露的损害。
4. 基于区块链历史的数据生成密钥，保证随机性和不可预测性。
5. 采用多方计算生成密钥和签名，可以防止单点攻击和控制。
6. 简化账户和合约管理，不需要外部证书中心。

通过这种链上密钥技术的创新设计，Internet Computer实现了去中心化、安全、可靠的区块链计算平台。其安全性不依赖任何集中式密钥基础设施。这对于构建高度可扩展和可用的公共区块链具有里程碑意义。

当然，这种链上密钥技术也还有改进空间，未来可望支持更多类型密钥和算法，引入零知识证明进一步增强安全性，简化用户操作等等。但总体来说，这是区块链技术安全演进的重要一步。





好的，我来尝试更详细地解释Threshold Signatures中的BLS签名算法，并用更多示例帮助理解。

首先，我们假定有n个节点参与到区块链网络中，节点标记为P1，P2，...Pn。为了进行 Threshold Signature，我们需要为每个节点生成一对公私钥。

公钥是公开的，所有节点都可以获取。私钥则需要保密，只有对应的节点可以获取。公私钥生成算法是一个数学函数，输入是节点的标识，输出是公私钥对。例如:

P1 -> (PubKey1， PriKey1)
P2 -> (PubKey2， PriKey2) 

我们使用椭圆曲线加密算法来生成密钥对。不需要去了解细节，只需要知道用节点ID可以生成公私钥对就可以了。

一个区块链网络中会有多个公私钥对，但我们把所有节点的公钥合并，可以得到一个汇总的公钥PubKeyTotal。这就是该区块链的总公钥。

对应地，我们也可以计算一个总私钥PriKeyTotal，但是它是被分割成n份分别给每个节点保存的。例如3节点的情况:

P1 保存: PriKeyShare1
P2 保存: PriKeyShare2  
P3 保存: PriKeyShare3

其中PriKeyShare1 + PriKeyShare2 + PriKeyShare3 = PriKeyTotal

有了这些准备，我们可以签名了。假设有一个消息M需要签名。

第一步，计算消息M的哈希，得到H=Hash(M)。哈希算法也是一种数学函数，输入任意数据，输出一个数字指纹。

第二步，每个节点使用自己的私钥份额对哈希值H进行签名。例如在3节点的网络中:

P1 计算: Signature1 = Sign(H， PriKeyShare1) 
P2 计算: Signature2 = Sign(H， PriKeyShare2)
P3 计算: Signature3 = Sign(H， PriKeyShare3)

Sign函数输入是消息哈希和私钥，输出是签名。

第三步，收集签名并合并，得到总签名:

SignatureTotal = Signature1 + Signature2 + Signature3

这里的加法是一种特殊的Group加法，不过不用关心细节。

最后一步，任何人使用公钥PubKeyTotal来验证这个签名:

Verify(H， SignatureTotal， PubKeyTotal)

只要其中至少2个节点提供了正确的签名份额，总签名就是有效的。

这样我们就实现了一个2-out-of-3的BLS阈值签名!

这个过程可以扩展到任意多的节点。我们设置一个阈值t，要求至少t个节点参与签名才生效。那么就实现了一个t-out-of-n的阈值签名。

这么做的好处是，不能单独通过一个节点就完成签名，需要足够多节点参与，才能通过验证，这样可以防止单个节点私自伪造交易，保证了区块链的安全。

另外，不需要让所有节点每次都签名，这样也提高了效率。

接下来通过一个更复杂的例子进一步理解Threshold Signature。

假设我们要开发一个区块链游戏，有100个节点加入了网络，记为P1到P100。 

根据游戏规则，我们决定进行一个 60-out-of-100 的阈值签名。这意味着每次至少需要60个节点参与签名，结果才会生效。

第一步，为每个节点生成公私钥对:

P1 -> (PubKey1， PriKey1)
...
P100 -> (PubKey100， PriKey100)

第二步，计算总公钥:

PubKeyTotal = PubKey1 + PubKey2 + ... + PubKey100

第三步，为每个节点生成私钥份额:  

P1得到: PriKeyShare1
...
P100得到: PriKeyShare100

其中PriKeyShare1 + ... + PriKeyShare100 = PriKeyTotal

现在消息M需要签名:

1. 计算哈希 H = Hash(M)

2. 每个节点对H签名，得到Signature1...Signature100

3. 收集60个签名份额，进行组合

SignatureTotal = Signature1 + ... + Signature60

4. 使用公钥PubKeyTotal验证签名

可以看到，这种方式可以扩展到成百上千个节点，我们只需要调整阈值参数，就可以要求不同数量的节点签名。

这样就可以灵活地在去中心化和效率之间进行平衡。

BLS签名算法看上去比较复杂，涉及到一些高深的数学知识。但基本思路就是“分割秘钥 —— 分发给节点 —— 重组签名”，这种分布式协作的模式，可以带来区块链网络的安全性。

当然，BLS算法也有一些问题需要注意:

1. 生成和分发密钥需要一个可信的中心节点。这引入了一定的中心化。

2. 签名验证需要知道总公钥，这带来了公钥管理问题。

3. 分布式签名计算还是有一定性能消耗。

后续的研究正在致力于解决这些问题，使Threshold Signature更实用。但基本思想已经被证实是行之有效的。

区块链技术综合运用了密码学、分布式系统等多门学科。想完全掌握还需要长期学习。我在这里尽量用浅显的语言和实例讲解阈值签名的思路和原理，希望可以帮助你建立正确的认知模型。

当然我的解释可能还存在误解或不准确的地方，如果你在理解中遇到困惑，请一定要提出来讨论。只有多问问题、主动思考，我们才能真正掌握知识。





好的，来讲讲Chain Key中的第二部分——Chain Evolution Technology。

Chain Evolution Technology由两部分组成:Summary Blocks和Catch-up Packages(CUP)。它们的作用是帮助区块链平滑地进行链上变更和升级。

什么是链上变更和升级呢?区块链网络在运行过程中，参与的节点可能会增加或离开，算法也需要不断优化。这就需要对区块链状态进行动态调整。

如果不考虑Compatibility，直接在链上做Hard Fork，势必会造成不同版本链之间的分叉。这对去中心化网络是灾难性的。

所以我们需要能够平滑地做到Backward Compatibility，也就是新老版本链可以兼容和重叠运行。这需要一套精心设计的链上变更机制，即Chain Evolution Technology。


先来看Summary Blocks，顾名思义，它存储每轮的链上摘要数据。主要包含以下信息:

1. 当前子网的成员节点列表

2. 用于链上签名的公钥信息 

3. 链上升级的版本号

4. 随机数种子

5. 一些其它元数据


将这些关键信息汇总到Summary Block中，具有以下好处:

1. 新节点可以快速同步链状态，不需要从创世块全部执行一次。

2. 旧版本节点可以验证Summary Block的签名，安全地与新版本交互。

3. 关键参数集中管理，便于链上治理和升级。

可以看出，Summary Blocks在平滑地进行链上变更中起了“锚点”的作用。新老版本链都可以参照这个汇总数据进行交互和状态迁移。

接下来看另一部分——Catch-up Packages (CUP)。

CUP包含当前阶段完整的链状态快照。具体来说，包含:

1. 该阶段所有链数据的Merkle树根

2. 对应的Summary Block

3. 随机数种子

4. 签名信息


当新节点加入网络时，可以请求CUP来快速同步状态，而不需要从创世块开始执行全部交易。

当旧版本节点需要升级时，也可以用CUP安全地切换到新版本链上。

可以看到，CUP进一步增强了版本链的兼容性和平滑迁移。新节点和旧节点都可以依据CUP快速安全地同步状态。

总结一下，Chain Evolution Technology启用了Summary Blocks和CUP这两个锚点机制，通过存储关键参数、链状态快照等数据，帮助不同链版本之间进行兼容和平滑迁移。

这就避免了Hard Fork在去中心化网络中的大量问题，确保了区块链平台的持续演进。

当然，Chain Evolution也存在一些限制:

1. 提取和签名链状态快照需要额外计算开销。

2. 需要链上治理协议来管理和发布新的Summary Blocks。

3. 不足以应对全部的链上变更场景。

这仍是一个活跃的研究领域，我们需要更多实践来完善链上变更的技术方案。

但Chain Evolution Technology无疑是迈向实用和演进的区块链的重要一步。它为链上参数调整、节点迁移、算法升级等提供了基础框架。

相信随着技术的进一步成熟，区块链平台会变得越来越易用和灵活，才能真正被广泛应用起来。













阈值签名

链钥密码学的第一个组成部分是阈值签名：阈值签名是一个成熟的加密技术，它允许子网拥有一个公共的验证签名密钥，对应的签名私钥分成片段分配给子网中的节点副本，而分配保证作恶节点无法伪造任何签名，而诚实节点拥有的私钥片段可以允许子网生成符合IC原则和协议的签名。

这些阈值签名的一个关键应用在于一个子网的单独输出可以由另一个子网或是外部用户进行验证，验证可以简单地利用该子网（第一个子网）的公共验证签名密钥来验证电子签名实现。

需要注意的是，子网的公共验证签名密钥可以从NNS中获取—该公共验证签名密钥在子网的生命周期中保持不变（即使子网的成员在该生命周期中可能发生变化）。这与许多不可扩展的区块链协议形成鲜明的对比，其需要验证整个区块链来验证单个输出。



正如我们所看到的，这些阈值签名在IC中还有许多其他应用。一个应用于让子网中的每个节点副本可以访问无法预测的伪随机数位（衍生于此类阈值签名）。这是共识层使用的随机信标和执行层使用的随机磁带的基础。

为了安全地部署阈值签名，IC采用了创新性的分布式密钥生成（以下简称DKG）协议，来构建公共签名验证密钥，并为每个节点副本提供对应签名私钥的一个片段，用于我们的故障和通信模型。



链钥密码学也包括一系列复杂的技术，用于随时间推移健壮和安全地维护基于区块链的复制状态机，合起来我们称之为链演进技术。每个子网在包含多轮（通常大约是几百轮）的时期（Epoch）内运行。利用阈值签名和其他一些技术，链演技术实现了许多按时期定期执行的基本维护工作：

**垃圾回收**：在每一时期的末尾，所有已经被处理的输入以及所有排序这些输入所需要的共识层消息，可以安全地从每个节点副本的内存中清除。这对防止对于节点副本的存储需求的无限增长至关重要。这也与许多不可扩展的区块链协议形成对比，它们必须存储从创世区块开始的整个区块链。

**快速转发**：如果一个子网中的节点副本大幅落后于其同步节点（因为其宕机或是网络断连很长时间），或是一个新的节点副本被添加入子网，他们可以通过快速转发至最新时期的起始点，不需要运行共识协议并处理该点之前的所有输入。这也与许多不可扩展的区块链协议形成对比，它们必须处理从创世区块开始的整个区块链。

**子网成员变更**：子网的成员（由NNS决定，详见章节1.5）可能会随着时间变化。这仅可能发生在时期的边缘，需要小心操作以确保一致且正确的行为。

**主动秘密再共享**：我们在上面的章节1.6.1中提到 IC 是如何使用链钥密码学——具体来说，阈值签名——来进行输出验证。它基于的就是**秘密共享**，通过将一个秘密（在这里就是签名私钥）拆分成片段分别存储在节点副本中，从而避免了任何单点故障。在每个时期开始时，这些片段都会被**主动再共享**。这实现了两个目标：

* 当一个子网的成员发生变动时，再共享可以确保任何新成员都有相应的秘密片段，而任何不再是成员的节点副本就不再会拥有秘密片段。

* 如果在任意一个时期，甚至每个时期都有少量的秘密片段被泄露给攻击者，这些片段也不会帮助到攻击者。

**协议升级**：如果IC协议本身需要升级，修复漏洞或是增加新功能，可以在时期开始时通过特殊协议（CUP）自动完成。





再共享协议

基础DKG协议可以被很容易地修改，因此不需要创建一个新的随机密钥$x$的共享，而是创建一个先前共享密钥的新随机共享。

- 修改基础协议的第1步，以便每个节点可以广播已有共享片段的已签名dealing
- 修改第2步，以便就$t$个有效的已签名dealing集合达成共识。此外，每个dealing都经验证以确保是现有共享片段的dealing（这意味着在第$i$个dealing中$A_{i，0}$的值应当等于$V_i$的旧值）。
- 第3步中，通过计算$i$个拉格朗日插值系数的和（和乘积），等于新的$x_j$（和$V_j$）。





**垃圾回收：**因为CUP包含特定时期的信息，因此每个节点副本可以安全地清除该时期前所有已处理的输入，以及对这些输入排序的共识层消息。

**快速转发：**如果一个子网中的节点副本大幅落后于其同步节点（因为其宕机或是网络断连很长时间），或是一个新的节点副本被添加入子网，他们可以通过快速转发至最新时期的起始点，不需要运行共识协议并处理该点之前的所有输入。该节点副本可以通过获取最新CUP做到。利用从CUP中包含的摘要块和随机信标，以及来自其他节点副本的（还没有被清除的）共识消息，该节点副本可以从相应时期的起始点开始，向前运行共识协议。该节点也可以使用状态同步子协议来获取对应时期开始时的复制状态，这样它也可以开始处理共识层产生的输入。

图5描绘了快速转发。此处，我们假设需要一个需要追赶的节点副本处于时期起始点，（比方说）块高为101，有一个CUP。这个CUP包含了块高101的复制状态的默克尔树的根，块高101的摘要块（绿色标识）和块高101的随机信标。该节点会使用状态同步子协议，从它的对等节点中获取块高101的所有复制状态，并用CUP中的默克尔树来验证此状态。在获取到该状态后，节点副本可以参与到协议之中，从对等节点中获取块高102，103等等的区块（以及其他和共识相关的消息），并更新其复制状态的副本。如果其对等节点已经确认了更高高度的区块，该节点副本将尽快处理（以及公证和最终确认）这些从对等节点获取的已最终确认区块（以执行层所允许的最快速度）。

<img src="assets/1.ChainKey/图5：快速转发.png" alt="截屏2022-02-13 23.36.57" style="zoom:80%;" />

<center>图5：快速转发</center>

**子网成员变更：**我们已经讨论过特定时期内，如何使用摘要块来加密，使用哪个版本的注册表以及它如何决定子网成员，更具体来说，是各种任务的委员会成员。需要注意的是，即使一个节点副本从一个子网中移除，（如果可能的话）它应当额外履行一个时期的所分配到的委员会职责。

**主动秘密再共享：**我们已经讨论过了，如何使用摘要块生成和转发签名密钥。如有必要，需要的摘要块也可以从CUP中获取。

**协议升级：**CUP 也可用于协议升级。协议升级由 NNS 发起（详见[章节1.5](#1.5 权限模型)）。不考虑所有细节，基本细节如下：

- 当需要安装新版本的协议时，时期开始时的摘要块会做出指示；
- 所有运行老版本协议的节点副本，将继续运行共识协议直到最终确认摘要块并创建对应的CUP；然而，他们只会创建空区块，并不会将任何荷载传递给消息路由层和执行层；
- 安装新版本的协议后，运行新版本共识协议的节点副本，将从上述的CUP开始继续运行完整的协议。













链密钥签名

链密钥签名扩展了链密钥技术，允许针对其他区块链的交易在链上使用 Internet Computer 协议完全计算。通过链密钥签名，IC 可以与比特币和以太坊等其他区块链完全无信任地集成，无需任何桥接。Canister 现在可以安全地存储和交易比特币。比特币的私钥在运行 Canister 的所有节点之间共享。当至少三分之二的节点同意进行交易时，Canister 可以使用链密钥签名的交易进行比特币交易。事实上，使用链密钥签名是整合区块链的最强大、最分散的方式，因为除了两个区块链之外，不需要任何其他信任假设，尤其是不需要管理签名密钥或其份额的其他方。



比特币整合

Internet Computer 上的比特币整合基于两个支柱：链密钥签名和 Internet Computer 节点与比特币对等网络之间的直接互动。虽然链密钥签名使 Canister 可以拥有自己的比特币地址并创建有效的交易，用于支付这些地址持有的比特币，但 Internet Computer 和比特币网络之间的直接消息交换用于在 Internet Computer 中维护关于比特币区块链状态的信息（如地址余额），并将 Canister 发起的比特币交易传输到比特币网络。



链密钥代币

链密钥代币 —— 以及链密钥比特币（ckBTC）—— 是一种基于密码学的替代包装代币，具有强大的去中心化优势：链密钥代币消除了传统基于中介的代币包装所带来的风险，同时还具有使来自其他区块链的代币可用于转账和交易的优势。链密钥密码学使这成为可能：以比特币为例，Canister 智能合约可以拥有 ECDSA 密钥对，并派生出可以在比特币网络上进行真实比特币转账的比特币地址。当接收到比特币时，Canister 以 1:1 的比例向比特币的发送者铸造并发行 ckBTC。相反，兑换 ckBTC 为基础比特币会将 ckBTC 从流通供应中移除并退还比特币。这使得链密钥代币成为具有相同属性和估值的原始代币的“双胞胎”，但托管在 Internet Computer 上。







这段文字详细介绍了一个阈值签名方案及其匹配的分布式密钥生成协议，包括各种算法。阈值签名方案的目标是防止未授权签名，确保只有达到阈值的参与者共同参与签名过程。

在安全性定义中，诚实的参与者可以生成新的公钥，这些公钥对敌手是公开的。我们假设公钥具有足够的熵以唯一标识参与者。敌手可以在满足某些条件的情况下，要求参与者更新解密密钥。

参与者有时会创建新的阈值签名验证密钥，并分配相应的签名密钥份额。敌手可以决定何时创建新的验证密钥，但需要提供一个参与者配置以及阈值和纪元。此外，敌手可以触发诚实的交易创建，模拟诚实参与者运行交易算法。所有诚实的交易都包含在 Qd 集合中。

之后，敌手可以将诚实的交易与自己的任意交易组合，生成一个让互联网计算机识别的新公钥。在安全性定义中，我们要求敌手在交易记录中至少包括一个诚实的交易。如果交易记录被接受，交易将组合导出一个验证密钥，该密钥将注册在 Qvk 中。

参与者有时还希望重新共享现有的秘密阈值签名密钥。在这种情况下，敌手也需要创建一个配置，但这次配置必须引用先前的配置和它所依赖的现有公钥的交易记录。被诚实节点处理的分享签名密钥也会被记录。

诚实的参与者可以使用分享签名密钥为任意消息提供签名份额。在我们的模型中，我们让敌手控制何时以及哪个参与者为哪个消息签名。

在互联网计算机上，诚实的参与者会在分享签名密钥过时时擦除它。当然，只有在参与者无法再通过解密密钥恢复分享签名密钥时，擦除才有意义。因此，我们只允许敌手要求擦除无法再次被诚实参与者恢复的分享签名密钥。

最后，我们的安全模型旨在捕获动态腐败，因此我们允许敌手腐化参与者。每当敌手腐化一个参与者时，她会了解到该参与者拥有的所有相关数据，如解密密钥和所有未擦除的份额。此后，与该参与者有关的记录将被删除，因为模型只记录诚实参与者，而敌手现在可以代表该参与者行动。

