https://www.reddit.com/r/dfinity/comments/nlymmu/ama_we_are_the_dfinity_crypto_and_research_team/

https://medium.com/dfinity/chain-key-technology-one-public-key-for-the-internet-computer-6a3644901e28

https://internetcomputer.org/how-it-works/chain-key-technology/



# 链钥密码学（Chain-key cryptography）

IC的共识协议确实使用了区块链，但它也采用了公钥加密技术，特别是电子签名：NNS维护的注册表用于将公钥绑定至节点副本及子网形成一个整体。这实现了一个独一无二的强大技术集合，我们称之为**链钥密码学**，它有几个组成部分。



# 阈值签名

链钥密码学的第一个组成部分是阈值签名：阈值签名是一个成熟的加密技术，它允许子网拥有一个公共的验证签名密钥，对应的签名私钥分成片段分配给子网中的节点副本，而分配保证作恶节点无法伪造任何签名，而诚实节点拥有的私钥片段可以允许子网生成符合IC原则和协议的签名。

这些阈值签名的一个关键应用在于一个子网的单独输出可以由另一个子网或是外部用户进行验证，验证可以简单地利用该子网（第一个子网）的公共验证签名密钥来验证电子签名实现。

需要注意的是，子网的公共验证签名密钥可以从NNS中获取—该公共验证签名密钥在子网的生命周期中保持不变（即使子网的成员在该生命周期中可能发生变化）。这与许多不可扩展的区块链协议形成鲜明的对比，其需要验证整个区块链来验证单个输出。



## BLS阈值签名

### 秘密共享

### 拉格朗日插值



正如我们所看到的，这些阈值签名在IC中还有许多其他应用。一个应用于让子网中的每个节点副本可以访问无法预测的伪随机数位（衍生于此类阈值签名）。这是共识层使用的随机信标和执行层使用的随机磁带的基础。

为了安全地部署阈值签名，IC采用了创新性的分布式密钥生成（以下简称DKG）协议，来构建公共签名验证密钥，并为每个节点副本提供对应签名私钥的一个片段，用于我们的故障和通信模型。



链钥密码学也包括一系列复杂的技术，用于随时间推移健壮和安全地维护基于区块链的复制状态机，合起来我们称之为链演进技术。每个子网在包含多轮（通常大约是几百轮）的时期（Epoch）内运行。利用阈值签名和其他一些技术，链演技术实现了许多按时期定期执行的基本维护工作：

**垃圾回收**：在每一时期的末尾，所有已经被处理的输入以及所有排序这些输入所需要的共识层消息，可以安全地从每个节点副本的内存中清除。这对防止对于节点副本的存储需求的无限增长至关重要。这也与许多不可扩展的区块链协议形成对比，它们必须存储从创世区块开始的整个区块链。

**快速转发**：如果一个子网中的节点副本大幅落后于其同步节点（因为其宕机或是网络断连很长时间），或是一个新的节点副本被添加入子网，他们可以通过快速转发至最新时期的起始点，不需要运行共识协议并处理该点之前的所有输入。这也与许多不可扩展的区块链协议形成对比，它们必须处理从创世区块开始的整个区块链。

**子网成员变更**：子网的成员（由NNS决定，详见章节1.5）可能会随着时间变化。这仅可能发生在时期的边缘，需要小心操作以确保一致且正确的行为。

**主动秘密再共享**：我们在上面的章节1.6.1中提到 IC 是如何使用链钥密码学——具体来说，阈值签名——来进行输出验证。它基于的就是**秘密共享**，通过将一个秘密（在这里就是签名私钥）拆分成片段分别存储在节点副本中，从而避免了任何单点故障。在每个时期开始时，这些片段都会被**主动再共享**。这实现了两个目标：

* 当一个子网的成员发生变动时，再共享可以确保任何新成员都有相应的秘密片段，而任何不再是成员的节点副本就不再会拥有秘密片段。

* 如果在任意一个时期，甚至每个时期都有少量的秘密片段被泄露给攻击者，这些片段也不会帮助到攻击者。

**协议升级**：如果IC协议本身需要升级，修复漏洞或是增加新功能，可以在时期开始时通过特殊协议自动完成。









签名

数字签名方案是一种非常传统的公钥密码系统，其中私钥（仅由签名者持有）用于在消息上生成数字签名，公钥（对所有人可用）可以用于高效地验证消息上的数字签名。这种方案实现的基本安全属性是，无法在不明确调用相应私钥的签名算法的情况下创建消息上的有效签名。

阈值签名方案是一种数字签名方案，其中签名密钥从不存储在一个位置（这将成为单点故障）。相反，私钥实际上被拆分成秘密份额，每个秘密份额存储在不同的计算机上。要签署消息，这些计算机必须同意签署消息，并以分布式方式协调彼此以生成数字签名（重要的是，不要在一个位置重建私钥签名密钥）。

链密钥技术

虽然阈值签名方案是一种存在已久的技术，但 IC 是第一个将此技术完全整合到其设计核心的区块链。如上所述，这项技术实现了链密钥加密及其所有优点——有效验证区块链输出、IC 拓扑的自主演变、为容器提供不可预测且不可偏见的伪随机数源。

IC 中的每个子网都与此类阈值签名方案的公共验证密钥关联。

最重要的是，这个公钥可以用于验证 IC 的输出，包括来自外部用户的入口消息的响应，以及一个容器到另一个容器的消息。这是 IC 和其他区块链之间的根本区别：其他区块链的状态只能通过从创世区块运行整个协议来验证，而在 IC 上，只需验证单个数字签名即可。因此，这是实现互联网计算机空前可扩展性的关键技术之一。
该公钥还用于定期验证子网的整个状态，从而实现诸如向子网添加新节点以及使崩溃节点快速追赶上其他节点等功能。这提高了 IC 的可扩展性，并对实现 IC 拓扑在 NNS 的指导下随时间自主演进至关重要。
此外，这些阈值签名还用作创建不可预测伪随机数的来源，这在两方面有所应用：

作为任何智能合约可用的不可预测且不可偏见的伪随机数来源，这是区块链世界中的一个独特功能，使得在其他区块链上无法实现的应用成为可能（例如，NFT 抽奖）；
作为 IC 共识协议中伪随机选择领导者的机制，这增强了共识的效率和公平性。



实施

IC实现的阈值签名方案是著名的BLS签名方案的阈值版本。使用BLS签名方案的一个原因是，它是唯一能产生非常简单且高效的阈值签名协议的签名方案。实际上，持有私钥份额的机器可以非常轻松地生成对某个消息的签名份额，这些签名份额可以组合成对该消息的BLS签名——这些机器之间不需要进一步交互。

使用BLS签名方案的另一个原因是签名是唯一的，这意味着对于给定的公钥和消息，只有一个有效的签名。这种唯一签名属性对于为智能合约生成不可预测且无偏差的伪随机数至关重要：在智能合约请求伪随机数之后（而不是之前！），会生成对特殊消息的签名，然后通过哈希函数将此签名传递，以从中导出种子，然后从种子中生成所需的伪随机数。根据签名方案的安全特性，无法预测或偏置这个种子或衍生的伪随机数。

尽管使用阈值BLS签名相当简单，但设计一个安全的、去中心化的协议来生成和分发私钥份额——即一个分布式密钥生成（DKG）协议——仍然具有挑战性。尽管已经有很多关于DKG设计的研究，但文献中的绝大多数DKG协议都无法满足互联网计算机（IC）的高要求，因为它们要么假设一个同步网络（这意味着如果消息意外延迟，协议将失败或变得不安全），要么没有健壮性（这意味着如果一个节点崩溃，产生签名的能力就完全丧失），或者两者兼有。在IC上，这些假设都是不可接受的：即使在一个有许多故障节点的异步网络中，安全性和生存性也必须保持。

DFINITY已经设计、分析并实现了一种新的DKG协议，该协议在异步网络上运行且具有很高的健壮性（即使子网中多达三分之一的节点崩溃或损坏，它仍然可以成功），同时仍然能够提供可接受的性能。除了生成新密钥外，此协议还可用于重新共享现有密钥。此功能对于实现IC拓扑的自主演进至关重要，因为子网随着时间推移会发生成员变化。











# 链钥密码学I：阈值签名

IC的链钥密码学的一个关键组成部分是阈值签名方案[[Des87]](#Des87)。IC在多处应用了阈值签名。假设子网中的节点副本数量为$n$，故障节点数量上限为$f$。

- 共识层使用$(f+1)/n$的阈值签名来实现随机信标（详见[章节5.5](#5.5 随机信标 )）。
- 执行层使用$(f+1)/n$的阈值签名来实现随机磁带，用于向容器提供不可预测的伪随机数（详见[章节7.1](#7.1 随机磁带)）。
- 执行层使用$(n-f)/n$的阈值签名来认证复制状态。这既用于验证子网的输出（详见[章节6.1](#6.1 每轮认证状态)），也用于实现IC链演进技术中的快速转发功能。（详见[章节8.2](#8.2 CUPs)）

对于前两个应用（随机信标和随机磁带），阈值签名必须是唯一的，即给定公钥和消息，仅有一个有效签名。因为我们使用签名作为随机数生成器的种子，所有计算该阈值签名的节点副本必须对相同的种子达成共识。

## BLS阈值签名

我们基于BLS签名方案实现了阈值签名[[BLS01]](#BLS01)，使得调整阈值设定十分简单。

普通的BLS签名方案（即非阈值）利用两个质数阶均为$q$的群$\mathbb{G}$和$\mathbb{G}'$。我们假设$\mathbb{G}$通过基准点$g\in\mathbb{G}$生成，$\mathbb{G}'$通过基准点$g'\in\mathbb{G}'$生成。我们同样假设一个哈希函数$H_{\mathbb{G}'}$可以将其输入映射到$\mathbb{G}'$（一个随机预言机模型）。签名私钥元素$x\in\mathbb{Z}_q$，公共验证密钥$V$:= $g^x\in\mathbb{G}$。

非阈值的设定下，为对消息$m$签名，签名人计算$h'\leftarrow H_{\mathbb{G}'}(m)\in\mathbb{G'}$，然后计算签名$\sigma$:= $($h$')^x\in\mathbb{G}$。为验证签名是否有效，必须检验$log_{$h$'}\sigma$是否等于$log_gV$。为了高效地执行检验，BLS方案在群$\mathbb{G}$和$\mathbb{G}'$上使用了**配对**的概念，这是一种特殊的代数工具，当$\mathbb{G}$和$\mathbb{G}'$是特殊类型的**椭圆曲线**时可用。我们无法在这里详细介绍配对和椭圆曲线。更多细节详见[[BLS01]](#BLS01)。BLS签名具有签名唯一这一良好的特性（如上所述）。

在$t/n$的阈值设定下，我们有$n$个节点副本，其中任意$t$个都可以用于生成消息的签名。更具体来看，每个节点副本$P_j$私下持有签名密钥$x\in\mathbb{Z}_q$的一个片段$x_j\in\mathbb{Z}_q$，而群元素$V_j$:=$g^{x_j}$公开可用。密钥片段$(x_1,...,x_n)$是$x$的$t/n$秘密共享（详见[章节3.4](#3.4 PVSS方案)）。

给定消息$m$，节点副本$p_j$可以生成**签名片段**
$$
\sigma_j=(h')^{x_j}\in\mathbb{G}'
$$
与之前一样，$h':=H_{\mathbb{G}'}(m)$。为了验证这样的签名片段是否有效，必须检验$log_{h'}\sigma_j$是否等于$log_gV_j$。如上所述，这可以通过配对来完成—事实上，这和用公钥$V_j$验证普通BLS签名有效性完全一样。

这一阈值签名方案满足如下的**重构特性：**

给定消息$m$的任意$t$个有效签名片段$\sigma_j$的集合（由不同的节点副本提供），我们可以高效得计算出公共验证密钥下，消息m的有效BLS签名$\sigma$。

事实上，$\sigma$可以按如下公式计算

$$
\displaystyle \sigma\leftarrow\prod_{j}\sigma^{\lambda_j}_j\tag{1}
$$
*其中，$\lambda_j$可由签名该消息m的t个节点副本的索引，高效地计算出来。*

在$\mathbb{G}$的合理难度假设下，将$H_{\mathbb{G}'}$建模成随机预言机，这一方案可以满足如下的**安全性**：

假设最多有$f$个节点副本被敌对方破坏。它也无法计算出消息的有效签名，除非他获取了至少$t-f$个诚实节点副本对该消息的签名片段。



## 分布式密钥分发

为了实现BLS阈值签名，我们需要一种分发签名私钥给节点副本的方法。一种实现方法是让一个**可信方**直接计算所有这些私钥片段并分发给所有的节点副本。不幸的是，这可能会造成单点故障。相反，我们使用了**分布式密钥生成（以下简称DKG）协议**，它本质上允许节点副本在安全的分布式协议下，执行此类可信方的逻辑。

我们概述了当前实现的协议的顶层思想。推荐读者阅读[[Gro21]](#Gro21)了解更多细节。我们使用的DKG本质上是非交互式的。它有两个基本组成部分：

- **公开可验证秘密共享（以下简称PVSS）**方案，和
- **共识**协议。

尽管任何共识协议都适用，但毫无疑问我们使用了[第5章](#5 共识层)（也可见[第八章](#8 链钥密码学Ⅱ：链演进技术)）中的协议。

## 假设

所做的基本假设和[第一章](#1 引言)中所概述的一致：

- 异步通信，和
- $f<n/3$。

我们仅仅（在[章节5.1](#5.1 假设)中）间接地使用了*部分*同步假设，来确保共识协议的活性。

对于一个t/n的阈值签名方案，我们还假设

$$
f<t\leq n-f
$$
这（除了其他方面外）确保了（1）故障节点副本们无法独立地签名，和（2）诚实的节点副本们可以独立地签名。

我们还假设每个节点副本和一些公钥相关联，其中每个节点持有这些公钥的对应私钥。一个公钥是签名密钥（同[章节5.4](#5.4 公钥)中一样）。另一个公钥是公共加密密钥，用于实现PVSS方案的特殊公钥加密方案（详细方案如下）。



## PVSS方案

如上所述，假设$\mathbb{G}$通过基准点$g\in\mathbb{G}$生成的质数阶为q的群。假设$s\in\mathbb{Z}_q$是私钥。回想一下，阈值结构为$t/n$下，密钥s的Shamir密钥共享是向量$(s_1,...,s_n)\in\mathbb{Z}_q^n$，其中

$$
s_j:=a(j)\ \ (j=1,...,n)
$$
而

$$
a(x):=a_0+a_1x+...+a_{t-1}x^{t-1}\in\mathbb{Z}_q[x]
$$
是次数小于$t$的多项式，其中$a_0:=s$。该类密钥共享方案的关键属性是

- 根据$t$个$s_j$的集合，我们可以（多项式插值）有效地计算密钥$s=a_0=a(0)$，和
- 如果从$\mathbb{Z}_q$中一致且独立得抽取$a_1,...,a_{t-1}$，任意少于$t$个元素的集合都无法披露密钥$s$的任何信息。

&emsp;&emsp;在更高层面上，PVSS方案允许节点副本$P_i$，在此称为**dealer**，进行密钥共享并计算称为**dealing**的对象，其中包括

- 群元素向量$(A_0,...,A_{t-1})$，其中$A_k:=g^{a_k}$对于$k=0,...,t-1$，
- 密文向量$(c_1,...,c_n)$，其中$c_j$是$P_j$的公共验证密钥下对$s_j$的加密，
- 非交互式的零知识证明$\pi$，证明每个节点副本$c_j$确实加密了密钥片段—更准确地说，每个密文$c_j$解密的值$s_j$满足

$$
\displaystyle g^{s_j}=\prod^{t-1}_{k=0}A_k^{j^k}=g^{a(j)}\tag{2}
$$

我们注意到，为了确保DKG协议的整体安全性，PVSS方案必须提供适当级别的所选密文安全性。具体来说，dealer必须将其身份作为关联数据嵌入dealing，并且加密的共享片段必须要保持隐匿，即使是在选择密文攻击中，敌对方可以用与创建dealing无关的关联数据，解密任意dealing。

如果不考虑效率问题，实现PVSS方案很容易。方案中利用类似ElGamal的加密方案，对每个$s_j$逐位加密，然后对公式[（2）](#GS2)使用标准的非交互式零知识证明，该证明基于对相应的Sigma协议(详见[[CDS94])](#CDS94)应用标准的Fiat-Shamir转换(详见[[FS86])](#FS86)实现。尽管这产生了一个多项式时间的方案，但是并不实用。然而，有很多可能的方法来优化这个类型的方案。关于IC中使用的高度优化的PVSS方案，详见[[Gro21]](#Gro21)。



## 基础DKG协议

使用PVSS方案和共识协议，基础的DKG协议十分简单。

1. 每个节点副本向其他节点副本广播关于随机密钥的**已签名dealing**。

  这样的已签名dealing包括一个dealing主体，dealer身份以及dealer公钥下对该dealing的签名。

  如果语法格式正确，签名和非交互式的零知识证明有效，那么这样的签名dealing是有效的。

2. 利用共识协议，节点副本对$f+1$的有效的已签名dealing集合$S$达成共识。

3. 假设集合$S$中的第$i$个dealing包含群元素向量$(A_{i,0},...,A_{i,t-1})$和密文向量$(c_{i,1},...,c_{i,n})$。

&emsp;&emsp;然后阈值签名方案的公共验证密钥是

$$
\displaystyle V:=\prod_iA_{i,0}
$$
注意，签名私钥被隐式定义

$$
x:=log_gV
$$
副本$P_j$的签名私钥x的片段为

$$
\displaystyle x_j:=\sum_i s_{i,j}
$$
其中$s_{i,j}$是$p_j$的解密私钥下对$c_{i,j}$的解密。

副本$P_j$的公共验证密钥是

$$
\displaystyle V_j:=\prod_i \prod^{t-1}_{k=0}A_{i,k}^{j^k}=g^{x_j}
$$
需要注意的是，密钥片段$x_j$包含$x$的阈值结构为$t/n$的Shami密钥共享。因此，公式[（1）](#GS1)中出现的只是拉格朗日插值系数。这证实了[章节3.1](#3.1 BLS阈值签名)中提到的*重构特性*。至于中[章节3.1](#BLS阈值签名)提及的安全性，可被如下证明，在$H_{\mathbb{G}'}$建模成随机预言机的情况下，假设PVSS方案是安全的，群$\mathbb{G}$和$\mathbb{G}'$（通过配对）满足**one-more Diffie-Hellman**的特定类型的难度假设，即不存在有效的对手方，有概率赢得下面的博弈：

挑战者随机选择$\mu_1,...,\mu_k\in\mathbb{Z}_q$和$v_1,...,v_l\in\mathbb{Z}_q$，将给到对手方$\{g^{\mu_i}\}^k_{i=1}$和$\{(g')^{v_j}\}^l_{j=1}$ 

对手方向挑战者发起一系列查询请求，每一个请求都是$\{k_{i,j}\}_{i,j}$形式的向量，挑战者回应对应的

$$
\displaystyle \prod_{i,j}((g')^{\mu_iv_i})^{k_{i,j}}
$$
为结束这场博弈，对手方输出向量$\{\lambda_{i,j}\}_{i,j}$和群元素$h'\in\mathbb{G}'$，并将赢得博弈如果

$$
h'\displaystyle =\prod_{i,j}((g')^{\mu_iv_i})^{\lambda_{i,j}}
$$
并且输出向量$\{\lambda_{i,j}\}_{i,j}$不是请求向量的线性组合。

尽管当$t>f+1$的情况下，需要这类one-more Diffie-Hellman假设，但是当$t=f+1$的情况下，可以采用较弱的假设(即所谓的co-CDH假设，普通BLS签名方案的安全性即基于此)。



## 再共享协议

基础DKG协议可以被很容易地修改，因此不需要创建一个新的随机密钥$x$的共享，而是创建一个先前共享密钥的新随机共享。

- 修改基础协议的第1步，以便每个节点可以广播已有共享片段的已签名dealing
- 修改第2步，以便就$t$个有效的已签名dealing集合达成共识。此外，每个dealing都经验证以确保是现有共享片段的dealing（这意味着在第$i$个dealing中$A_{i,0}$的值应当等于$V_i$的旧值）。
- 第3步中，通过计算$i$个拉格朗日插值系数的和（和乘积），等于新的$x_j$（和$V_j$）。





# 链钥密码学Ⅱ：链演进技术

如[章节1.6.2](#1.6.2 链演进技术（Chain-evolution technology）)所述，链钥密码学包括一系列复杂的技术，用于健壮和安全地持续维护基于区块链的复制状态机，合起来我们称之为**链演进技术**。每个子网在包含多轮（通常大约是几百轮）的**时期**（Epoch）内运行。链演技术实现了许多按时期定期执行的基本维护工作：*垃圾回收，快速转发，子网成员变更，主动秘密再共享和协议升级。*

链演进技术包含两个基本组成部分：**摘要块（Summary Bblocks）**和**追赶包（Catch-Up Packages，以下简称CUPs）**。

## 摘要块

每个时期的第一个区块是**摘要块**。摘要块包含特殊数据，用于管理不同阈值签名方案的密钥片段（详见[第3章](#3 链钥密码学I：阈值签名)）。其中有两种阈值签名方案：

- 阈值结构为$(f+1)/n$的方案中，每个时期生成一个新的签名密钥；（三分之一）
- 阈值结构为$(n-f)/n$的方案中，每个时期重新共享一次签名密钥。（九分之七）

阈值低的方案用于*随机信标*和*随机磁带*，而阈值高的方案用于验证子网的复制状态。

回想一下，DKG协议（详见[章节3.5](#3.5 基础DKG协议)）要求，对于每个签名密钥，有一个dealing的集合，而每个副本可以根据这组dealing，非交互式得获取它的签名密钥片段。

再回想一下，除了别的之外，NNS还维护着决定子网成员的**注册表**（详见[章节1.5](#1.5 权限模型)）。注册表（以及子网成员）会随时间改变。因此，子网必须在不同时间出于不同目的，对使用的**注册表版本**达共识。这一信息也存储在摘要块中。

时期 $i$ 的摘要块包括如下数据字段。

- $currentRegistryVersion$。这个注册表版本将决定时期 $i$中的*共识委员会（consensus committee）*—所有共识层的任务（生成区块，公证，最终确认）都由这个委员会执行。

- *$nextRegistryVersion$。*在每一轮共识中，区块生成者会将其知道的最新注册表版本（不得早于提议的区块的构建时间）包含在区块提案内。这确保了时期$i$中的*nextRegistryVersion*是最新值。

    时期 $i$中的$currentRegistryVersion$值设置为时期$i-1$中的$nextRegistryVersion$值。

- $currentDealingSets$。这个dealing集用于决定时期$i$中签名消息的阈值签名密钥。

    正如我们所看到的，时期 $i$中的阈值签名委员会是时期$i-1$中的共识委员会。

- $nextDealingSets$。这个字段收集和存储时期$i-1$中*收集到*的dealing[^6]。时期 $i$中的$currentDealingSets$的值将被设置为时期$i-1$中$nextDealingSets$的值（本身包含时期$i-2$中收集到的dealing）。

- $collectDealingParams$。这个字段描述了时期$i$中需要*收集*的dealing集的参数。时期 $i$中，区块生成者会将经这些参数验证有效的dealing，放进提议的区块内。

    Dealings的*接受委员会*基于时期$i$的摘要块的$nextRegistryVersion$。

    对于低阈值的签名方案，时期$i$中的*交易委员会*是时期$i$中的共识委员会。

    对于高阈值的签名方案，密钥片段的共享是基于时期$i$中的$nextDealingSets$。因此时期$i$中的*交易委员会*是时期$i-1$中的*接受委员会*，也是时期$i$中的*共识委员会*。

    还要注意的是，时期$i$中的阈值签名委员会是时期$i-2$中的接受委员会，其是时期$i-1$中的共识委员会。

时期$i$中的共识协议依赖于时期 $i$中的$currentRegistryVersion$和$currentDealingSets$ —— 具体来说，

* 共识委员会本身基于*$currentRegistryVersion$*，

* 共识中的随机信标基于$currentDealingSets$。

此外，同其他区块一样，在时期$i$开始的时候可能会有多个经过公证的摘要块，并且这种歧义需要在时期$i$中经过共识来解决。这种看似循环的问题的解决办法是，保证时期$i-1$开始时的摘要块，在时期$ i$开始前已经被最终确认，因为新的摘要块的相关值，是直接从老的摘要块复制而来。这实际上是一个*隐含的同步假设*，但它更是一个学术假设。事实上，因为[章节5.12.2](#5.11.2 区块生成详述)中讨论的确保活性的“共识降速（consensus throttling）”，也因为时期的长度很长，下面的情况本质上不可能发生：早在共识进展到时期$i-1$结束之时，时期$i-1$的摘要块没有被最终确认，公证延迟函数将增长到非常之大，因此最终确认需要的部分同步假设（实际上）肯定会（基本）满足[^7]。

[^6]: 我们省略的一个细节是，如果在时期$i-1$中，我们没有收集到所有需要的交易，那么作为备选方案，时期$i$中的下一交易集的值将被设置为时期$i$中的$currentDealingSets$的值。如果这种情况发生，那么协议将酌情使用之前的交易委员会和阈值签名委员会。
[^7]: 另外需要注意的是，时期$i$中收集的交易取决于时期$i$的摘要块，具体来说，就是$nextDealingSets$和$nextRegistryVersion$。因此在时期$i$的摘要块被最终确定之前，这些交易不应当生成且不能被验证。



## Catch Up Packages

在阐述 CUP 之前，我们首先需要指出随机信标的一个细节：每一轮的随机信标取决于前一轮的随机信标。它不是 CUP 的基本特性，但是影响了 CUP 的设计。

**CUP**是一种特殊的（不在区块链上的）消息，它（基本上）拥有一个节点副本在不知道先前时期任何信息下，在时期的起始点开始工作时所需的一切。它包含如下的数据字段：

- **整个**复制状态的默克尔哈希树的根（与[章节1.6](#1.6 链钥密码学（Chain-key cryptography）)中的每轮验证的部分状态不同）。
- 时期的摘要块。
- 时期第一轮的随机信标。
- 子网对上述字段的$(n-f)/n$的阈值签名。

为生成给定时期的CUP，节点副本必须等到该时期的摘要块已经被最终确认，并且对应的每轮状态经过验证。如前所述，*整个*复制状态必须经哈希函数处理为一个默克尔树—尽管有很多技术用于加快这一过程，这个成本代价仍然非常大，这也是为什么每个时期仅处理一次。因为CUP仅包含这个默克尔树的根，因此我们使用了一个**状态同步**子协议，允许节点副本从对等节点中提取它所需要的任何状态—同样地，我们用了很多技术来加快这一过程，它的成本代价仍然很大。因为我们对CUP使用了高阈值签名，因此可以保证在任何时期只有一个有效的CUP，而且可以从很多对等节点中提取状态。同时，阈值签名方案的公钥保持一致，CUP可以在不知道当前子网的参与节点的情况下验证。



## 链演进技术实现

**垃圾回收：**因为CUP包含特定时期的信息，因此每个节点副本可以安全地清除该时期前所有已处理的输入，以及对这些输入排序的共识层消息。

**快速转发：**如果一个子网中的节点副本大幅落后于其同步节点（因为其宕机或是网络断连很长时间），或是一个新的节点副本被添加入子网，他们可以通过快速转发至最新时期的起始点，不需要运行共识协议并处理该点之前的所有输入。该节点副本可以通过获取最新CUP做到。利用从CUP中包含的摘要块和随机信标，以及来自其他节点副本的（还没有被清除的）共识消息，该节点副本可以从相应时期的起始点开始，向前运行共识协议。该节点也可以使用状态同步子协议来获取对应时期开始时的复制状态，这样它也可以开始处理共识层产生的输入。

图5描绘了快速转发。此处，我们假设需要一个需要追赶的节点副本处于时期起始点，（比方说）块高为101，有一个CUP。这个CUP包含了块高101的复制状态的默克尔树的根，块高101的摘要块（绿色标识）和块高101的随机信标。该节点会使用状态同步子协议，从它的对等节点中获取块高101的所有复制状态，并用CUP中的默克尔树来验证此状态。在获取到该状态后，节点副本可以参与到协议之中，从对等节点中获取块高102，103等等的区块（以及其他和共识相关的消息），并更新其复制状态的副本。如果其对等节点已经确认了更高高度的区块，该节点副本将尽快处理（以及公证和最终确认）这些从对等节点获取的已最终确认区块（以执行层所允许的最快速度）。

<img src="assets/1.ChainKey/图5：快速转发.png" alt="截屏2022-02-13 23.36.57" style="zoom:80%;" />

<center>图5：快速转发</center>

**子网成员变更：**我们已经讨论过特定时期内，如何使用摘要块来加密，使用哪个版本的注册表以及它如何决定子网成员，更具体来说，是各种任务的委员会成员。需要注意的是，即使一个节点副本从一个子网中移除，（如果可能的话）它应当额外履行一个时期的所分配到的委员会职责。

**主动秘密再共享：**我们已经讨论过了，如何使用摘要块生成和转发签名密钥。如有必要，需要的摘要块也可以从CUP中获取。

**协议升级：**CUP 也可用于协议升级。协议升级由 NNS 发起（详见[章节1.5](#1.5 权限模型)）。不考虑所有细节，基本细节如下：

- 当需要安装新版本的协议时，时期开始时的摘要块会做出指示；
- 所有运行老版本协议的节点副本，将继续运行共识协议直到最终确认摘要块并创建对应的CUP；然而，他们只会创建空区块，并不会将任何荷载传递给消息路由层和执行层；
- 安装新版本的协议后，运行新版本共识协议的节点副本，将从上述的CUP开始继续运行完整的协议。











链密钥密码学

Internet Computer 协议使用一组先进的密码学机制，统称为链密钥密码学，这使得 IC 能够实现其他区块链无法实现的功能和可扩展性。

链密钥密码学的关键组成部分是阈值签名方案，它类似于普通的数字签名方案，只是将秘密签名密钥在子网中的所有副本之间分发，以便密钥不能通过攻击子网中的一个（甚至大部分）副本而被盗。这项技术有很多优势，包括：

* 任何人都可以通过简单地验证签名而无需同步整个区块链来验证从 Internet Computer 收到的内容。
* IC 的拓扑结构可以自主演变 -- 可以添加新的节点和子网，可以恢复故障节点，并可以自主升级协议。
* 提供一个无法预测和无法偏倚的伪随机数源，供 Canister 使用。Canister 可以安全地运行需要随机性的算法。



链密钥签名

链密钥签名扩展了链密钥技术，允许针对其他区块链的交易在链上使用 Internet Computer 协议完全计算。通过链密钥签名，IC 可以与比特币和以太坊等其他区块链完全无信任地集成，无需任何桥接。Canister 现在可以安全地存储和交易比特币。比特币的私钥在运行 Canister 的所有节点之间共享。当至少三分之二的节点同意进行交易时，Canister 可以使用链密钥签名的交易进行比特币交易。事实上，使用链密钥签名是整合区块链的最强大、最分散的方式，因为除了两个区块链之外，不需要任何其他信任假设，尤其是不需要管理签名密钥或其份额的其他方。



比特币整合

Internet Computer 上的比特币整合基于两个支柱：链密钥签名和 Internet Computer 节点与比特币对等网络之间的直接互动。虽然链密钥签名使 Canister 可以拥有自己的比特币地址并创建有效的交易，用于支付这些地址持有的比特币，但 Internet Computer 和比特币网络之间的直接消息交换用于在 Internet Computer 中维护关于比特币区块链状态的信息（如地址余额），并将 Canister 发起的比特币交易传输到比特币网络。



链密钥代币

链密钥代币 —— 以及链密钥比特币（ckBTC）—— 是一种基于密码学的替代包装代币，具有强大的去中心化优势：链密钥代币消除了传统基于中介的代币包装所带来的风险，同时还具有使来自其他区块链的代币可用于转账和交易的优势。链密钥密码学使这成为可能：以比特币为例，Canister 智能合约可以拥有 ECDSA 密钥对，并派生出可以在比特币网络上进行真实比特币转账的比特币地址。当接收到比特币时，Canister 以 1:1 的比例向比特币的发送者铸造并发行 ckBTC。相反，兑换 ckBTC 为基础比特币会将 ckBTC 从流通供应中移除并退还比特币。这使得链密钥代币成为具有相同属性和估值的原始代币的“双胞胎”，但托管在 Internet Computer 上。







这段文字详细介绍了一个阈值签名方案及其匹配的分布式密钥生成协议，包括各种算法。阈值签名方案的目标是防止未授权签名，确保只有达到阈值的参与者共同参与签名过程。

在安全性定义中，诚实的参与者可以生成新的公钥，这些公钥对敌手是公开的。我们假设公钥具有足够的熵以唯一标识参与者。敌手可以在满足某些条件的情况下，要求参与者更新解密密钥。

参与者有时会创建新的阈值签名验证密钥，并分配相应的签名密钥份额。敌手可以决定何时创建新的验证密钥，但需要提供一个参与者配置以及阈值和纪元。此外，敌手可以触发诚实的交易创建，模拟诚实参与者运行交易算法。所有诚实的交易都包含在 Qd 集合中。

之后，敌手可以将诚实的交易与自己的任意交易组合，生成一个让互联网计算机识别的新公钥。在安全性定义中，我们要求敌手在交易记录中至少包括一个诚实的交易。如果交易记录被接受，交易将组合导出一个验证密钥，该密钥将注册在 Qvk 中。

参与者有时还希望重新共享现有的秘密阈值签名密钥。在这种情况下，敌手也需要创建一个配置，但这次配置必须引用先前的配置和它所依赖的现有公钥的交易记录。被诚实节点处理的分享签名密钥也会被记录。

诚实的参与者可以使用分享签名密钥为任意消息提供签名份额。在我们的模型中，我们让敌手控制何时以及哪个参与者为哪个消息签名。

在互联网计算机上，诚实的参与者会在分享签名密钥过时时擦除它。当然，只有在参与者无法再通过解密密钥恢复分享签名密钥时，擦除才有意义。因此，我们只允许敌手要求擦除无法再次被诚实参与者恢复的分享签名密钥。

最后，我们的安全模型旨在捕获动态腐败，因此我们允许敌手腐化参与者。每当敌手腐化一个参与者时，她会了解到该参与者拥有的所有相关数据，如解密密钥和所有未擦除的份额。此后，与该参与者有关的记录将被删除，因为模型只记录诚实参与者，而敌手现在可以代表该参与者行动。
