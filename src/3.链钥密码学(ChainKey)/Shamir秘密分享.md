### 去中心化秘密共享方案

自从密钥共享方案诞生以来，大量的不同环境下的密钥共享方案己经被提了出来。大部分的方案中都假设存在一个可信中心密钥分发者，负责将密钥分割成为子密钥，并且安全密钥的将子密钢发送给参与者。但是在实际环境中，可信中心往往是不存在的。所以一种新的无可信中心的密胡共享协议被提了出来以适应没有可信中心的环境。

在无可信中心的密钥共享中，子密朗的产生和分配都是由参与者本身合作完成的。在实际应用中，有可信中心的密朗共享可能存在可信中心的“权威欺骗”，并且在现实中需要成员具有较高的可信度也不是明智的假设。因此，和有可信中心的密钥共享相比，无可信中心的密钥共享安全性更高，实用性更强。

对无可信中心密钥共享研究的主要目的就是：寻找合适的方案来保证信息能够安全，有效地发布和传输。此外，无可信中心密明共享中的子密钥如何分发，是人们研究的热点问题，其发展空间还很大。因此，无可信中心密钥共享不仅存在着重要的理论价值，更在实际应用中存在着广泛的应用前景。目甜对于无可信中心的密明共享的应用主要集中在数字签名方面。对无可信中心的密明共享的加密研究并不多。下面是笔者个人提出的一种去中心化秘密共享方案。

去中心的化密钥共享方案实际上就是把密钥拆分成 n 份之后，对每一份秘密进行加密，然后将他们存储到区块链上去，这样可以解决密钥的分发存储。密钥发送到相应的节点后，该节点先对密钥做二次加密，签名，然后写到区块链上，当密钥恢复者需要恢复密钥时，它可以全网广播一条恢复密钥的信息，然后付给密钥段存储节点一定的 token，密钥存储节点验证密钥并解密之后发送给恢复密钥的客户端。这样就可以达到去中心的秘密共享的目标。

### （t，n）门限的动态秘密共享方案

1979 年 Shamir 和 Blakley 分别提出了一个（t，n）门限秘密共享方案，Shamir 的（t，n）门限方案是基于 Lagrange（拉格朗日）插值法来实现的，它通过构造一个 t-1 次多项式，并将需要共享的秘密作为该多项式的常数项，每个份额（子秘密）为满足该多项式的一个坐标点，由 Lagrange 插值定理可知，任意 t 个份额（子秘密）可以重构该多项式从而恢复秘密，而 t-1 个或更少的份额（子秘密）不能重构该多项式，因而得不到关于秘密的任何信息。

动态秘密共享体制的提出主要源于秘密共享方案的安全性问题。在（t，n）门限秘密共享方案中，方案的安全性是建立在攻击者不可能在秘密的生命周期内获取 t 个子秘密的前提之下的。然而实际上很难保证这一点，尤其是在秘密的生命周期较长的情况下，这一点就更难以保证。可验证秘密共享方案主要用来解决传统秘密共享方案中存在的分发者不诚实性问题和子秘密持有者的不诚实性问题，而面对敌手的破坏性攻击，可验证秘密共享方案并没有更好的安全性。

当然，对于周期上的安全性，可以通过不断更换秘密的办法得到解决，但是更换秘密并不总是可行的（比如说该秘密是一个重要文件或是一些军事、商业秘密等）。动态秘密共享方案通过在不改变秘密的情况下解决了秘密共享方案在周期上的安全性问题。动态秘密共享方案在保证秘密不变的情况下周期性地更换子秘密，从而使得每次更换子秘密时攻击者在前一个周期内所获得的信息完全失效。

这样一来，就可以根据可能受攻击程度的不同来相应地决定子秘密更换周期的长短，以保证在每一个周期内秘密的安全性。动态秘密共享还要保证过期的子秘密所包含的信息不会对未来秘密的构造产生不安全的影响。

#### 5.1 Amir Herzberg 方案

有关动态秘密共享的方案已有不少，Amir Herzberg 提出的方案是很经典的一个，方案是对 Shamir 的秘密共享方案实现动态化。

分发者 D 选择一个有限域 GF(q)（q 为大素数），为了方便说明，用 i 代替 Shamir 方案中的 xi的。在第 k 个时段，Pi 持有的子秘密用 si(k)(si 的 k 次方) 表示。

子秘密更新协议：每个时段开始时要进行子秘密更新，进入第 k 时段后，Pi 持有的子秘密要从 si(k-1) =f(k-1)（i）更新至 si(k) ，其中 f(k-1) (0) = s。整个过程如下：



更新后的子秘密显然符合门限秘密共享的要求，任意大于或等于 t 个参与者利用 Lagrange 插值法可恢复秘密。之后 Amir Herzberg 等人在他们的这篇文章中进一步提出了一个防止主动攻击的子秘密更新方案，并增加了可验证性，进一步加强了方案的安全性。

#### 5.2 Amir Herzberg 方案的改进

事实上 Amir Herzberg 的子秘密更新方案相当于 n 个参与者协商了一个常数项为零的 t-1 次多项式，事实上少于 n 个参与者也可以进行子秘密更新，步骤和原方案相同，如果参与子秘密更新的参与者少于门限值 t 时，可以对此方案进行改进，使它具有更好的灵活性和执行效率，方案描述如下： 



##### 5.2.1 AMIR HERZBERG 方案的改进分析

这样 k（k<t）个参与者就实现了子秘密的更新，并且这个方案有很大的灵活性，在步骤（3）中，只需对 si′=si+χ·i ic 中 i 的次数进行修改，使次数大于 t-k 就可以提高门限值，如 si′=si+χ·iit-k+θ，方案中的门限值就是 t+θ，这相当于把储存秘密 s 的多项式变为 t+θ-1 次多项式。由于参与子秘密更新的成员只需选择一随机数，并进行简单的直和分解运算，与原方案相比执行效率很高。由于传递信息是通过安全信道，安全性可以得到保证。Amir Herzberg 的子秘密更新方案相当于 n 个参与者协商了一个常数项为零的 t-1 次多项式，给出参与子秘密更新的参与者少于门限值 t 也可以进行子秘密更新，并具有更好的灵活性和执行效率。进一步考虑，对于参与子秘密更新的人数大于或等于门限值时，即 k≥t 时，此方案仍可以更新子秘密，但是门限值却会发生变化，不太适合需要保持门限值不变的场合，没有 k<t 时方案更加灵活。











好的,我来详细讲讲Shamir秘密分享的密码学原理。

Shamir秘密分享是一种门限秘密分享方案,由Adi Shamir在1979年提出。它的基本思想是:

1. 选取一个质数p和一个秘密数s,s属于0到p-1之间。

2. 选择一个t-1次多项式,其中a0=s,其余系数a1到at-1是随机数。

3. 将多项式在n个不同的点x上进行求值,得到n个值y1到yn。其中每个yi就是这个秘密的一个分享。

4. t个或以上的分享可以通过重构多项式来求得秘密数s。而少于t个分享无法得到足够的信息来推算出s。

举个例子,假设p=23,s=15,t=3,n=5,那么可以构造一个2次多项式:

f(x) = a0 + a1x + a2x2 

其中a0=15, a1和a2是随机数,比如a1=5,a2=7。

那么:

f(1) = 15 + 5*1 + 7*12 = 32 mod 23 = 9   (分享1)

f(2) = 15 + 5*2 + 7*22 = 83 mod 23 = 3    (分享2) 

f(3) = 15 + 5*3 + 7*32 = 180 mod 23 = 11   (分享3)

f(4) = 15 + 5*4 + 7*42 = 339 mod 23 = 17   (分享4)

f(5) = 15 + 5*5 + 7*52 = 552 mod 23 = 13  (分享5)

任意3个分享都可以重构这个2次多项式,从而计算出系数a0=15,也就是最初的秘密。而2个或少于2个分享不足以求出a0。

数学原理上,t个分享点(x, y)可以唯一确定一个t-1次多项式。Shamir秘密分享使用的是拉格朗日插值法来从t个分享重构这个多项式。

对于每个分享点(xi, yi),定义一个拉格朗日基多项式:

Li(x) = (x - x1)...(x - xi-1)(x - xi+1)...(x - xt) / ((xi - x1)...(xi - xi-1)(xi - xi+1)...(xi - xt))

可以验证,这个多项式在点xj处取值为:

Li(xj) = 1 if i = j

Li(xj) = 0 if i != j

那么秘密多项式可以表示为:

f(x) = Σ yi * Li(x)  

其中i遍历给定的t个分享点。

代入x=0,就可以得到最初的秘密a0=s。

这就是Shamir秘密分享的数学基础。它利用了多项式插值的性质,只需要t个点就可以唯一定义一条曲线,从而重构出秘密。而少于t个点给出的信息是不足以确定曲线的。

Shamir秘密分享还有一些其他特性:

1. 完美的秘密:少于t个分享无法得到任何信息。

2. 理想的门限:只需要t个分享就可以完全恢复秘密。

3. 可以检验:可以确认一个分享是否正确。

4. 可以重构:可以从t-1个真实分享和一个假分享恢复真实秘密。

综上,Shamir秘密分享利用多项式插值理论,实现了完美的门限秘密分享方案,是许多密码系统中的一个重要组件。







好的,拉格朗日插值是实现Shamir秘密分享的关键 mathematical 原理,我来详细解释它的原理。

拉格朗日插值法可以从一组离散的点来唯一确定一个多项式。

其背后的思想是,对于一个n次多项式:

f(x) = a0 + a1x + a2x^2 + ... + anx^n

如果我们知道这个多项式在n+1个不同的点上的取值,那么就可以通过解方程组的方法求解出a0到an这n+1个未知系数,从而确定这个n次多项式。

比如给定3个点:

f(x1) = y1 

f(x2) = y2

f(x3) = y3

我们可以构建出以下方程组:

a0 + a1x1 + a2x1^2 = y1 

a0 + a1x2 + a2x2^2 = y2

a0 + a1x3 + a2x3^2 = y3

解这个方程组就可以求出a0,a1,a2,从而确定这个2次多项式。

那么,拉格朗日插值法的思路就是,我们直接构建出passes 通过给定点的多项式,而不需要明确求出多项式的系数。

对于每个点(xi, yi),定义一个多项式Li(x),它满足:

Li(xj) = 1,如果i=j

Li(xj) = 0,如果i!=j

这样的一个多项式称为拉格朗日基函数。它有着可以取任意指定值的“单点插值”性质。

那么我们可以将所有基函数加总,就得到了一个 passes 通过所有给定点的多项式:

$$
f(x) = Σ yi * Li(x)
$$
这个多项式明确地passes 通过所有给定的数据点。

比如给定3个点(1,1),(2,4),(3,9),对应的基函数为:

$$
L1(x) = (x-2) / (1-2) * (x-3) / (1-3) = x(x-3)/2
$$

$$
L2(x) = (x-1) / (2-1) * (x-3) / (2-3) = -(x-3)/2
$$

$$
L3(x) = (x-1) / (3-1) * (x-2) / (3-2) = (x-1)(x-2)/2
$$

构建出的多项式为:

$$
f(x) = 1*L1(x) + 4*L2(x) + 9*L3(x)
$$

$$
= 1*x(x-3)/2 -4*(x-3)/2 + 9*(x-1)(x-2)/2
$$

可以验证这个多项式 passes 过指定的3个点。

这就是拉格朗日插值法的基本思路,通过构建具有“单点插值”性质的基函数,直接产生一个passes 过所有给定离散点的多项式,而不需要明确计算多项式的系数。

在Shamir秘密分享中,利用的是代入x=0时,上述多项式等于a0,也就是最初的秘密数s。所以有了t个点,就可以通过拉格朗日插值直接重构出这个秘密。

拉格朗日插值法避免了复杂的系数求解,通过巧妙地构造基函数,实现了从离散点到多项式的简便插值。这是它在Shamir秘密分享等密码应用中的数学基础。





您好,我理解您没有高等数学基础,那么我会尽可能用简单直白的语言和具体例子,详细解释拉格朗日插值法的原理。

我们首先来看一个简单的例子:

假设我们有这样3个点:(1, 2) , (2, 5) , (3, 10)

这代表如果x=1时,y=2
如果x=2时,y=5
如果x=3时,y=10

我们 Plot 出这3个点,可以看到他们大概在一条曲线上分布:

(1,2)  (2,5)   (3,10)

        ●      ●        ●

我们该如何表达这个曲线呢?这里就要用到多项式方程:

y = a + bx + cx2 

也就是说,我们需要找到这样一个方程,它带入x和y的值,恰好通过我们已经知道的这3个点。

为了找到a,b,c的值,我们把已知的x和y带入方程:

当x=1时,y=2 =>   2 = a + b + c
当x=2时,y=5 =>   5 = a + 2b + 4c  
当x=3时,y=10 =>  10 = a + 3b + 9c

同时解这3个方程,我们可以得到:
a = 2
b = 1
c = 1

所以这个通过这3个点的多项式方程为:

y = 2 + x + x2

我们成功通过3个点,得到一个多项式方程!

这个方法叫做拉格朗日插值法,它让我们不需要自己推导复杂的方程,而是通过已知的点直接得到多项式。

在Shamir秘密分享里,利用的是这个方程中a的值刚好等于最初的秘密数。

所以,如果我有3个点的信息,就可以直接把它们带入拉格朗日插值法,求得a的值,也就是最初的秘密!而少于3个点的信息是不够的。

我尽可能用直白简单的语言和具体例子解释了拉格朗日插值法。它实际上避免了求解方程组来直接得到过指定点的多项式的方程。这也是它在Shamir秘密分享中的数学基础。如果有哪里还不清楚,请告诉我,我会继续补充解释。





> 所以已知的点是怎么变成密钥的？

Shamir的秘密共享方案利用了拉格朗日插值的特性来实现密钥的分割和重组。在这个方案中，密钥（或者说秘密）就是那个我们想要通过插值法找回的多项式的常数项。这就是如何将"点"和"密钥"关联起来的。

具体来说，如果我们有一个秘密（或者说密钥），我们首先创建一个多项式，这个多项式的常数项就是我们的秘密。然后我们在这个多项式上选择几个点（通常选择的点的数量比我们想要重构密钥需要的点的数量多），每个点的x坐标和y坐标就成为一份秘密份额。所以，每一个秘密份额就是一对数值：一个x坐标和一个y坐标。这就是如何把点变成密钥的。

然后，我们可以把这些份额分发给参与者。只有当收集到足够多的份额（至少等于多项式的次数加一）时，我们才能用拉格朗日插值法找回原始的多项式，从而找回我们的秘密（或密钥）。每个参与者只拥有一个秘密份额，而不是整个密钥，所以这个方案提供了一种分布式的、安全的密钥管理方法。



> 所以已知的点是怎么变成密钥的？通过什么算法。那阈值秘密共享的原理呢？

您的问题点到了关键所在,让我继续详细解释一下:

1. 已知的点是如何变成密钥的

在 Shamir 秘密共享中,我们选择一个秘密数字s,这个数字就是我们要分享的密钥。

然后构造一个过点(0, s)的 t-1 次多项式,也就是说这个多项式在 x=0 时等于 s。

接着在 n 个不同的 x 坐标点上求值,就得到了 n 个点的坐标 (x1, y1),...,(xn, yn)。

这 n 个坐标点就是这个密钥 s 的分享。注意,其中 xi 是公开的,而 yi 是保密的。

每个人持有一个分享 (xi, yi),就拥有了部分的密钥信息。

1. 怎么通过算法恢复密钥

当我们收集到至少 t 个分享 (xi, yi) 时,就可以通过拉格朗日插值法求出过这 t 个点的多项式。

我们代入 x=0,就可以直接得到这个多项式在 x=0 时的值,也就是最初的密钥 s。

所以算法是:

(1) 收集至少 t 个分享 (xi, yi)

(2) 使用拉格朗日插值法,构造过这 t 个点的多项式函数 f(x)

(3) 计算 f(0),得到最初的密钥 s

1. 阈值秘密共享的原理

阈值秘密共享的原理在于:

t-1 次多项式可以由 t 个点唯一确定,但少于 t 个点无法确定。

Shamir 使用的是 t-1 次多项式来分享密钥,这样至少需要 t 个分享才能重构多项式和密钥。

同时,少于 t 个分享无法得知任何关于密钥的信息。这保证了到达一个“门限"t 才能获取密钥。

所以阈值秘密共享实际上是一个 (t, n) 的门限方案。它使用拉格朗日插值的数学原理,实现了一个完美的门限秘密分享方案。

我尽量用简单直白的语言和算法步骤详细解释了整个密钥生成和恢复的过程。如果还有不清楚的地方,请您提出来,我会继续详细说明。
